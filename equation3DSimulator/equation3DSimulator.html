<!doctype html>
<html version="1.7.22" by="huynoobz" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Equation 3D Simulator</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; color: #eaeaea; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #app { position: fixed; inset: 0; overflow: hidden; }
    #ui-panel {
      position: fixed;
      left: 12px;
      top: 12px;
      width: min(420px, calc(100vw - 24px));
      max-height: calc(100vh - 24px);
      overflow: auto;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      z-index: 5;
    }
    #ui-panel.is-hidden { display: none; }
    #ui-panel .header { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 10px; }
    #ui-panel .title { font-weight: 700; margin: 0; }
    #ui-panel .close-btn {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #eaeaea;
      cursor: pointer;
      font-size: 18px;
      line-height: 32px;
      padding: 0;
    }

    #open-controls {
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 6;
      display: none;
      padding: 9px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: #eaeaea;
      cursor: pointer;
      backdrop-filter: blur(8px);
    }
    #open-controls.is-visible { display: inline-block; }
    #ui-panel .row { margin-bottom: 10px; }
    #ui-panel .preset-controls { display: flex; gap: 8px; align-items: center; }
    #ui-panel .preset-controls select { flex: 1 1 auto; }
    #ui-panel .preset-mini-btn {
      width: auto;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #eaeaea;
      cursor: pointer;
      white-space: nowrap;
    }
    #ui-panel .preset-mini-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    #ui-panel label { display: block; font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    #ui-panel textarea, #ui-panel input, #ui-panel select {
      width: 100%;
      box-sizing: border-box;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.15);
      color: #eaeaea;
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }
    #ui-panel textarea { min-height: 64px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    #ui-panel .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    #ui-panel .buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    #ui-panel button {
      width: 100%;
      padding: 9px 10px;
      border-radius: 10px;
      background: rgba(255, 211, 107, 0.12);
      border: 1px solid rgba(255, 211, 107, 0.25);
      color: #ffd36b;
      cursor: pointer;
    }
    #ui-panel button.secondary {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #eaeaea;
    }
    #ui-panel .hint { font-size: 12px; opacity: 0.78; line-height: 1.35; }
    #error {
      position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
      padding: 10px 12px; border-radius: 10px;
      background: rgba(140, 20, 20, 0.85); border: 1px solid rgba(255,255,255,0.12);
      max-width: min(900px, calc(100vw - 24px));
      display: none; white-space: pre-wrap;
    }
    #notice {
      position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
      padding: 10px 12px; border-radius: 10px;
      background: rgba(20, 110, 40, 0.85); border: 1px solid rgba(255,255,255,0.12);
      max-width: min(900px, calc(100vw - 24px));
      display: none; white-space: pre-wrap;
    }
    /* Right settings panel (no dat.gui) */
    #settings-panel {
      position: fixed;
      right: 12px;
      top: 12px;
      width: 340px;
      max-width: calc(100vw - 24px);
      max-height: calc(100vh - 24px);
      overflow: hidden;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      backdrop-filter: blur(8px);
      z-index: 6;
      display: flex;
      flex-direction: column;
    }
    #settings-panel.is-hidden { display: none; }
    #settings-panel .settings-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 10px 6px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    #settings-panel .settings-title { font-weight: 700; opacity: 0.95; }
    /* Close button in header: wrap to content (no full-width) */
    #settings-close {
      width: auto;
      min-width: 34px;
      height: 34px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #eaeaea;
      cursor: pointer;
      font-size: 18px;
      line-height: 32px;
      padding: 0 10px;
    }
    #settings-body {
      overflow: auto;
      padding: 10px;
      display: grid;
      gap: 10px;
    }
    #settings-panel.is-collapsed #settings-body { display: none; }
    #settings-panel label { display: block; font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    #settings-panel input, #settings-panel select {
      width: 100%;
      box-sizing: border-box;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.15);
      color: #eaeaea;
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }
    #settings-panel .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    #settings-panel button {
      width: 100%;
      padding: 9px 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #eaeaea;
      cursor: pointer;
    }
    /* Override for header button */
    #settings-panel .settings-header button { width: auto; padding: 0 10px; }
    #open-settings {
      position: fixed;
      right: 12px;
      top: 12px;
      z-index: 7;
      display: none;
      padding: 9px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: #eaeaea;
      cursor: pointer;
      backdrop-filter: blur(8px);
    }

    /* Controller sections */
    .section-title {
      margin: 10px 0 6px;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0.75;
    }
    .section-title.is-collapsible {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 6px 8px;
      border-radius: 10px;
    }
    .section-title.is-collapsible:hover {
      background: rgba(255,255,255,0.04);
    }
    .section-title.is-collapsible::after {
      content: "▾";
      opacity: 0.85;
      transform: rotate(0deg);
      transition: transform 120ms ease;
    }
    .section-title.is-collapsible.is-collapsed::after {
      transform: rotate(-90deg);
    }
    .section-title.is-collapsible.is-collapsed + .section-box {
      display: none !important;
    }
    .section-box {
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 10px;
    }

    /* FPS crosshair (shown only during pointer lock) */
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 8;
      display: none;
      pointer-events: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 18px;
      line-height: 18px;
      color: rgba(255,255,255,0.9);
      text-shadow: 0 0 6px rgba(0,0,0,0.8);
      user-select: none;
    }

    /* Basic/Advanced toggle removed: always show all controls */
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="error"></div>
  <div id="notice"></div>
  <div id="crosshair" aria-hidden="true">+</div>
  <button id="open-settings" title="Open settings" style="display:none;">Settings</button>
  <div id="settings-panel">
    <div class="settings-header">
      <div id="settings-title" class="settings-title">Settings</div>
      <button id="settings-close" title="Close settings" aria-label="Close settings">-</button>
    </div>
    <div id="settings-body">
      <div>
        <label id="settings-lang-label">Language</label>
        <select id="settings-language">
          <option value="vi">Tiếng Việt</option>
          <option value="en">English</option>
        </select>
      </div>
      <div class="grid">
        <div>
          <label id="settings-axes-label">Show axes</label>
          <select id="settings-axes">
            <option value="1">On</option>
            <option value="0">Off</option>
          </select>
        </div>
        <div>
          <label id="settings-mode-label">Render mode</label>
          <select id="settings-mode">
            <option value="Line">Line</option>
            <option value="Points" selected>Points</option>
          </select>
        </div>
      </div>
      <div>
        <label id="settings-pointsize-label">Point size</label>
        <div class="grid" style="grid-template-columns: 1fr 110px;">
          <input id="settings-pointsize" type="range" min="0.001" max="0.08" step="0.001" value="0.01" />
          <input id="settings-pointsize-num" type="number" min="0.001" max="0.08" step="0.001" value="0.01" />
        </div>
      </div>
      <div>
        <label id="settings-camspeed-label">Camera speed</label>
        <div class="grid" style="grid-template-columns: 1fr 110px;">
          <input id="settings-camspeed" type="range" min="0.2" max="3.5" step="0.05" value="1.0" />
          <input id="settings-camspeed-num" type="number" min="0.2" max="3.5" step="0.05" value="1.0" />
        </div>
      </div>
      <div>
        <label id="settings-mouselock-label">Mouse lock</label>
        <div class="grid" style="grid-template-columns: 1fr;">
          <button id="settings-mouselock-btn" title="Click to lock/unlock mouse">Lock</button>
        </div>
        <div class="hint" id="settings-mouselock-hint" style="margin-top:6px;">
          Click Lock to lock pointer. Move mouse to look around. Press Esc to unlock.
        </div>
      </div>
      <div>
        <label id="settings-mousesense-label">Mouse sensitivity</label>
        <div class="grid" style="grid-template-columns: 1fr 110px;">
          <input id="settings-mousesense" type="range" min="0.2" max="3.0" step="0.05" value="1.0" />
          <input id="settings-mousesense-num" type="number" min="0.2" max="3.0" step="0.05" value="1.0" />
        </div>
      </div>
      <div class="grid">
        <button id="settings-resetview">Reset view</button>
      </div>
    </div>
  </div>
  <div id="ui-panel">
    <div class="header">
      <div id="panel-title" class="title">3D Simulator Controller</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="close-controls" class="close-btn" title="Close controls" aria-label="Close controls">×</button>
      </div>
    </div>

    <div id="section-model" class="section-title">Model</div>
    <div class="section-box">
      <div class="row">
        <label>System category</label>
        <select id="systemType">
          <option value="algebraic" selected>Algebraic System</option>
          <option value="ode_linear">ODE – Linear</option>
          <option value="ode_nonlinear">ODE – Nonlinear</option>
          <option value="map">Discrete Map</option>
          <option value="pde_linear">PDE – Linear</option>
          <option value="pde_nonlinear">PDE – Nonlinear</option>
          <option value="dae">DAE System</option>
          <option value="stochastic">Stochastic System (SDE)</option>
          <option value="hybrid">Hybrid System</option>
          <option value="hamilton">Hamilton/Lagrange System</option>
          <option value="optimization">Optimization / Gradient Flow</option>
          <option value="markov">Markov / Probabilistic System</option>
        </select>
      </div>

      <div class="row">
        <label>Preset</label>
        <div class="preset-controls">
          <select id="preset"></select>
          <button id="save-custom" class="preset-mini-btn" title="Save current Custom as a new preset">Save</button>
          <button id="delete-saved" class="preset-mini-btn" title="Delete selected saved preset" style="display:none;">Delete</button>
        </div>
      </div>
      <div class="row">
        <label>Search presets</label>
        <input id="presetSearch" placeholder="Type to filter presets…" />
      </div>

      <div class="grid row" id="dimproj-row">
    <div>
          <label>
            <span id="dim-label">Dimension N</span>
            <span style="float:right; font-weight:500; opacity:0.9;">
              <input id="dimAuto" type="checkbox" checked style="width:auto; vertical-align:middle; margin-right:6px;" />
              <span id="dim-auto-label">Auto</span>
            </span>
          </label>
          <input id="dim" value="3" title="When Auto is ON: Simple=3, Vector=number of non-empty equation lines." />
        </div>
        <div data-advanced="1" id="proj-row">
          <label>3D projection (x,y,z) indices (1-based)</label>
          <div class="grid" style="grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
            <input id="projX" value="1" title="X component index (1-based)" />
            <input id="projY" value="2" title="Y component index (1-based)" />
            <input id="projZ" value="3" title="Z component index (1-based)" />
          </div>
    </div>
  </div>

      <div class="row" id="eqmode-row">
        <label>Equation mode</label>
        <select id="eqMode">
          <option value="simple" selected>Simple (dx/dy/dz)</option>
          <option value="vector">Vector (N lines)</option>
        </select>
      </div>

      <div class="row">
        <label>Vector equations (one per line). If not empty, this overrides dx/dy/dz. Variables: x1..xN, t, and params.</label>
        <textarea id="eqs" placeholder="Example (ODE):&#10;x1' = x2&#10;x2' = -sin(x1) - 0.1*x2&#10;..."></textarea>
      </div>

      <div id="simple-eqs">
        <div class="row">
          <label>dx/dt = F(x,y,z,t,params)</label>
          <textarea id="dx"></textarea>
        </div>
        <div class="row">
          <label>dy/dt = G(x,y,z,t,params)</label>
          <textarea id="dy"></textarea>
        </div>
        <div class="row">
          <label>dz/dt = H(x,y,z,t,params)</label>
          <textarea id="dz"></textarea>
        </div>
      </div>

      <div class="row">
        <label>Parameters (mỗi dòng: name = value)</label>
        <textarea id="params"></textarea>
      </div>

      <div class="grid row" id="init-row">
        <div>
          <label>Initial (comma-separated, length N)</label>
          <input id="init" value="0.1, 0.1, 0.1" />
        </div>
      </div>

      <!-- PDE (Linear) -->
      <div id="pde-linear-section" class="section-title" style="display:none;">PDE – Linear</div>
      <div id="pde-linear-box" class="section-box" style="display:none;">
        <div class="row">
          <label>PDE type</label>
          <select id="pdeType">
            <option value="heat2d" selected>Heat / Diffusion (2D): u_t = α(uxx + uyy) + S</option>
          </select>
        </div>

        <div class="grid row">
          <div>
            <label>Nx</label>
            <input id="pdeNx" value="90" />
          </div>
          <div>
            <label>Ny</label>
            <input id="pdeNy" value="90" />
          </div>
        </div>

        <div class="grid row">
          <div>
            <label>x min</label>
            <input id="pdeXMin" value="-1" />
          </div>
          <div>
            <label>x max</label>
            <input id="pdeXMax" value="1" />
          </div>
        </div>
        <div class="grid row">
          <div>
            <label>y min</label>
            <input id="pdeYMin" value="-1" />
          </div>
          <div>
            <label>y max</label>
            <input id="pdeYMax" value="1" />
          </div>
        </div>

        <div class="grid row">
          <div>
            <label>α (diffusivity)</label>
            <input id="pdeAlpha" value="0.25" />
          </div>
          <div>
            <label>Boundary</label>
            <select id="pdeBC">
              <option value="dirichlet0" selected>Dirichlet: u=0</option>
              <option value="neumann0">Neumann: ∂u/∂n=0</option>
              <option value="periodic">Periodic</option>
            </select>
          </div>
        </div>

        <div class="grid row">
          <div>
            <label>Z scale</label>
            <input id="pdeZScale" value="1.0" />
          </div>
          <div class="hint" style="margin-top:22px;">
            Variables: <code>x</code>, <code>y</code>, <code>t</code>, params. Use <code>sin</code>, <code>exp</code>, etc.
          </div>
        </div>

        <div class="row">
          <label>Initial condition u(x,y,t=0)</label>
          <textarea id="pdeU0" placeholder="Example: exp(-20*(x^2+y^2))"></textarea>
        </div>
        <div class="row" data-advanced="1">
          <label>Source term S(x,y,t) (optional)</label>
          <textarea id="pdeSource" placeholder="Example: 0"></textarea>
        </div>
        <div class="row" id="pde-nonlinear-row" style="display:none;">
          <label>Nonlinear term N(u,x,y,t) (optional)</label>
          <textarea id="pdeNonlinear" placeholder="Examples: u*(1-u)  or  u - u^3"></textarea>
        </div>
      </div>

      <!-- DAE (index-1 semi-explicit): x' = f(x,y,t), 0 = g(x,y,t) -->
      <div id="dae-section" class="section-title" style="display:none;">DAE</div>
      <div id="dae-box" class="section-box" style="display:none;">
        <div class="grid row">
          <div>
            <label>Nx (differential vars)</label>
            <input id="daeNx" value="1" />
          </div>
          <div class="hint" style="margin-top:22px;">
            State is <code>[x1..xNx, y1..yNy]</code>. Use variables <code>x1..xN</code>, <code>t</code>, params.
          </div>
        </div>
        <div class="row">
          <label>DAE differential equations (Nx lines): x' = f(x,y,t)</label>
          <textarea id="daeF" placeholder="Example (Nx=1):&#10;x1' = -x1 + x2"></textarea>
        </div>
        <div class="row">
          <label>DAE algebraic constraints (Ny lines): 0 = g(x,y,t)</label>
          <textarea id="daeG" placeholder="Example (Ny=1):&#10;0 = x2 - x1^2"></textarea>
        </div>
        <div class="grid row" data-advanced="1">
          <div>
            <label>Newton tol</label>
            <input id="daeTol" value="1e-8" />
          </div>
          <div>
            <label>Newton max iters</label>
            <input id="daeNewtonIters" value="12" />
          </div>
        </div>
      </div>

    </div>

      <!-- Hybrid rules (event + reset) -->
      <div id="hybrid-section" class="section-title" style="display:none;">Hybrid rules</div>
      <div id="hybrid-box" class="section-box" style="display:none;">
        <div class="row">
          <label>Event condition (trigger when this becomes true)</label>
          <input id="hybridEvent" placeholder="Example: x1 >= v_th" />
        </div>
        <div class="row">
          <label>Reset rules (each line: x1 = ..., x2 = ...)</label>
          <textarea id="hybridReset" placeholder="Example:&#10;x1 = v_reset&#10;x2 = spikeAmp"></textarea>
        </div>
        <div class="hint">
          When the event triggers, the solver finds the crossing time inside the current step, advances to it, then applies the reset instantly.
        </div>
      </div>

    <!-- Algebraic (implicit surface) -->
    <div id="alg-section" class="section-title" style="display:none;">Algebraic</div>
    <div id="alg-box" class="section-box" style="display:none;">
      <div class="row">
        <label>Algebraic mode</label>
        <select id="algMode">
          <option value="parametric" selected>Parametric curve (x(t),y(t),z(t))</option>
          <option value="implicit">Implicit surface (F(x,y,z)=iso)</option>
        </select>
      </div>
      <div id="alg-implicit-row" style="display:none;">
        <div class="row">
          <label>F(x,y,z)</label>
          <textarea id="algF" placeholder="Example (sphere): x^2+y^2+z^2-1"></textarea>
        </div>
        <div class="grid row">
          <div>
            <label>iso</label>
            <input id="algIso" value="0" />
          </div>
          <div>
            <label>resolution (N)</label>
            <input id="algRes" value="40" />
          </div>
        </div>
        <div class="grid row">
          <div>
            <label>x min</label>
            <input id="algXMin" value="-1.5" />
          </div>
          <div>
            <label>x max</label>
            <input id="algXMax" value="1.5" />
          </div>
        </div>
        <div class="grid row">
          <div>
            <label>y min</label>
            <input id="algYMin" value="-1.5" />
          </div>
          <div>
            <label>y max</label>
            <input id="algYMax" value="1.5" />
          </div>
        </div>
        <div class="grid row">
          <div>
            <label>z min</label>
            <input id="algZMin" value="-1.5" />
          </div>
          <div>
            <label>z max</label>
            <input id="algZMax" value="1.5" />
          </div>
        </div>
        <div class="hint">
          Use variables <code>x</code>, <code>y</code>, <code>z</code> and params (e.g. <code>a,b,c</code>, <code>n</code>). Example torus: <code>(x^2+y^2+z^2+R^2-r^2)^2-4*R^2*(x^2+y^2)</code>.
        </div>
      </div>
    </div>

    <div id="section-run" class="section-title">Run</div>
    <div class="section-box">
      <div class="grid row">
        <div id="dt-box">
          <label id="dt-label">dt</label>
          <input id="dt" value="0.005" />
        </div>
        <div>
          <label id="steps-label">steps</label>
          <input id="steps" value="200000" />
        </div>
      </div>

      <div class="grid row" id="ode-row">
        <div>
          <label>Solver (ODE only)</label>
          <select id="solver">
            <option value="rk4" selected>RK4 (fixed step)</option>
            <option value="euler">Euler (fixed step)</option>
            <option value="dp45">Dormand–Prince RK45 (adaptive)</option>
            <option value="rkf45">Fehlberg RKF45 (adaptive)</option>
            <option value="bs23">Bogacki–Shampine RK23 (adaptive)</option>
            <option value="ck45">Cash–Karp CK45 (adaptive)</option>
          </select>
        </div>
        <div class="hint" style="margin-top:22px;">
          Map ignores dt/solver (uses iterations). SDE uses Euler–Maruyama.
        </div>
      </div>

      <div class="grid row" id="sde-row" style="display:none;">
        <div>
          <label>sigma (SDE noise)</label>
          <input id="sigma" value="0.0" />
        </div>
        <div>
          <label>Note</label>
          <input value="x += f*dt + sigma*sqrt(dt)*N(0,1)" disabled />
        </div>
      </div>

      <div class="grid row" id="adaptive-row-1">
        <div>
          <label>absTol (adaptive)</label>
          <input id="absTol" value="1e-6" />
        </div>
        <div>
          <label>relTol (adaptive)</label>
          <input id="relTol" value="1e-3" />
        </div>
      </div>

      <div class="grid row" id="adaptive-row-2">
        <div>
          <label>dtMin (adaptive)</label>
          <input id="dtMin" value="1e-6" />
        </div>
        <div>
          <label>dtMax (adaptive)</label>
          <input id="dtMax" value="0.05" />
        </div>
      </div>

      <div class="grid row" data-advanced="1" id="stream-row">
        <div id="transient-box">
          <label>Transient (skip)</label>
          <input id="transient" value="2000" />
        </div>
        <div id="ppf-box">
          <label id="ppf-label">Points/frame (streaming)</label>
          <input id="ppf" value="1500" />
        </div>
      </div>
    </div>

    <div class="buttons row">
      <button id="start">Start</button>
      <button id="validate" class="secondary">Validate</button>
      <button id="pause" class="secondary">Pause</button>
      <button id="reset" class="secondary">Reset</button>
    </div>

    <div id="main-hint" class="hint">
      Hỗ trợ biến <b>x,y,z,t</b> và tham số tuỳ ý. Dùng hàm math.js như <code>sin</code>, <code>cos</code>, <code>pow</code>.<br/>
      Ví dụ Lorenz: <code>dx=sigma*(y-x)</code>, <code>dy=x*(rho-z)-y</code>, <code>dz=x*y-beta*z</code>.
    </div>
    <div id="stats" class="hint" style="margin-top:10px;"></div>
  </div>
  <button id="open-controls" title="Open controls">Open controls</button>

  <!-- Three.js (ES Modules via import map) -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <!-- math.js (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/mathjs@11.12.0/lib/browser/math.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    (() => {
      // ---- TODO progress: base/engine/gui/animation all in this file ----

      const errorEl = document.getElementById('error');
      const noticeEl = document.getElementById('notice');
      function showError(message) {
        if (noticeEl) { noticeEl.style.display = 'none'; noticeEl.textContent = ''; }
        if (!message) {
          errorEl.style.display = 'none';
          errorEl.textContent = '';
          return;
        }
        errorEl.style.display = 'block';
        errorEl.textContent = message;
      }
      function showNotice(message) {
        if (errorEl) { errorEl.style.display = 'none'; errorEl.textContent = ''; }
        if (!noticeEl) return;
        if (!message) { noticeEl.style.display = 'none'; noticeEl.textContent = ''; return; }
        noticeEl.style.display = 'block';
        noticeEl.textContent = message;
        window.setTimeout(() => {
          if (noticeEl.textContent === message) {
            noticeEl.style.display = 'none';
            noticeEl.textContent = '';
          }
        }, 2200);
      }

      const appEl = document.getElementById('app');

      // ---- Three.js base ----
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 2000);
      camera.position.set(2.8, 1.9, 3.2);

      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      appEl.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.zoomSpeed = 0.9;
      controls.rotateSpeed = 0.7;
      controls.panSpeed = 0.7;

      // ---- Keyboard: game-like movement with arrow keys (supports holding multiple keys) ----
      // ArrowLeft/Right: strafe; ArrowUp/Down: forward/back. Moves camera + controls.target (no zoom).
      function isTypingInControl() {
        const el = document.activeElement;
        if (!el) return false;
        const tag = String(el.tagName || '').toLowerCase();
        if (tag === 'input' || tag === 'textarea' || tag === 'select') return true;
        // contenteditable
        if (el.isContentEditable) return true;
        return false;
      }

      // WASD movement (game-like). Shift = up, Ctrl = down.
      const _moveKeys = { left: false, right: false, forward: false, back: false, shiftUp: false, ctrlDown: false };
      let _movePrevMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const _kbForward = new THREE.Vector3();
      const _kbRight = new THREE.Vector3();
      const _kbDelta = new THREE.Vector3();
      let cameraMoveSpeed = 1.0; // user setting
      let mouseLockEnabled = false;
      let mouseSensitivity = 1.0;
      let pointerLocked = false;
      let _unlockRequested = false;
      const crosshairEl = document.getElementById('crosshair');

      // True FPS look (yaw/pitch) while pointer is locked.
      let fpYaw = 0;
      let fpPitch = 0;
      let fpLookDist = 10;
      const _fpEuler = new THREE.Euler(0, 0, 0, 'YXZ');
      const _fpDir = new THREE.Vector3();

      function syncFpAnglesFromCamera() {
        _fpEuler.setFromQuaternion(camera.quaternion, 'YXZ');
        fpPitch = _fpEuler.x;
        fpYaw = _fpEuler.y;
      }
      function updateFpTarget() {
        camera.getWorldDirection(_fpDir).normalize();
        controls.target.copy(camera.position).addScaledVector(_fpDir, fpLookDist);
      }
      function applyFpRotation() {
        // Clamp pitch to avoid flipping
        const lim = Math.PI * 0.5 - 0.001;
        fpPitch = Math.max(-lim, Math.min(lim, fpPitch));
        _fpEuler.set(fpPitch, fpYaw, 0, 'YXZ');
        camera.quaternion.setFromEuler(_fpEuler);
      }

      function isPointerLocked() {
        return document.pointerLockElement === renderer.domElement;
      }

      function setPointerLockEnabled(on) {
        mouseLockEnabled = !!on;
        if (settings.mouseLockBtn) settings.mouseLockBtn.textContent = isPointerLocked() ? 'Unlock' : 'Lock';
        saveSettingsCache({ mouseLock: mouseLockEnabled ? 1 : 0 });
      }

      function clampMouseSensitivity(v) {
        return Math.max(0.2, Math.min(3.0, Number(v) || 1.0));
      }
      function setMouseSensitivity(v) {
        const s = clampMouseSensitivity(v);
        mouseSensitivity = s;
        if (settings.mouseSense) settings.mouseSense.value = String(s);
        if (settings.mouseSenseNum) settings.mouseSenseNum.value = String(s);
        saveSettingsCache({ mouseSensitivity: s });
      }

      function requestPointerLock() {
        if (!mouseLockEnabled) return;
        try { renderer.domElement.requestPointerLock?.(); } catch (_) {}
      }
      function exitPointerLock() {
        try { document.exitPointerLock?.(); } catch (_) {}
      }

      function onPointerLockChange() {
        pointerLocked = isPointerLocked();
        if (settings.mouseLockBtn) settings.mouseLockBtn.textContent = pointerLocked ? 'Unlock' : 'Lock';
        if (crosshairEl) crosshairEl.style.display = pointerLocked ? 'block' : 'none';

        if (pointerLocked) {
          // Enter FPS mode: disable orbit UI interactions, keep target in front of camera.
          controls.enabled = false;
          fpLookDist = camera.position.distanceTo(controls.target) || 10;
          syncFpAnglesFromCamera();
          applyFpRotation();
          updateFpTarget();
          controls.update();
        } else {
          // Exit FPS mode: re-enable OrbitControls.
          controls.enabled = true;
          controls.update();

          // If lock was lost unexpectedly (e.g. Alt key triggering browser menu),
          // keep the feature enabled and tell user to re-lock.
          if (mouseLockEnabled && !_unlockRequested) {
            showNotice('Mouse lock lost. Click Lock to re-enter.');
          }
          _unlockRequested = false;
        }
      }
      document.addEventListener('pointerlockchange', onPointerLockChange);

      function onLockedMouseMove(e) {
        if (!pointerLocked) return;
        const dx = Number(e.movementX || 0);
        const dy = Number(e.movementY || 0);
        const sens = 0.0022 * mouseSensitivity;
        // FPS-style: mouse right -> look right, mouse up -> look up
        fpYaw += -dx * sens;
        fpPitch += -dy * sens;
        applyFpRotation();
        updateFpTarget();
      }
      document.addEventListener('mousemove', onLockedMouseMove);

      function anyMoveKeyDown() {
        return _moveKeys.left || _moveKeys.right || _moveKeys.forward || _moveKeys.back || _moveKeys.shiftUp || _moveKeys.ctrlDown;
      }

      function applyKeyboardMove(dtSec) {
        if (isTypingInControl()) return;
        if (!anyMoveKeyDown()) return;
        const lr = (_moveKeys.right ? 1 : 0) + (_moveKeys.left ? -1 : 0);
        const fb = (_moveKeys.forward ? 1 : 0) + (_moveKeys.back ? -1 : 0);
        const ud = (_moveKeys.shiftUp ? 1 : 0) + (_moveKeys.ctrlDown ? -1 : 0);
        if (lr === 0 && fb === 0 && ud === 0) return;

        // Normalize diagonal so speed stays consistent
        const mag = Math.hypot(lr, fb, ud) || 1;
        const nlr = lr / mag;
        const nfb = fb / mag;
        const nud = ud / mag;

        const target = controls.target;
        const dist = pointerLocked ? fpLookDist : camera.position.distanceTo(target);
        const step = dist * 0.9 * dtSec * cameraMoveSpeed; // game-like feel (scaled)

        camera.getWorldDirection(_kbForward).normalize();
        _kbRight.crossVectors(_kbForward, camera.up).normalize();
        _kbDelta.set(0, 0, 0);
        _kbDelta.addScaledVector(_kbRight, nlr * step);
        _kbDelta.addScaledVector(_kbForward, nfb * step);
        _kbDelta.addScaledVector(camera.up, nud * step);
        camera.position.add(_kbDelta);
        if (pointerLocked) {
          // FPS: target stays in front of camera
          updateFpTarget();
        } else {
          // Orbit-style move: translate camera and target together
          target.add(_kbDelta);
        }
      }

      window.addEventListener('keydown', (e) => {
        // Allow normal cursor movement inside inputs/textareas/selects.
        if (isTypingInControl()) return;
        const k = e.key;
        const code = e.code;
        // Prevent Alt from focusing browser menu while pointer-locked (commonly drops pointer lock on Windows).
        if (pointerLocked && (k === 'Alt' || code === 'AltLeft' || code === 'AltRight')) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        if (k === 'Shift') { _moveKeys.shiftUp = true; e.preventDefault(); return; }
        if (k === 'Control') { _moveKeys.ctrlDown = true; e.preventDefault(); return; }
        if (code === 'KeyA') { _moveKeys.left = true; e.preventDefault(); }
        if (code === 'KeyD') { _moveKeys.right = true; e.preventDefault(); }
        if (code === 'KeyW') { _moveKeys.forward = true; e.preventDefault(); }
        if (code === 'KeyS') { _moveKeys.back = true; e.preventDefault(); }
      }, { passive: false });

      window.addEventListener('keyup', (e) => {
        const k = e.key;
        const code = e.code;
        // Fallback: if Alt still caused unlock, allow Alt keyup (user gesture) to re-lock.
        if (!pointerLocked && mouseLockEnabled && (k === 'Alt' || code === 'AltLeft' || code === 'AltRight')) {
          e.preventDefault?.();
          requestPointerLock();
          return;
        }
        if (k === 'Shift') _moveKeys.shiftUp = false;
        if (k === 'Control') _moveKeys.ctrlDown = false;
        if (code === 'KeyA') _moveKeys.left = false;
        if (code === 'KeyD') _moveKeys.right = false;
        if (code === 'KeyW') _moveKeys.forward = false;
        if (code === 'KeyS') _moveKeys.back = false;
      });

      window.addEventListener('blur', () => {
        _moveKeys.left = _moveKeys.right = _moveKeys.forward = _moveKeys.back = _moveKeys.shiftUp = _moveKeys.ctrlDown = false;
      });

      const ambient = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.55);
      dir.position.set(3, 4, 2);
      scene.add(dir);

      const axes = new THREE.AxesHelper(1.25);
      axes.visible = true;
      scene.add(axes);

      // =====================================================================
      // UI (inputs), Parser (math.js), Solver (Euler/RK4), Renderer (Three.js)
      // =====================================================================

      // ---- UI refs ----
      const ui = {
        panel: document.getElementById('ui-panel'),
        openControls: document.getElementById('open-controls'),
        closeControls: document.getElementById('close-controls'),
        panelTitle: document.getElementById('panel-title'),
        sectionModel: document.getElementById('section-model'),
        sectionRun: document.getElementById('section-run'),
        mainHint: document.getElementById('main-hint'),
        stats: document.getElementById('stats'),
        preset: document.getElementById('preset'),
        presetSearch: document.getElementById('presetSearch'),
        saveCustom: document.getElementById('save-custom'),
        deleteSaved: document.getElementById('delete-saved'),
        systemType: document.getElementById('systemType'),
        dtBox: document.getElementById('dt-box'),
        dtLabel: document.getElementById('dt-label'),
        stepsLabel: document.getElementById('steps-label'),
        odeRow: document.getElementById('ode-row'),
        adaptiveRow1: document.getElementById('adaptive-row-1'),
        adaptiveRow2: document.getElementById('adaptive-row-2'),
        sdeRow: document.getElementById('sde-row'),
        streamRow: document.getElementById('stream-row'),
        transientBox: document.getElementById('transient-box'),
        ppfLabel: document.getElementById('ppf-label'),
        sigma: document.getElementById('sigma'),
        dimProjRow: document.getElementById('dimproj-row'),
        dim: document.getElementById('dim'),
        dimAuto: document.getElementById('dimAuto'),
        dimLabel: document.getElementById('dim-label'),
        dimAutoLabel: document.getElementById('dim-auto-label'),
        projX: document.getElementById('projX'),
        projY: document.getElementById('projY'),
        projZ: document.getElementById('projZ'),
        eqModeRow: document.getElementById('eqmode-row'),
        eqMode: document.getElementById('eqMode'),
        eqs: document.getElementById('eqs'),
        simpleEqs: document.getElementById('simple-eqs'),
        dx: document.getElementById('dx'),
        dy: document.getElementById('dy'),
        dz: document.getElementById('dz'),
        params: document.getElementById('params'),
        initRow: document.getElementById('init-row'),
        init: document.getElementById('init'),
        dt: document.getElementById('dt'),
        absTol: document.getElementById('absTol'),
        relTol: document.getElementById('relTol'),
        dtMin: document.getElementById('dtMin'),
        dtMax: document.getElementById('dtMax'),
        steps: document.getElementById('steps'),
        transient: document.getElementById('transient'),
        solver: document.getElementById('solver'),
        ppf: document.getElementById('ppf'),
        start: document.getElementById('start'),
        validate: document.getElementById('validate'),
        pause: document.getElementById('pause'),
        reset: document.getElementById('reset'),
        exportBtn: null,
        // PDE (linear)
        pdeSection: document.getElementById('pde-linear-section'),
        pdeBox: document.getElementById('pde-linear-box'),
        pdeType: document.getElementById('pdeType'),
        pdeNx: document.getElementById('pdeNx'),
        pdeNy: document.getElementById('pdeNy'),
        pdeXMin: document.getElementById('pdeXMin'),
        pdeXMax: document.getElementById('pdeXMax'),
        pdeYMin: document.getElementById('pdeYMin'),
        pdeYMax: document.getElementById('pdeYMax'),
        pdeAlpha: document.getElementById('pdeAlpha'),
        pdeBC: document.getElementById('pdeBC'),
        pdeZScale: document.getElementById('pdeZScale'),
        pdeU0: document.getElementById('pdeU0'),
        pdeSource: document.getElementById('pdeSource'),
        pdeNonlinearRow: document.getElementById('pde-nonlinear-row'),
        pdeNonlinear: document.getElementById('pdeNonlinear'),
        // DAE
        daeSection: document.getElementById('dae-section'),
        daeBox: document.getElementById('dae-box'),
        daeNx: document.getElementById('daeNx'),
        daeF: document.getElementById('daeF'),
        daeG: document.getElementById('daeG'),
        daeTol: document.getElementById('daeTol'),
        daeNewtonIters: document.getElementById('daeNewtonIters'),
        // Hybrid
        hybridSection: document.getElementById('hybrid-section'),
        hybridBox: document.getElementById('hybrid-box'),
        hybridEvent: document.getElementById('hybridEvent'),
        hybridReset: document.getElementById('hybridReset'),
        // Algebraic (implicit surface)
        algSection: document.getElementById('alg-section'),
        algBox: document.getElementById('alg-box'),
        algMode: document.getElementById('algMode'),
        algImplicitRow: document.getElementById('alg-implicit-row'),
        algF: document.getElementById('algF'),
        algIso: document.getElementById('algIso'),
        algRes: document.getElementById('algRes'),
        algXMin: document.getElementById('algXMin'),
        algXMax: document.getElementById('algXMax'),
        algYMin: document.getElementById('algYMin'),
        algYMax: document.getElementById('algYMax'),
        algZMin: document.getElementById('algZMin'),
        algZMax: document.getElementById('algZMax'),
      };

      // ---- Collapsible panels (Model / Algebraic / Wizards / Run) ----
      const UI_COLLAPSE_KEY = 'sim_ui_collapsed_panels_v1';
      function loadCollapseMap() {
        try {
          const raw = localStorage.getItem(UI_COLLAPSE_KEY);
          const v = safeJsonParse(raw, {});
          return (v && typeof v === 'object') ? v : {};
        } catch (_) {
          return {};
        }
      }
      function saveCollapseMap(next) {
        try { localStorage.setItem(UI_COLLAPSE_KEY, JSON.stringify(next || {})); } catch (_) {}
      }
      function setCollapsed(titleEl, collapsed) {
        if (!titleEl) return;
        const box = titleEl.nextElementSibling;
        if (!box || !box.classList || !box.classList.contains('section-box')) return;
        titleEl.classList.toggle('is-collapsed', !!collapsed);
        titleEl.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
      }
      function makePanelCollapsible(titleEl, key) {
        if (!titleEl) return;
        const box = titleEl.nextElementSibling;
        if (!box || !box.classList || !box.classList.contains('section-box')) return;
        titleEl.classList.add('is-collapsible');
        titleEl.setAttribute('role', 'button');
        titleEl.setAttribute('tabindex', '0');
        const map = loadCollapseMap();
        setCollapsed(titleEl, !!map[key]);
        const toggle = () => {
          const now = titleEl.classList.contains('is-collapsed');
          const nextCollapsed = !now;
          const m = loadCollapseMap();
          m[key] = nextCollapsed;
          saveCollapseMap(m);
          setCollapsed(titleEl, nextCollapsed);
        };
        titleEl.addEventListener('click', toggle);
        titleEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggle();
          }
        });
      }

      // ---- Right settings panel (no dat.gui) ----
      const settings = {
        panel: document.getElementById('settings-panel'),
        title: document.getElementById('settings-title'),
        close: document.getElementById('settings-close'),
        openBtn: document.getElementById('open-settings'),
        langLabel: document.getElementById('settings-lang-label'),
        langSelect: document.getElementById('settings-language'),
        axesLabel: document.getElementById('settings-axes-label'),
        axesSelect: document.getElementById('settings-axes'),
        modeLabel: document.getElementById('settings-mode-label'),
        modeSelect: document.getElementById('settings-mode'),
        pointSizeLabel: document.getElementById('settings-pointsize-label'),
        pointSize: document.getElementById('settings-pointsize'),
        pointSizeNum: document.getElementById('settings-pointsize-num'),
        camSpeedLabel: document.getElementById('settings-camspeed-label'),
        camSpeed: document.getElementById('settings-camspeed'),
        camSpeedNum: document.getElementById('settings-camspeed-num'),
        mouseLockLabel: document.getElementById('settings-mouselock-label'),
        mouseLockBtn: document.getElementById('settings-mouselock-btn'),
        mouseLockHint: document.getElementById('settings-mouselock-hint'),
        mouseSenseLabel: document.getElementById('settings-mousesense-label'),
        mouseSense: document.getElementById('settings-mousesense'),
        mouseSenseNum: document.getElementById('settings-mousesense-num'),
        resetView: document.getElementById('settings-resetview'),
      };

      // Setup collapsible panels now that elements exist
      makePanelCollapsible(ui.sectionModel, 'model');
      makePanelCollapsible(ui.algSection, 'algebraic');
      makePanelCollapsible(ui.sectionRun, 'run');
      const SETTINGS_OPEN_KEY = 'sim_settings_open';
      const SETTINGS_CACHE_KEY = 'sim_settings_cache_v1';
      function loadSettingsCache() {
        try {
          const raw = localStorage.getItem(SETTINGS_CACHE_KEY);
          const v = safeJsonParse(raw, {});
          return (v && typeof v === 'object') ? v : {};
        } catch (_) {
          return {};
        }
      }
      function saveSettingsCache(patch) {
        const prev = loadSettingsCache();
        const next = { ...prev, ...patch };
        try { localStorage.setItem(SETTINGS_CACHE_KEY, JSON.stringify(next)); } catch (_) {}
      }
      function setSettingsOpen(open) {
        const isOpen = !!open;
        settings.panel?.classList.toggle('is-hidden', !isOpen);
        if (settings.openBtn) settings.openBtn.style.display = isOpen ? 'none' : 'inline-block';
        try { localStorage.setItem(SETTINGS_OPEN_KEY, isOpen ? '1' : '0'); } catch (_) {}
      }
      function getSettingsOpenDefault() {
        try {
          const v = localStorage.getItem(SETTINGS_OPEN_KEY);
          if (v === '0') return false;
          if (v === '1') return true;
        } catch (_) {}
        return true;
      }
      setSettingsOpen(getSettingsOpenDefault());
      settings.close?.addEventListener('click', () => setSettingsOpen(false));
      settings.openBtn?.addEventListener('click', () => setSettingsOpen(true));

      // ---- Language (i18n) ----
      const UI_LANG_KEY = 'sim_ui_lang';
      const I18N = {
        vi: {
          panelTitle: 'Bảng điều khiển mô phỏng 3D',
          openControls: 'Mở điều khiển',
          advanced: 'Nâng cao',
          basic: 'Cơ bản',
          sectionModel: 'Mô hình',
          // sectionWizards removed
          sectionRun: 'Chạy mô phỏng',
          systemCategory: 'Phân loại hệ',
          preset: 'Preset',
          presetSearch: 'Tìm preset',
          eqMode: 'Chế độ nhập',
          eqModeSimple: 'Đơn giản (dx/dy/dz)',
          eqModeVector: 'Vector (N dòng)',
          vectorEqs: 'Phương trình vector (mỗi dòng 1 phương trình). Biến: x1..xN, t, và params.',
          dx: 'dx/dt = F(x,y,z,t,params)',
          dy: 'dy/dt = G(x,y,z,t,params)',
          dz: 'dz/dt = H(x,y,z,t,params)',
          params: 'Tham số (mỗi dòng: name = value)',
          init: 'Điều kiện đầu (cách nhau bởi dấu phẩy, độ dài N)',
          dt: 'dt',
          dtSde: 'dt (SDE)',
          dtParam: 'Bước t',
          steps: 'Số bước',
          iterations: 'Số vòng lặp',
          samples: 'Số mẫu',
          solverOde: 'Solver (chỉ ODE)',
          sigma: 'sigma (nhiễu SDE)',
          note: 'Ghi chú',
          absTol: 'absTol (adaptive)',
          relTol: 'relTol (adaptive)',
          dtMin: 'dtMin (adaptive)',
          dtMax: 'dtMax (adaptive)',
          transient: 'Bỏ qua (transient)',
          ppf: 'Điểm/frame (streaming)',
          start: 'Chạy',
          validate: 'Kiểm tra',
          pause: 'Tạm dừng',
          resume: 'Tiếp tục',
          reset: 'Đặt lại',
          export: 'Xuất PNG',
          hint: 'Hỗ trợ biến x,y,z,t và tham số tuỳ ý. Dùng hàm math.js như sin, cos, pow. Ví dụ Lorenz: dx=sigma*(y-x), dy=x*(rho-z)-y, dz=x*y-beta*z.',
          langName: 'Ngôn ngữ',
          systemOptions: {
            algebraic: 'Hệ đại số (Algebraic)',
            ode_linear: 'ODE – Tuyến tính',
            ode_nonlinear: 'ODE – Phi tuyến',
            map: 'Hệ sai phân (Discrete Map)',
            pde_linear: 'PDE – Tuyến tính',
            pde_nonlinear: 'PDE – Phi tuyến',
            dae: 'DAE',
            stochastic: 'Hệ ngẫu nhiên (SDE)',
            hybrid: 'Hybrid',
            hamilton: 'Hamilton/Lagrange',
            optimization: 'Tối ưu / Gradient Flow',
            markov: 'Markov / Xác suất',
          },
          // wizard strings removed
        },
        en: {
          panelTitle: '3D Simulator Controller',
          openControls: 'Open controls',
          advanced: 'Advanced',
          basic: 'Basic',
          sectionModel: 'Model',
          // sectionWizards removed
          sectionRun: 'Run',
          systemCategory: 'System category',
          preset: 'Preset',
          presetSearch: 'Search presets',
          eqMode: 'Equation mode',
          eqModeSimple: 'Simple (dx/dy/dz)',
          eqModeVector: 'Vector (N lines)',
          vectorEqs: 'Vector equations (one per line). Variables: x1..xN, t, and params.',
          dx: 'dx/dt = F(x,y,z,t,params)',
          dy: 'dy/dt = G(x,y,z,t,params)',
          dz: 'dz/dt = H(x,y,z,t,params)',
          params: 'Parameters (one per line: name = value)',
          init: 'Initial (comma-separated, length N)',
          dt: 'dt',
          dtSde: 'dt (SDE)',
          dtParam: 't step',
          steps: 'steps',
          iterations: 'iterations',
          samples: 'samples',
          solverOde: 'Solver (ODE only)',
          sigma: 'sigma (SDE noise)',
          note: 'Note',
          absTol: 'absTol (adaptive)',
          relTol: 'relTol (adaptive)',
          dtMin: 'dtMin (adaptive)',
          dtMax: 'dtMax (adaptive)',
          transient: 'Transient (skip)',
          ppf: 'Points/frame (streaming)',
          start: 'Start',
          validate: 'Validate',
          pause: 'Pause',
          resume: 'Resume',
          reset: 'Reset',
          export: 'Export PNG',
          hint: 'Supports variables x,y,z,t and arbitrary parameters. Use math.js functions like sin, cos, pow. Lorenz example: dx=sigma*(y-x), dy=x*(rho-z)-y, dz=x*y-beta*z.',
          langName: 'Language',
          systemOptions: {
            algebraic: 'Algebraic System',
            ode_linear: 'ODE – Linear',
            ode_nonlinear: 'ODE – Nonlinear',
            map: 'Discrete Map',
            pde_linear: 'PDE – Linear',
            pde_nonlinear: 'PDE – Nonlinear',
            dae: 'DAE System',
            stochastic: 'Stochastic System (SDE)',
            hybrid: 'Hybrid System',
            hamilton: 'Hamilton/Lagrange System',
            optimization: 'Optimization / Gradient Flow',
            markov: 'Markov / Probabilistic System',
          },
          // wizard strings removed
        }
      };

      function getCurrentLang() {
        try {
          const v = localStorage.getItem(UI_LANG_KEY);
          if (v === 'en' || v === 'vi') return v;
        } catch (_) {}
        return 'vi';
      }
      function setCurrentLang(lang) {
        const l = (lang === 'en' || lang === 'vi') ? lang : 'vi';
        try { localStorage.setItem(UI_LANG_KEY, l); } catch (_) {}
        applyLanguage(l);
      }
      function setLabelForControl(controlEl, text) {
        if (!controlEl) return;
        // Prefer the label within the immediate field container (<div><label>..</label><input/></div>)
        const parent = controlEl.parentElement;
        const directLabel = parent ? parent.querySelector('label') : null;
        if (directLabel) {
          directLabel.textContent = text;
          return;
        }
        // Fallback: previous sibling label
        const prev = controlEl.previousElementSibling;
        if (prev && prev.tagName === 'LABEL') {
          prev.textContent = text;
          return;
        }
        // Last resort: first label in row
        const row = controlEl.closest('.row');
        const label = row ? row.querySelector('label') : null;
        if (label) label.textContent = text;
      }
      function setPrevLabel(el, text) {
        const prev = el?.previousElementSibling;
        if (prev && prev.tagName === 'LABEL') prev.textContent = text;
      }

      // Boot-safe running flag (avoid touching runtime before it's initialized)
      let uiIsRunning = false;
      // Some functions are hoisted and can be called during early preset setup
      // before render objects/runtime are initialized. Use this guard to avoid TDZ.
      var renderObjectsReady = false;

      function updateRenderModeOptionLabels(lang) {
        if (!settings.modeSelect) return;
        const l = (lang === 'en' || lang === 'vi') ? lang : getCurrentLang();
        const optLine = settings.modeSelect.querySelector('option[value="Line"]');
        const optPts = settings.modeSelect.querySelector('option[value="Points"]');
        if (optPts) optPts.textContent = (l === 'vi') ? 'Điểm' : 'Points';

        // In Algebraic+Implicit context, "Line" actually means Surface (mesh).
        const isAlgImplicit = String(ui.systemType?.value || '') === 'algebraic'
          && String(ui.algMode?.value || 'parametric') === 'implicit';
        if (optLine) {
          optLine.textContent = isAlgImplicit
            ? ((l === 'vi') ? 'Bề mặt' : 'Surface')
            : ((l === 'vi') ? 'Quỹ đạo' : 'Path');
        }
      }

      function applyLanguage(lang) {
        const d = I18N[lang] || I18N.vi;
        if (ui.panelTitle) ui.panelTitle.textContent = d.panelTitle;
        if (ui.openControls) ui.openControls.textContent = d.openControls;
        if (ui.sectionModel) ui.sectionModel.textContent = d.sectionModel;
        if (ui.sectionRun) ui.sectionRun.textContent = d.sectionRun;

        // Basic/Advanced removed

        setLabelForControl(ui.systemType, d.systemCategory);
        setLabelForControl(ui.preset, d.preset);
        setLabelForControl(ui.presetSearch, d.presetSearch);
        setLabelForControl(ui.eqMode, d.eqMode);
        if (ui.dimLabel) ui.dimLabel.textContent = (lang === 'vi') ? 'Số chiều N' : 'Dimension N';
        if (ui.dimAutoLabel) ui.dimAutoLabel.textContent = (lang === 'vi') ? 'Tự động' : 'Auto';

        // eqMode option labels
        if (ui.eqMode) {
          const optSimple = ui.eqMode.querySelector('option[value="simple"]');
          const optVector = ui.eqMode.querySelector('option[value="vector"]');
          if (optSimple) optSimple.textContent = d.eqModeSimple;
          if (optVector) optVector.textContent = d.eqModeVector;
        }

        // system category option labels
        if (ui.systemType) {
          for (const opt of ui.systemType.querySelectorAll('option')) {
            const v = opt.value;
            if (d.systemOptions && d.systemOptions[v]) opt.textContent = d.systemOptions[v];
          }
        }

        // Vector eq label
        if (ui.eqs) {
          const row = ui.eqs.closest('.row');
          const label = row ? row.querySelector('label') : null;
          if (label) label.textContent = d.vectorEqs;
        }
        setLabelForControl(ui.dx, d.dx);
        setLabelForControl(ui.dy, d.dy);
        setLabelForControl(ui.dz, d.dz);
        setLabelForControl(ui.params, d.params);
        setLabelForControl(ui.init, d.init);

        // PDE (linear) labels (minimal)
        if (ui.pdeSection) {
          const cat = String(ui.systemType?.value || '');
          const isNl = cat === 'pde_nonlinear';
          ui.pdeSection.textContent = isNl
            ? ((lang === 'vi') ? 'PDE – Phi tuyến' : 'PDE – Nonlinear')
            : ((lang === 'vi') ? 'PDE – Tuyến tính' : 'PDE – Linear');
        }
        if (ui.pdeType) setLabelForControl(ui.pdeType, (lang === 'vi') ? 'Loại PDE' : 'PDE type');
        if (ui.pdeNx) setLabelForControl(ui.pdeNx, 'Nx');
        if (ui.pdeNy) setLabelForControl(ui.pdeNy, 'Ny');
        if (ui.pdeXMin) setLabelForControl(ui.pdeXMin, 'x min');
        if (ui.pdeXMax) setLabelForControl(ui.pdeXMax, 'x max');
        if (ui.pdeYMin) setLabelForControl(ui.pdeYMin, 'y min');
        if (ui.pdeYMax) setLabelForControl(ui.pdeYMax, 'y max');
        if (ui.pdeAlpha) setLabelForControl(ui.pdeAlpha, (lang === 'vi') ? 'α (khuếch tán)' : 'α (diffusivity)');
        if (ui.pdeBC) setLabelForControl(ui.pdeBC, (lang === 'vi') ? 'Điều kiện biên' : 'Boundary');
        if (ui.pdeZScale) setLabelForControl(ui.pdeZScale, (lang === 'vi') ? 'Tỉ lệ Z' : 'Z scale');
        if (ui.pdeU0) setLabelForControl(ui.pdeU0, (lang === 'vi') ? 'Điều kiện đầu u(x,y,t=0)' : 'Initial condition u(x,y,t=0)');
        if (ui.pdeSource) setLabelForControl(ui.pdeSource, (lang === 'vi') ? 'Nguồn S(x,y,t) (tuỳ chọn)' : 'Source term S(x,y,t) (optional)');
        if (ui.pdeNonlinear) setLabelForControl(ui.pdeNonlinear, (lang === 'vi') ? 'Hạng phi tuyến N(u,x,y,t) (tuỳ chọn)' : 'Nonlinear term N(u,x,y,t) (optional)');

        // DAE labels (minimal)
        if (ui.daeSection) ui.daeSection.textContent = 'DAE';
        if (ui.daeNx) setLabelForControl(ui.daeNx, (lang === 'vi') ? 'Nx (biến vi phân)' : 'Nx (differential vars)');
        if (ui.daeF) setLabelForControl(ui.daeF, (lang === 'vi') ? "Phương trình vi phân (Nx dòng): x' = f" : "DAE differential eqs (Nx lines): x' = f");
        if (ui.daeG) setLabelForControl(ui.daeG, (lang === 'vi') ? 'Ràng buộc đại số (Ny dòng): 0 = g' : 'DAE algebraic constraints (Ny lines): 0 = g');
        if (ui.daeTol) setLabelForControl(ui.daeTol, (lang === 'vi') ? 'Newton tol' : 'Newton tol');
        if (ui.daeNewtonIters) setLabelForControl(ui.daeNewtonIters, (lang === 'vi') ? 'Newton tối đa' : 'Newton max iters');

        // Algebraic (implicit) labels (minimal)
        if (ui.algSection) ui.algSection.textContent = (lang === 'vi') ? 'Hệ đại số' : 'Algebraic';
        if (ui.algMode) setLabelForControl(ui.algMode, (lang === 'vi') ? 'Chế độ đại số' : 'Algebraic mode');
        if (ui.algF) setLabelForControl(ui.algF, 'F(x,y,z)');
        if (ui.algIso) setLabelForControl(ui.algIso, 'iso');
        if (ui.algRes) setLabelForControl(ui.algRes, (lang === 'vi') ? 'độ phân giải (N)' : 'resolution (N)');
        if (ui.algXMin) setLabelForControl(ui.algXMin, 'x min');
        if (ui.algXMax) setLabelForControl(ui.algXMax, 'x max');
        if (ui.algYMin) setLabelForControl(ui.algYMin, 'y min');
        if (ui.algYMax) setLabelForControl(ui.algYMax, 'y max');
        if (ui.algZMin) setLabelForControl(ui.algZMin, 'z min');
        if (ui.algZMax) setLabelForControl(ui.algZMax, 'z max');

        // Run labels
        const category = String(ui.systemType?.value || 'ode_nonlinear');
        const engine = categoryToEngineType(category) || 'ode';
        if (ui.dtLabel) ui.dtLabel.textContent = (engine === 'sde') ? d.dtSde : (engine === 'param') ? d.dtParam : d.dt;
        if (ui.stepsLabel) ui.stepsLabel.textContent = (engine === 'map') ? d.iterations : (engine === 'param') ? d.samples : d.steps;

        // ODE/SDE/adaptive labels
        if (ui.solver) {
          const odeLabel = ui.solver.closest('.grid')?.querySelector('label');
          if (odeLabel) odeLabel.textContent = d.solverOde;
        }
        if (ui.sigma) setLabelForControl(ui.sigma, d.sigma);
        if (ui.sdeRow) {
          const noteLabel = ui.sdeRow.querySelectorAll('label')[1];
          if (noteLabel) noteLabel.textContent = d.note;
        }
        if (ui.absTol) setLabelForControl(ui.absTol, d.absTol);
        if (ui.relTol) setLabelForControl(ui.relTol, d.relTol);
        if (ui.dtMin) setLabelForControl(ui.dtMin, d.dtMin);
        if (ui.dtMax) setLabelForControl(ui.dtMax, d.dtMax);
        if (ui.transient) setLabelForControl(ui.transient, d.transient);
        if (ui.ppf) setLabelForControl(ui.ppf, d.ppf);

        // Buttons
        if (ui.start) ui.start.textContent = d.start;
        if (ui.validate) ui.validate.textContent = d.validate;
        if (ui.pause) ui.pause.textContent = uiIsRunning ? d.pause : d.resume;
        if (ui.reset) ui.reset.textContent = d.reset;
        if (ui.exportBtn) ui.exportBtn.textContent = d.export;

        // Wizard labels/buttons (best-effort)
        if (ui.mainHint) ui.mainHint.textContent = d.hint;

        // Settings panel labels (right)
        if (settings.title) settings.title.textContent = (lang === 'vi') ? 'Cài đặt' : 'Settings';
        if (settings.langLabel) settings.langLabel.textContent = d.langName;
        if (settings.axesLabel) settings.axesLabel.textContent = (lang === 'vi') ? 'Hiện trục' : 'Show axes';
        if (settings.modeLabel) settings.modeLabel.textContent = (lang === 'vi') ? 'Chế độ vẽ' : 'Render mode';
        updateRenderModeOptionLabels(lang);
        if (settings.pointSizeLabel) settings.pointSizeLabel.textContent = (lang === 'vi') ? 'Kích thước điểm' : 'Point size';
        if (settings.camSpeedLabel) settings.camSpeedLabel.textContent = (lang === 'vi') ? 'Tốc độ camera' : 'Camera speed';
        if (settings.mouseLockLabel) settings.mouseLockLabel.textContent = (lang === 'vi') ? 'Khoá chuột' : 'Mouse lock';
        if (settings.mouseLockHint) settings.mouseLockHint.textContent = (lang === 'vi')
          ? 'Bấm Lock để khoá chuột. Di chuyển chuột để xoay camera. Nhấn Esc để thoát.'
          : 'Click Lock to lock pointer. Move mouse to look around. Press Esc to unlock.';
        if (settings.mouseSenseLabel) settings.mouseSenseLabel.textContent = (lang === 'vi') ? 'Độ nhạy chuột' : 'Mouse sensitivity';
        if (settings.resetView) settings.resetView.textContent = (lang === 'vi') ? 'Reset góc nhìn' : 'Reset view';
      }

      // ---- Basic/Advanced removed (always show all controls) ----
      applyLanguage(getCurrentLang());

      function syncEqModeUI() {
        const mode = String(ui.eqMode?.value || 'simple');
        const showVector = mode === 'vector';
        const eqRow = ui.eqs ? ui.eqs.closest('.row') : null;
        if (eqRow) eqRow.style.display = showVector ? 'block' : 'none';
        if (ui.simpleEqs) ui.simpleEqs.style.display = showVector ? 'none' : 'block';
      }
      ui.eqMode?.addEventListener('change', () => syncEqModeUI());
      syncEqModeUI();

      // ---- Dimension N (auto) ----
      let projAuto = true;
      let lastAutoDim = null;
      function setProjDefaultsForN(n) {
        if (!ui.projX || !ui.projY || !ui.projZ) return;
        ui.projX.value = '1';
        ui.projY.value = String(Math.min(2, n));
        ui.projZ.value = String(Math.min(3, n));
      }

      function countNonEmptyVectorLines(text) {
        const lines = String(text || '').split(/\r?\n/);
        let count = 0;
        for (let i = 0; i < lines.length; i++) {
          let s = lines[i].trim();
          if (!s) continue;
          s = s.replace(/(#|\/\/).*$/, '').trim();
          if (!s) continue;
          if (s.includes('=')) {
            const rhs = s.slice(s.indexOf('=') + 1).trim();
            if (!rhs) continue;
          }
          count++;
        }
        return count;
      }

      function syncDimAuto() {
        const mode = String(ui.eqMode?.value || 'simple');
        const n = (mode === 'vector')
          ? Math.max(1, countNonEmptyVectorLines(ui.eqs?.value || ''))
          : 3;
        if (ui.dimAuto?.checked) {
          if (ui.dim) ui.dim.value = String(n);
        }

        // Auto projection: if user hasn't overridden, keep a sensible default for current dim.
        const nEffective = Math.max(1, Math.floor(Number(ui.dim?.value || n)) || n);
        if (projAuto) {
          setProjDefaultsForN(nEffective);
        } else {
          // If current projection is out of range (e.g., moved from 3D->2D), force reset.
          const px = Math.floor(Number(ui.projX?.value || 1));
          const py = Math.floor(Number(ui.projY?.value || 2));
          const pz = Math.floor(Number(ui.projZ?.value || 3));
          if (![px, py, pz].every(v => Number.isFinite(v) && v >= 1 && v <= nEffective)) {
            projAuto = true;
            setProjDefaultsForN(nEffective);
          }
        }

        lastAutoDim = nEffective;
      }

      ui.eqMode?.addEventListener('change', () => syncDimAuto());
      ui.eqs?.addEventListener('input', () => syncDimAuto());
      ui.dimAuto?.addEventListener('change', () => syncDimAuto());
      ui.dim?.addEventListener('input', () => {
        // If user types N manually, disable auto
        if (ui.dimAuto) ui.dimAuto.checked = false;
        syncDimAuto();
      });
      ui.projX?.addEventListener('input', () => { projAuto = false; });
      ui.projY?.addEventListener('input', () => { projAuto = false; });
      ui.projZ?.addEventListener('input', () => { projAuto = false; });
      syncDimAuto();

      // ---- Run settings cache (Transient + Points/frame) ----
      const RUN_CACHE_KEY = 'sim_run_cache_v1';
      function loadRunCache() {
        try {
          const raw = localStorage.getItem(RUN_CACHE_KEY);
          const v = safeJsonParse(raw, {});
          return (v && typeof v === 'object') ? v : {};
        } catch (_) {
          return {};
        }
      }
      function saveRunCache(patch) {
        const prev = loadRunCache();
        const next = { ...prev, ...patch };
        try { localStorage.setItem(RUN_CACHE_KEY, JSON.stringify(next)); } catch (_) {}
      }
      // Apply cached values on boot (and keep across preset changes)
      (() => {
        const cache = loadRunCache();
        if (ui.transient && cache.transient != null) ui.transient.value = String(cache.transient);
        if (ui.ppf && cache.ppf != null) ui.ppf.value = String(cache.ppf);
      })();
      ui.transient?.addEventListener('input', () => saveRunCache({ transient: ui.transient.value }));
      ui.ppf?.addEventListener('input', () => saveRunCache({ ppf: ui.ppf.value }));

      // ---- UI panel open/close ----
      const UI_PANEL_KEY = 'ode_ui_panel_open';
      function setPanelOpen(isOpen) {
        const open = !!isOpen;
        ui.panel.classList.toggle('is-hidden', !open);
        ui.openControls.classList.toggle('is-visible', !open);
        try { localStorage.setItem(UI_PANEL_KEY, open ? '1' : '0'); } catch (_) {}
      }
      function getPanelOpenDefault() {
        try {
          const v = localStorage.getItem(UI_PANEL_KEY);
          if (v === '0') return false;
          if (v === '1') return true;
        } catch (_) {}
        return true;
      }
      setPanelOpen(getPanelOpenDefault());
      ui.closeControls.addEventListener('click', () => setPanelOpen(false));
      ui.openControls.addEventListener('click', () => setPanelOpen(true));

      // ---- Presets (ODE attractors) ----
      const builtinPresets = {
        'Lorenz (1963) — Edward Lorenz / “butterfly”': {
          dx: 'sigma*(y-x)',
          dy: 'x*(rho-z)-y',
          dz: 'x*y-beta*z',
          params: 'sigma=10\nrho=28\nbeta=8/3',
          init: '0.1, 0.1, 0.1',
          dt: '0.005',
          steps: '200000',
          transient: '2000',
        },
        'Linear ODE — damped oscillator (2D)': {
          // x1' = x2
          // x2' = -w^2 x1 - c x2
          category: 'ode_linear',
          systemType: 'ode',
          dim: '2',
          projX: '1',
          projY: '2',
          projZ: '2',
          eqs: "x1' = x2\nx2' = -w*w*x1 - c*x2",
          params: 'w=1\nc=0.08',
          init: '1, 0',
          dt: '0.01',
          solver: 'dp45',
          absTol: '1e-8',
          relTol: '1e-5',
          dtMin: '1e-6',
          dtMax: '0.05',
          steps: '120000',
          transient: '0',
        },
        'Lü (Lu) System (2002) — Lü & Chen': {
          // Lü system (2002):
          // xdot = a(y - x)
          // ydot = -x z + c y
          // zdot = x y - b z
          dx: 'a*(y-x)',
          dy: '-x*z + c*y',
          dz: 'x*y - b*z',
          params: 'a=36\nb=3\nc=20',
          init: '0.1, 0.1, 0.1',
          dt: '0.003',
          steps: '240000',
          transient: '2500',
        },
        'Rössler (1976) — Otto Rössler': {
          dx: '-y - z',
          dy: 'x + a*y',
          dz: 'b + z*(x - c)',
          params: 'a=0.2\nb=0.2\nc=5.7',
          init: '0.1, 0, 0',
          dt: '0.01',
          steps: '160000',
          transient: '1500',
        },
        'Chen (1999) — Chen & Ueta': {
          dx: 'a*(y-x)',
          dy: '(c-a)*x - x*z + c*y',
          dz: 'x*y - b*z',
          params: 'a=35\nb=3\nc=28',
          init: '0.1, 0.1, 0.1',
          dt: '0.005',
          steps: '220000',
          transient: '2500',
        },
        'Halvorsen (1996) — Halvorsen attractor': {
          dx: '-a*x - 4*y - 4*z - y*y',
          dy: '-a*y - 4*z - 4*x - z*z',
          dz: '-a*z - 4*x - 4*y - x*x',
          params: 'a=1.4',
          init: '1, 0, 0',
          dt: '0.004',
          steps: '220000',
          transient: '3000',
        },
        'Chua Circuit (1986) — double scroll (Leon O. Chua)': {
          // Chua double-scroll (normalized form):
          // xdot = alpha (y - x - f(x))
          // ydot = x - y + z
          // zdot = -beta y
          // f(x) = m1*x + 0.5*(m0-m1)*(abs(x+1)-abs(x-1))
          dx: 'alpha*(y - x - (m1*x + 0.5*(m0-m1)*(abs(x+1)-abs(x-1))))',
          dy: 'x - y + z',
          dz: '-beta*y',
          params: 'alpha=15.6\nbeta=28\nm0=-1.143\nm1=-0.714',
          init: '0.1, 0, 0',
          dt: '0.004',
          steps: '260000',
          transient: '4000',
        },
        'Qi (2005) — Qi et al. (yz coupling)': {
          // A commonly cited Qi-system form (with yz term):
          // xdot = a (y - x) + y z
          // ydot = b x - y - x z
          // zdot = -c z + x y
          dx: 'a*(y-x) + y*z',
          dy: 'b*x - y - x*z',
          dz: '-c*z + x*y',
          params: 'a=35\nb=80\nc=8/3',
          init: '0.1, 0.0, 0.1',
          dt: '0.002',
          steps: '280000',
          transient: '5000',
        },
        'Rabinovich–Fabrikant (1979) — RF equations': {
          // xdot = y (z - 1 + x^2) + gamma x
          // ydot = x (3 z + 1 - x^2) + gamma y
          // zdot = -2 z (alpha + x y)
          dx: 'y*(z - 1 + x*x) + gamma*x',
          dy: 'x*(3*z + 1 - x*x) + gamma*y',
          dz: '-2*z*(alpha + x*y)',
          params: 'alpha=0.14\ngamma=0.10',
          init: '0.1, 0.1, 0.1',
          dt: '0.002',
          steps: '300000',
          transient: '6000',
        },
        'Thomas (1999) — cyclically symmetric attractor': {
          // Thomas cyclically symmetric attractor
          dx: 'sin(y) - b*x',
          dy: 'sin(z) - b*y',
          dz: 'sin(x) - b*z',
          params: 'b=0.208186',
          init: '0.1, 0, 0',
          dt: '0.01',
          steps: '200000',
          transient: '2000',
        },
        'Finance — Sornette–Andersen (search: “chaotic finance system”)': {
          // A 3D nonlinear finance-style system often used in chaotic finance demos:
          dx: '-a*x + y + z - x*x*x',
          dy: '-b*y + x*z',
          dz: '-c*z + x*y',
          params: 'a=0.1\nb=0.1\nc=14',
          init: '0.2, 0.1, 0.1',
          dt: '0.003',
          steps: '240000',
          transient: '4000',
        },
        'Henon map (Hénon 1976) — discrete-time': {
          // Classic Hénon map (2D):
          // x_{n+1} = 1 - a x_n^2 + y_n
          // y_{n+1} = b x_n
          // z_{n+1} = 0
          systemType: 'map',
          dx: '1 - a*x*x + y',
          dy: 'b*x',
          dz: '0',
          params: 'a=1.4\nb=0.3',
          init: '0, 0, 0',
          dt: '1',
          steps: '200000',
          transient: '100',
        },
        'Ikeda map (Ikeda 1979) — discrete-time': {
          // Ikeda map (2D) with parameter u:
          // t = 0.4 - 6/(1 + x^2 + y^2)
          // x_{n+1} = 1 + u (x cos t - y sin t)
          // y_{n+1} = u (x sin t + y cos t)
          // z_{n+1} = 0
          systemType: 'map',
          dx: '1 + u*(x*cos(0.4 - 6/(1 + x*x + y*y)) - y*sin(0.4 - 6/(1 + x*x + y*y)))',
          dy: 'u*(x*sin(0.4 - 6/(1 + x*x + y*y)) + y*cos(0.4 - 6/(1 + x*x + y*y)))',
          dz: '0',
          params: 'u=0.9',
          init: '0.1, 0, 0',
          dt: '1',
          steps: '220000',
          transient: '200',
        },
        'Noisy Lorenz (SDE) — Lorenz + Gaussian noise': {
          // SDE mode: x += f*dt + sigma*sqrt(dt)*N(0,1)
          systemType: 'sde',
          sigma: '0.8',
          dx: 'sigmaL*(y-x)',
          dy: 'x*(rho-z)-y',
          dz: 'x*y-beta*z',
          params: 'sigmaL=10\nrho=28\nbeta=8/3',
          init: '0.1, 0.1, 0.1',
          dt: '0.003',
          steps: '200000',
          transient: '2000',
        },
        'x=y line (parametric)': {
          // x(t)=t, y(t)=t, z(t)=0
          category: 'algebraic',
          systemType: 'param',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: 'x1 = t\nx2 = t\nx3 = 0',
          params: '',
          init: '0, 0, 0',
          dt: '0.01',
          steps: '200000',
          transient: '0',
        },
        'Helix (parametric)': {
          // x(t)=cos(t), y(t)=sin(t), z(t)=0.05*t
          category: 'algebraic',
          systemType: 'param',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: 'x1 = cos(t)\nx2 = sin(t)\nx3 = 0.05*t',
          params: '',
          init: '0, 0, 0',
          dt: '0.02',
          steps: '120000',
          transient: '0',
        },
        'Sphere (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^2 + y^2 + z^2 - R^2',
          algIso: '0',
          algRes: '52',
          algXMin: '-1.3',
          algXMax: '1.3',
          algYMin: '-1.3',
          algYMax: '1.3',
          algZMin: '-1.3',
          algZMax: '1.3',
          params: 'R=1',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Ellipsoid (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^2/a^2 + y^2/b^2 + z^2/c^2 - 1',
          algIso: '0',
          algRes: '56',
          algXMin: '-1.6',
          algXMax: '1.6',
          algYMin: '-1.6',
          algYMax: '1.6',
          algZMin: '-1.6',
          algZMax: '1.6',
          params: 'a=1.2\nb=0.9\nc=0.7',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Hyperboloid (1 sheet) (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^2/a^2 + y^2/b^2 - z^2/c^2 - 1',
          algIso: '0',
          algRes: '58',
          algXMin: '-2',
          algXMax: '2',
          algYMin: '-2',
          algYMax: '2',
          algZMin: '-2',
          algZMax: '2',
          params: 'a=1\nb=1\nc=1.2',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Paraboloid (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'z - (x^2/a^2 + y^2/b^2)',
          algIso: '0',
          algRes: '60',
          algXMin: '-1.4',
          algXMax: '1.4',
          algYMin: '-1.4',
          algYMax: '1.4',
          algZMin: '-0.2',
          algZMax: '2.2',
          params: 'a=1\nb=1',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Torus (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: '(x^2+y^2+z^2+R^2-r^2)^2 - 4*R^2*(x^2+y^2)',
          algIso: '0',
          algRes: '64',
          algXMin: '-1.8',
          algXMax: '1.8',
          algYMin: '-1.8',
          algYMax: '1.8',
          algZMin: '-1.8',
          algZMax: '1.8',
          params: 'R=1\nr=0.45',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Fermat surface (degree n) (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^n + y^n + z^n - 1',
          algIso: '0',
          algRes: '64',
          algXMin: '-1.2',
          algXMax: '1.2',
          algYMin: '-1.2',
          algYMax: '1.2',
          algZMin: '-1.2',
          algZMax: '1.2',
          params: 'n=4',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Clebsch diagonal cubic (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^3 + y^3 + z^3 - (x+y+z)^3',
          algIso: '0',
          algRes: '70',
          algXMin: '-1.2',
          algXMax: '1.2',
          algYMin: '-1.2',
          algYMax: '1.2',
          algZMin: '-1.2',
          algZMax: '1.2',
          params: '',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Roman surface (Steiner) (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^2*y^2 + y^2*z^2 + z^2*x^2 - x*y*z',
          algIso: '0',
          algRes: '68',
          algXMin: '-1.2',
          algXMax: '1.2',
          algYMin: '-1.2',
          algYMax: '1.2',
          algZMin: '-1.2',
          algZMax: '1.2',
          params: '',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Gyroid (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'sin(x)*cos(y) + sin(y)*cos(z) + sin(z)*cos(x)',
          algIso: '0',
          algRes: '64',
          algXMin: '-pi',
          algXMax: 'pi',
          algYMin: '-pi',
          algYMax: 'pi',
          algZMin: '-pi',
          algZMax: 'pi',
          params: '',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Barth Sextic (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          // One common form of Barth sextic (scaled). phi is the golden ratio.
          algF: '4*(phi^2*x^2 - y^2)*(phi^2*y^2 - z^2)*(phi^2*z^2 - x^2) - (1 + 2*phi)*(x^2 + y^2 + z^2 - 1)^2',
          algIso: '0',
          algRes: '78',
          algXMin: '-1.6',
          algXMax: '1.6',
          algYMin: '-1.6',
          algYMax: '1.6',
          algZMin: '-1.6',
          algZMax: '1.6',
          params: 'phi=(1+sqrt(5))/2',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Lissajous Knot (parametric)': {
          category: 'algebraic',
          systemType: 'param',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          algMode: 'parametric',
          eqs: 'x1 = sin(a*t + delta)\nx2 = sin(b*t)\nx3 = sin(c*t)',
          params: 'a=3\nb=4\nc=5\ndelta=pi/2',
          init: '0, 0, 0',
          dt: '0.003',
          steps: '60000',
          transient: '0',
        },
        'Sprott (1994) — simple chaotic flow #1 (J.C. Sprott)': {
          // Example Sprott simple chaotic flow:
          // xdot = y + z
          // ydot = -x + a y
          // zdot = x^2 - z
          dx: 'y + z',
          dy: '-x + a*y',
          dz: 'x*x - z',
          params: 'a=0.2',
          init: '0.1, 0, 0',
          dt: '0.01',
          steps: '180000',
          transient: '2000',
        },
        'Sprott (1994) — simple chaotic flow #2 (J.C. Sprott)': {
          // Another Sprott-type simple flow:
          // xdot = y
          // ydot = z
          // zdot = -A z + y^2 - x
          dx: 'y',
          dy: 'z',
          dz: '-A*z + y*y - x',
          params: 'A=2.017',
          init: '0.1, 0, 0',
          dt: '0.01',
          steps: '180000',
          transient: '2000',
        },
        'Dequan Li (2007) — Li 3-scroll attractor': {
          // Commonly cited Li 3-scroll form:
          // xdot = a(y-x) + d x z
          // ydot = k x + f y - x z
          // zdot = -e x^2 + x y + c z
          dx: 'a*(y-x) + d*x*z',
          dy: 'k*x + f*y - x*z',
          dz: '-e*x^2 + x*y + c*z',
          params: 'a=40\nd=0.16\nk=55\nf=20\ne=0.65\nc=11/6',
          init: '2, 2, 2',
          dt: '0.0025',
          steps: '260000',
          transient: '4000',
        },
        'Heat (2D) — Gaussian blob': {
          category: 'pde_linear',
          // ODE fields (unused in PDE mode)
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          init: '',
          params: '',
          dt: '0.00025',
          steps: '30000',
          solver: 'rk4',
          sigma: '0',
          // PDE fields
          pdeType: 'heat2d',
          pdeNx: '90',
          pdeNy: '90',
          pdeXMin: '-1',
          pdeXMax: '1',
          pdeYMin: '-1',
          pdeYMax: '1',
          pdeAlpha: '0.25',
          pdeBC: 'dirichlet0',
          pdeZScale: '1.0',
          pdeU0: 'exp(-25*(x^2+y^2))',
          pdeSource: '0',
        },
        'Heat (2D) — Periodic sine decay': {
          category: 'pde_linear',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          init: '',
          params: '',
          dt: '0.002',
          steps: '15000',
          solver: 'rk4',
          sigma: '0',
          pdeType: 'heat2d',
          pdeNx: '90',
          pdeNy: '90',
          pdeXMin: '0',
          pdeXMax: '2*pi',
          pdeYMin: '0',
          pdeYMax: '2*pi',
          pdeAlpha: '0.2',
          pdeBC: 'periodic',
          pdeZScale: '1.0',
          pdeU0: 'sin(x)*sin(y)',
          pdeSource: '0',
        },
        'Heat (2D) — Center source': {
          category: 'pde_linear',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          init: '',
          params: '',
          dt: '0.0003',
          steps: '25000',
          solver: 'rk4',
          sigma: '0',
          pdeType: 'heat2d',
          pdeNx: '90',
          pdeNy: '90',
          pdeXMin: '-1',
          pdeXMax: '1',
          pdeYMin: '-1',
          pdeYMax: '1',
          pdeAlpha: '0.18',
          pdeBC: 'dirichlet0',
          pdeZScale: '1.0',
          pdeU0: '0',
          pdeSource: '3*exp(-40*(x^2+y^2))',
        },
        'Reaction–Diffusion (2D) — Fisher-KPP': {
          category: 'pde_nonlinear',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          init: '',
          params: 'r=2.0',
          dt: '0.00025',
          steps: '30000',
          solver: 'rk4',
          sigma: '0',
          pdeType: 'heat2d',
          pdeNx: '90',
          pdeNy: '90',
          pdeXMin: '-1',
          pdeXMax: '1',
          pdeYMin: '-1',
          pdeYMax: '1',
          pdeAlpha: '0.08',
          pdeBC: 'neumann0',
          pdeZScale: '1.0',
          pdeU0: '0.15*exp(-35*(x^2+y^2))',
          pdeSource: '0',
          pdeNonlinear: 'r*u*(1-u)',
        },
        'Reaction–Diffusion (2D) — Allen–Cahn': {
          category: 'pde_nonlinear',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          init: '',
          params: '',
          dt: '0.0002',
          steps: '32000',
          solver: 'rk4',
          sigma: '0',
          pdeType: 'heat2d',
          pdeNx: '90',
          pdeNy: '90',
          pdeXMin: '-1',
          pdeXMax: '1',
          pdeYMin: '-1',
          pdeYMax: '1',
          pdeAlpha: '0.06',
          pdeBC: 'neumann0',
          pdeZScale: '1.0',
          pdeU0: '0.6*(sin(3*x)+sin(3*y))',
          pdeSource: '0',
          pdeNonlinear: 'u - u^3',
        },
        "DAE — x'=-x+y, 0=y-x^2": {
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: '',
          // state is [x1, y1] => x1 is differential, x2 is algebraic
          init: '0.2, 0.04',
          dt: '0.01',
          steps: '120000',
          transient: '2000',
          solver: 'euler',
          daeNx: '1',
          daeF: "x1' = -x1 + x2",
          daeG: "0 = x2 - x1^2",
          daeTol: '1e-10',
          daeNewtonIters: '12',
        },
        'Hybrid — Integrate-and-Fire Neuron (v, spike)': {
          category: 'hybrid',
          systemType: 'hybrid',
          dim: '2',
          projX: '1',
          projY: '2',
          projZ: '1',
          // Leaky integrate-and-fire (continuous ODE) + hybrid event/reset:
          // dv/dt = -(v - v_rest)/tau + I
          // spike decays between events
          eqs: "x1' = -(x1 - v_rest)/tau + I\nx2' = -x2/tauS",
          hybridEvent: 'x1 >= v_th',
          hybridReset: "x1 = v_reset\nx2 = spikeAmp",
          params: [
            'tau=10',
            'v_rest=-65',
            'v_reset=-70',
            'v_th=-50',
            'I=2',
            'spikeAmp=1',
            'tauS=5',
          ].join('\n'),
          init: '-65, 0',
          dt: '0.05',
          steps: '120000',
          transient: '0',
          solver: 'rk4',
        },
        'Hamilton — simple pendulum (q,p)': {
          category: 'hamilton',
          systemType: 'ode',
          dim: '2',
          projX: '1',
          projY: '2',
          projZ: '1',
          // H(q,p)=p^2/2 + (1-cos(q)) => q'=p, p'=-sin(q)
          eqs: "x1' = x2\nx2' = -sin(x1)",
          params: '',
          init: '1.2, 0.0',
          dt: '0.01',
          steps: '220000',
          transient: '2000',
          solver: 'rk4',
        },
        'Gradient flow — Rosenbrock (2D)': {
          category: 'optimization',
          systemType: 'ode',
          dim: '2',
          projX: '1',
          projY: '2',
          projZ: '1',
          // f(x,y)=(1-x)^2 + 100(y-x^2)^2 ; x'=-df/dx, y'=-df/dy
          eqs: "x1' = 2*(1-x1) + 400*x1*(x2 - x1^2)\nx2' = -200*(x2 - x1^2)",
          params: '',
          init: '-1.2, 1.0',
          dt: '0.001',
          steps: '200000',
          transient: '0',
          solver: 'rk4',
        },
        'Markov — 3-state distribution (map)': {
          category: 'markov',
          systemType: 'map',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          // x_{n+1} = P x_n (column-vector convention)
          eqs: "x1 = 0.90*x1 + 0.10*x2 + 0.05*x3\nx2 = 0.07*x1 + 0.80*x2 + 0.15*x3\nx3 = 0.03*x1 + 0.10*x2 + 0.80*x3",
          params: '',
          init: '1, 0, 0',
          dt: '1',
          steps: '120000',
          transient: '0',
          solver: 'rk4',
        },
        'Custom': {
          dx: 'sigma*(y-x)',
          dy: 'x*(rho-z)-y',
          dz: 'x*y-beta*z',
          params: 'sigma=10\nrho=28\nbeta=8/3',
          init: '0.1, 0.1, 0.1',
          dt: '0.005',
          systemType: 'ode',
          sigma: '0',
          steps: '200000',
          transient: '2000',
        },
      };

      // ---- Saved presets (localStorage) ----
      const CUSTOM_PRESET_KEY = 'Custom';
      const SAVED_PREFIX = 'Saved: ';
      const SAVED_PRESETS_KEY = 'ode_saved_presets_v1';
      const DEFAULT_PRESET_KEY = 'Lorenz (1963) — Edward Lorenz / “butterfly”';
      const DEFAULT_PRESET_BY_TYPE = {
        algebraic: 'x=y line (parametric)',
        ode_linear: 'Linear ODE — damped oscillator (2D)',
        ode_nonlinear: DEFAULT_PRESET_KEY,
        map: 'Henon map (Hénon 1976) — discrete-time',
        stochastic: 'Noisy Lorenz (SDE) — Lorenz + Gaussian noise',
        pde_linear: 'Heat (2D) — Gaussian blob',
        pde_nonlinear: 'Reaction–Diffusion (2D) — Fisher-KPP',
        dae: 'DAE — x\'=-x+y, 0=y-x^2',
        hybrid: 'Hybrid — Integrate-and-Fire Neuron (v, spike)',
        hamilton: 'Hamilton — simple pendulum (q,p)',
        optimization: 'Gradient flow — Rosenbrock (2D)',
        markov: 'Markov — 3-state distribution (map)',
      };

      function categoryToEngineType(category) {
        const c = String(category || '').trim();
        if (c === 'map') return 'map';
        if (c === 'stochastic') return 'sde';
        if (c === 'algebraic') return 'param'; // currently: explicit parametric curve sampling
        if (c === 'ode_linear' || c === 'ode_nonlinear') return 'ode';
        if (c === 'pde_linear') return 'pde';
        if (c === 'pde_nonlinear') return 'pde';
        if (c === 'dae') return 'dae';
        if (c === 'hybrid') return 'hybrid';
        if (c === 'hamilton') return 'ode';
        if (c === 'optimization') return 'ode';
        if (c === 'markov') return 'map';
        return null; // not implemented yet
      }

      function engineTypeToDefaultCategory(engineType) {
        const t = String(engineType || '').trim();
        if (t === 'map') return 'map';
        if (t === 'sde') return 'stochastic';
        if (t === 'param') return 'algebraic';
        if (t === 'pde') return 'pde_linear';
        if (t === 'dae') return 'dae';
        return 'ode_nonlinear';
      }

      function getPresetCategory(presetObj) {
        // Prefer explicit category; otherwise infer from legacy engine-type field
        const c = String(presetObj?.category || '').trim();
        if (c) return c;
        const t = String(presetObj?.systemType || '').trim();
        return engineTypeToDefaultCategory(t);
      }

      function safeJsonParse(s, fallback) {
        try { return JSON.parse(s); } catch (_) { return fallback; }
      }

      function loadSavedPresetsArray() {
        try {
          const raw = localStorage.getItem(SAVED_PRESETS_KEY);
          const arr = safeJsonParse(raw, []);
          return Array.isArray(arr) ? arr : [];
        } catch (_) {
          return [];
        }
      }

      function saveSavedPresetsArray(arr) {
        try { localStorage.setItem(SAVED_PRESETS_KEY, JSON.stringify(arr)); } catch (_) {}
      }

      function sanitizeSavedName(name) {
        const s = String(name || '').trim();
        // Keep it short and safe for <option> text/value.
        return s.replace(/\s+/g, ' ').slice(0, 80);
      }

      function buildSavedPresetMap() {
        const out = {};
        const saved = loadSavedPresetsArray();
        for (const item of saved) {
          if (!item || typeof item !== 'object') continue;
          const nm = sanitizeSavedName(item.name);
          if (!nm) continue;
          const key = SAVED_PREFIX + nm;
          const category = String(item.category ?? '');
          const systemType = String(item.systemType ?? '');
          out[key] = {
            category,
            dx: String(item.dx ?? ''),
            dy: String(item.dy ?? ''),
            dz: String(item.dz ?? ''),
            eqs: String(item.eqs ?? ''),
            params: String(item.params ?? ''),
            init: String(item.init ?? ''),
            dt: String(item.dt ?? ''),
            absTol: String(item.absTol ?? ''),
            relTol: String(item.relTol ?? ''),
            dtMin: String(item.dtMin ?? ''),
            dtMax: String(item.dtMax ?? ''),
            steps: String(item.steps ?? ''),
            solver: String(item.solver ?? ''),
            systemType,
            sigma: String(item.sigma ?? ''),
            dim: String(item.dim ?? ''),
            projX: String(item.projX ?? ''),
            projY: String(item.projY ?? ''),
            projZ: String(item.projZ ?? ''),
            // PDE (linear)
            pdeType: String(item.pdeType ?? ''),
            pdeNx: String(item.pdeNx ?? ''),
            pdeNy: String(item.pdeNy ?? ''),
            pdeXMin: String(item.pdeXMin ?? ''),
            pdeXMax: String(item.pdeXMax ?? ''),
            pdeYMin: String(item.pdeYMin ?? ''),
            pdeYMax: String(item.pdeYMax ?? ''),
            pdeAlpha: String(item.pdeAlpha ?? ''),
            pdeBC: String(item.pdeBC ?? ''),
            pdeZScale: String(item.pdeZScale ?? ''),
            pdeU0: String(item.pdeU0 ?? ''),
            pdeSource: String(item.pdeSource ?? ''),
            pdeNonlinear: String(item.pdeNonlinear ?? ''),
            // DAE
            daeNx: String(item.daeNx ?? ''),
            daeF: String(item.daeF ?? ''),
            daeG: String(item.daeG ?? ''),
            daeTol: String(item.daeTol ?? ''),
            daeNewtonIters: String(item.daeNewtonIters ?? ''),
            // Algebraic implicit
            algMode: String(item.algMode ?? ''),
            algF: String(item.algF ?? ''),
            algIso: String(item.algIso ?? ''),
            algRes: String(item.algRes ?? ''),
            algXMin: String(item.algXMin ?? ''),
            algXMax: String(item.algXMax ?? ''),
            algYMin: String(item.algYMin ?? ''),
            algYMax: String(item.algYMax ?? ''),
            algZMin: String(item.algZMin ?? ''),
            algZMax: String(item.algZMax ?? ''),
            // Hybrid
            hybridEvent: String(item.hybridEvent ?? ''),
            hybridReset: String(item.hybridReset ?? ''),
          };
        }
        return out;
      }

      let presets = {};

      function normalizePreset(p) {
        // Remove run-cache fields from presets so they don't override user run settings.
        if (!p || typeof p !== 'object') return p;
        const out = { ...p };
        delete out.transient;
        delete out.ppf;
        return out;
      }

      function populatePresetDropdown(selectedKey) {
        const prev = selectedKey || ui.preset.value;
        const q = String(ui.presetSearch?.value || '').trim().toLowerCase();
        const wantCategory = String(ui.systemType?.value || 'ode_nonlinear');
        ui.preset.innerHTML = '';
        for (const name of Object.keys(presets)) {
          // Filter by current system type (keep Custom always available)
          if (name !== CUSTOM_PRESET_KEY) {
            const pc = getPresetCategory(presets[name]);
            if (pc !== wantCategory) continue;
          }
          if (q && !name.toLowerCase().includes(q)) continue;
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          ui.preset.appendChild(opt);
        }
        // Restore selection if still visible; otherwise pick the first visible option.
        const hasPrev = !!(prev && presets[prev] && Array.from(ui.preset.options).some(o => o.value === prev));
        if (hasPrev) ui.preset.value = prev;
        else {
          const def = DEFAULT_PRESET_BY_TYPE[wantCategory] || DEFAULT_PRESET_KEY;
          if (presets[def] && Array.from(ui.preset.options).some(o => o.value === def)) ui.preset.value = def;
          else ui.preset.value = ui.preset.options[0]?.value || '';
        }
      }

      function rebuildPresets(selectedKey) {
        const savedMap = buildSavedPresetMap();
        // Builtins first, then saved
        const merged = { ...builtinPresets, ...savedMap };
        // Normalize (strip transient/ppf) without editing the big builtinPresets literal.
        presets = {};
        for (const [k, v] of Object.entries(merged)) presets[k] = normalizePreset(v);
        populatePresetDropdown(selectedKey);
      }

      function setPreset(name) {
        const p = presets[name];
        if (!p) return;
        // Projection defaults: presets may set projX/Y/Z; otherwise auto-reset based on dim.
        const hasProj = (p.projX != null || p.projY != null || p.projZ != null);
        projAuto = !hasProj;
        if (p.projX != null && ui.projX) ui.projX.value = p.projX;
        if (p.projY != null && ui.projY) ui.projY.value = p.projY;
        if (p.projZ != null && ui.projZ) ui.projZ.value = p.projZ;
        if (p.eqs != null && ui.eqs) ui.eqs.value = p.eqs;
        ui.dx.value = String(p.dx ?? '');
        ui.dy.value = String(p.dy ?? '');
        ui.dz.value = String(p.dz ?? '');
        ui.params.value = String(p.params ?? '');
        ui.init.value = String(p.init ?? '');
        ui.dt.value = String(p.dt ?? '');
        if (p.absTol != null && ui.absTol) ui.absTol.value = p.absTol;
        if (p.relTol != null && ui.relTol) ui.relTol.value = p.relTol;
        if (p.dtMin != null && ui.dtMin) ui.dtMin.value = p.dtMin;
        if (p.dtMax != null && ui.dtMax) ui.dtMax.value = p.dtMax;
        ui.steps.value = String(p.steps ?? '');
        if (p.solver && ui.solver) ui.solver.value = p.solver;
        if (ui.systemType) ui.systemType.value = getPresetCategory(p);
        if (p.sigma != null && ui.sigma) ui.sigma.value = p.sigma;
        // PDE (linear)
        if (p.pdeType != null && ui.pdeType) ui.pdeType.value = String(p.pdeType);
        if (p.pdeNx != null && ui.pdeNx) ui.pdeNx.value = String(p.pdeNx);
        if (p.pdeNy != null && ui.pdeNy) ui.pdeNy.value = String(p.pdeNy);
        if (p.pdeXMin != null && ui.pdeXMin) ui.pdeXMin.value = String(p.pdeXMin);
        if (p.pdeXMax != null && ui.pdeXMax) ui.pdeXMax.value = String(p.pdeXMax);
        if (p.pdeYMin != null && ui.pdeYMin) ui.pdeYMin.value = String(p.pdeYMin);
        if (p.pdeYMax != null && ui.pdeYMax) ui.pdeYMax.value = String(p.pdeYMax);
        if (p.pdeAlpha != null && ui.pdeAlpha) ui.pdeAlpha.value = String(p.pdeAlpha);
        if (p.pdeBC != null && ui.pdeBC) ui.pdeBC.value = String(p.pdeBC);
        if (p.pdeZScale != null && ui.pdeZScale) ui.pdeZScale.value = String(p.pdeZScale);
        if (p.pdeU0 != null && ui.pdeU0) ui.pdeU0.value = String(p.pdeU0);
        if (p.pdeSource != null && ui.pdeSource) ui.pdeSource.value = String(p.pdeSource);
        if (p.pdeNonlinear != null && ui.pdeNonlinear) ui.pdeNonlinear.value = String(p.pdeNonlinear);
        // DAE
        if (p.daeNx != null && ui.daeNx) ui.daeNx.value = String(p.daeNx);
        if (p.daeF != null && ui.daeF) ui.daeF.value = String(p.daeF);
        if (p.daeG != null && ui.daeG) ui.daeG.value = String(p.daeG);
        if (p.daeTol != null && ui.daeTol) ui.daeTol.value = String(p.daeTol);
        if (p.daeNewtonIters != null && ui.daeNewtonIters) ui.daeNewtonIters.value = String(p.daeNewtonIters);
        // Hybrid
        if (p.hybridEvent != null && ui.hybridEvent) ui.hybridEvent.value = String(p.hybridEvent);
        if (p.hybridReset != null && ui.hybridReset) ui.hybridReset.value = String(p.hybridReset);
        // Algebraic implicit
        if (p.algMode != null && ui.algMode) ui.algMode.value = String(p.algMode);
        if (p.algF != null && ui.algF) ui.algF.value = String(p.algF);
        if (p.algIso != null && ui.algIso) ui.algIso.value = String(p.algIso);
        if (p.algRes != null && ui.algRes) ui.algRes.value = String(p.algRes);
        if (p.algXMin != null && ui.algXMin) ui.algXMin.value = String(p.algXMin);
        if (p.algXMax != null && ui.algXMax) ui.algXMax.value = String(p.algXMax);
        if (p.algYMin != null && ui.algYMin) ui.algYMin.value = String(p.algYMin);
        if (p.algYMax != null && ui.algYMax) ui.algYMax.value = String(p.algYMax);
        if (p.algZMin != null && ui.algZMin) ui.algZMin.value = String(p.algZMin);
        if (p.algZMax != null && ui.algZMax) ui.algZMax.value = String(p.algZMax);
        // If preset provides vector equations, prefer vector mode
        if (ui.eqMode) {
          const hasVec = !!(p.eqs && String(p.eqs).trim());
          ui.eqMode.value = hasVec ? 'vector' : 'simple';
        }
        syncEqModeUI();
        syncDimAuto();
        syncSystemTypeUI();
      }

      function updatePresetButtons() {
        const selected = ui.preset.value;
        const isCustom = selected === CUSTOM_PRESET_KEY;
        const isSaved = selected.startsWith(SAVED_PREFIX);
        ui.saveCustom.disabled = !isCustom;
        ui.deleteSaved.style.display = isSaved ? 'inline-block' : 'none';
      }

      function getCurrentCustomDraft() {
        const category = ui.systemType?.value ?? 'ode_nonlinear';
        return {
          category,
          systemType: categoryToEngineType(category) || 'ode',
          dim: ui.dim?.value ?? '3',
          projX: ui.projX?.value ?? '1',
          projY: ui.projY?.value ?? '2',
          projZ: ui.projZ?.value ?? '3',
          eqs: ui.eqs?.value ?? '',
          dx: ui.dx.value,
          dy: ui.dy.value,
          dz: ui.dz.value,
          params: ui.params.value,
          init: ui.init.value,
          dt: ui.dt.value,
          sigma: ui.sigma?.value ?? '0',
          absTol: ui.absTol?.value ?? '',
          relTol: ui.relTol?.value ?? '',
          dtMin: ui.dtMin?.value ?? '',
          dtMax: ui.dtMax?.value ?? '',
          steps: ui.steps.value,
          solver: ui.solver.value,
          // PDE (linear)
          pdeType: ui.pdeType?.value ?? '',
          pdeNx: ui.pdeNx?.value ?? '',
          pdeNy: ui.pdeNy?.value ?? '',
          pdeXMin: ui.pdeXMin?.value ?? '',
          pdeXMax: ui.pdeXMax?.value ?? '',
          pdeYMin: ui.pdeYMin?.value ?? '',
          pdeYMax: ui.pdeYMax?.value ?? '',
          pdeAlpha: ui.pdeAlpha?.value ?? '',
          pdeBC: ui.pdeBC?.value ?? '',
          pdeZScale: ui.pdeZScale?.value ?? '',
          pdeU0: ui.pdeU0?.value ?? '',
          pdeSource: ui.pdeSource?.value ?? '',
          pdeNonlinear: ui.pdeNonlinear?.value ?? '',
          // DAE
          daeNx: ui.daeNx?.value ?? '',
          daeF: ui.daeF?.value ?? '',
          daeG: ui.daeG?.value ?? '',
          daeTol: ui.daeTol?.value ?? '',
          daeNewtonIters: ui.daeNewtonIters?.value ?? '',
          // Algebraic implicit
          algMode: ui.algMode?.value ?? '',
          algF: ui.algF?.value ?? '',
          algIso: ui.algIso?.value ?? '',
          algRes: ui.algRes?.value ?? '',
          algXMin: ui.algXMin?.value ?? '',
          algXMax: ui.algXMax?.value ?? '',
          algYMin: ui.algYMin?.value ?? '',
          algYMax: ui.algYMax?.value ?? '',
          algZMin: ui.algZMin?.value ?? '',
          algZMax: ui.algZMax?.value ?? '',
          // Hybrid
          hybridEvent: ui.hybridEvent?.value ?? '',
          hybridReset: ui.hybridReset?.value ?? '',
        };
      }

      function saveCurrentCustomToLocalStorage() {
        if (ui.preset.value !== CUSTOM_PRESET_KEY) return;
        const rawName = prompt('Save Custom preset as name:', 'My Preset');
        const nm = sanitizeSavedName(rawName);
        if (!nm) return;

        const saved = loadSavedPresetsArray();
        const draft = getCurrentCustomDraft();
        const idx = saved.findIndex(p => p && typeof p === 'object' && sanitizeSavedName(p.name) === nm);
        const record = { name: nm, ...draft, updatedAt: new Date().toISOString() };
        if (idx >= 0) saved[idx] = record;
        else saved.push(record);
        saveSavedPresetsArray(saved);

        const key = SAVED_PREFIX + nm;
        rebuildPresets(key);
        setPreset(key);
        updatePresetButtons();
      }

      function deleteSelectedSavedPreset() {
        const selected = ui.preset.value;
        if (!selected.startsWith(SAVED_PREFIX)) return;
        const nm = selected.slice(SAVED_PREFIX.length);
        const ok = confirm(`Delete saved preset "${nm}"?`);
        if (!ok) return;
        const saved = loadSavedPresetsArray();
        const next = saved.filter(p => !(p && typeof p === 'object' && sanitizeSavedName(p.name) === nm));
        saveSavedPresetsArray(next);
        rebuildPresets(CUSTOM_PRESET_KEY);
        setPreset(CUSTOM_PRESET_KEY);
        updatePresetButtons();
      }

      // Populate preset dropdown (builtins + saved from localStorage)
      rebuildPresets(DEFAULT_PRESET_KEY);
      setPreset(ui.preset.value);
      updatePresetButtons();

      // ---- Algebraic: auto-switch preset when algMode changes (remember last per mode) ----
      const ALG_LAST_PARAM_KEY = 'sim_alg_last_preset_param';
      const ALG_LAST_IMPLICIT_KEY = 'sim_alg_last_preset_implicit';
      function getAlgMode() {
        return String(ui.algMode?.value || 'parametric');
      }
      function getAlgLastKey(mode) {
        return (mode === 'implicit') ? ALG_LAST_IMPLICIT_KEY : ALG_LAST_PARAM_KEY;
      }
      function rememberAlgPreset(presetName) {
        try {
          const mode = getAlgMode();
          localStorage.setItem(getAlgLastKey(mode), String(presetName || ''));
        } catch (_) {}
      }
      function isAlgebraicPresetMatching(name, mode) {
        const p = presets[name];
        if (!p) return false;
        if (getPresetCategory(p) !== 'algebraic') return false;
        const pm = String(p.algMode || 'parametric');
        return pm === mode;
      }
      function pickAlgebraicPresetForMode(mode) {
        // 1) use last used for that mode, if still exists
        try {
          const last = localStorage.getItem(getAlgLastKey(mode));
          if (last && isAlgebraicPresetMatching(last, mode)) return last;
        } catch (_) {}
        // 2) fallbacks
        if (mode === 'implicit') {
          if (isAlgebraicPresetMatching('Sphere (implicit)', 'implicit')) return 'Sphere (implicit)';
          // any implicit algebraic preset
          for (const name of Object.keys(presets)) {
            if (isAlgebraicPresetMatching(name, 'implicit')) return name;
          }
        } else {
          if (isAlgebraicPresetMatching('Lissajous Knot (parametric)', 'parametric')) return 'Lissajous Knot (parametric)';
          if (isAlgebraicPresetMatching('x=y line (parametric)', 'parametric')) return 'x=y line (parametric)';
          for (const name of Object.keys(presets)) {
            if (isAlgebraicPresetMatching(name, 'parametric')) return name;
          }
        }
        return ui.preset.value;
      }

      ui.systemType?.addEventListener('change', () => {
        // Switching system type changes which presets are visible.
        populatePresetDropdown(ui.preset.value);
        // If switching to algebraic, keep per-mode last preset (parametric vs implicit).
        if (String(ui.systemType?.value || '') === 'algebraic') {
          const want = pickAlgebraicPresetForMode(getAlgMode());
          if (want && Array.from(ui.preset.options).some(o => o.value === want)) ui.preset.value = want;
        }
        setPreset(ui.preset.value);
        updatePresetButtons();
        syncSystemTypeUI();
      });

      ui.preset.addEventListener('change', () => {
        setPreset(ui.preset.value);
        updatePresetButtons();
        // Remember last algebraic preset per mode
        if (String(ui.systemType?.value || '') === 'algebraic') rememberAlgPreset(ui.preset.value);
      });
      ui.presetSearch?.addEventListener('input', () => {
        populatePresetDropdown(ui.preset.value);
        updatePresetButtons();
      });
      ui.saveCustom.addEventListener('click', () => saveCurrentCustomToLocalStorage());
      ui.deleteSaved.addEventListener('click', () => deleteSelectedSavedPreset());

      // ---- Parser ----
      function parseParams(text) {
        const out = {};
        const lines = String(text || '').split(/\r?\n/);
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i].trim();
          if (!line) continue;
          // Remove comments
          line = line.replace(/(#|\/\/).*$/, '').trim();
          if (!line) continue;
          const m = line.match(/^([A-Za-z_]\w*)\s*=\s*(.+)$/);
          if (!m) throw new Error(`Params line ${i + 1}: expected "name = value" but got "${lines[i]}"`);
          const key = m[1];
          const expr = m[2];
          const v = math.evaluate(expr, { ...out, pi: Math.PI, e: Math.E });
          if (typeof v !== 'number' || !Number.isFinite(v)) throw new Error(`Param "${key}" is not a finite number.`);
          out[key] = v;
        }
        return out;
      }

      function parseInit(text) {
        const parts = String(text || '').split(',').map(s => s.trim()).filter(Boolean);
        // N-dim: allow fewer values (pad 0) or more (truncate)
        const n = Math.max(1, parseIntStrict(ui.dim?.value ?? '3', 'Dimension N'));
        const out = new Float64Array(n);
        for (let i = 0; i < n; i++) {
          const v = (i < parts.length) ? Number(parts[i]) : 0;
          if (!Number.isFinite(v)) throw new Error('Initial values must be numbers.');
          out[i] = v;
        }
        return out;
      }

      function parseInitForN(text, n) {
        const parts = String(text || '').split(',').map(s => s.trim()).filter(Boolean);
        const dim = Math.max(1, n | 0);
        const out = new Float64Array(dim);
        for (let i = 0; i < dim; i++) {
          const v = (i < parts.length) ? Number(parts[i]) : 0;
          if (!Number.isFinite(v)) throw new Error('Initial values must be numbers.');
          out[i] = v;
        }
        return out;
      }

      function parseHybridResetRules(text, dim) {
        const lines = String(text || '').split(/\r?\n/).map(s => s.trim()).filter(Boolean);
        const targets = [];
        const exprs = [];
        for (let i = 0; i < lines.length; i++) {
          const raw = lines[i].replace(/(#|\/\/).*$/, '').trim();
          if (!raw) continue;
          const m = raw.match(/^([A-Za-z]\w*)\s*=\s*(.+)$/);
          if (!m) throw new Error(`Hybrid reset line ${i + 1}: expected "x1 = expr" but got "${lines[i]}"`);
          const lhs = m[1];
          const rhs = m[2];
          let idx = null;
          if (/^x\d+$/i.test(lhs)) {
            idx = parseInt(lhs.slice(1), 10) - 1;
          } else if (lhs.toLowerCase() === 'x') idx = 0;
          else if (lhs.toLowerCase() === 'y') idx = 1;
          else if (lhs.toLowerCase() === 'z') idx = 2;
          if (idx == null || !(idx >= 0 && idx < dim)) {
            throw new Error(`Hybrid reset line ${i + 1}: unknown target "${lhs}" (use x1..x${dim}).`);
          }
          targets.push(idx);
          exprs.push(math.compile(rhs));
        }
        if (!targets.length) throw new Error('Hybrid reset rules must not be empty.');
        return { targets, exprs };
      }

      function evalBoolExpr(compiledExpr, tValue, stateArr, dim) {
        fillScopeFromArray(tValue, stateArr, dim);
        const s = runtime.scope;
        let v;
        try { v = compiledExpr.evaluate(s); } catch (_) { return null; }
        if (typeof v === 'boolean') return v;
        if (typeof v === 'number') return Number.isFinite(v) ? (v !== 0) : null;
        return null;
      }

      function evalVecAtState(out, tValue, stateArr, dim, compiled) {
        fillScopeFromArray(tValue, stateArr, dim);
        const exprs = compiled.compiled;
        for (let i = 0; i < dim; i++) {
          let v;
          try { v = exprs[i].evaluate(runtime.scope); } catch (_) { return false; }
          if (!isFiniteNumber(v)) return false;
          out[i] = v;
        }
        return true;
      }

      function ensureHybridScratch(dim) {
        const d = dim | 0;
        const hs = runtime.hybrid;
        if (hs._scratchDim === d && hs._scratch) return hs._scratch;
        const scratch = {
          stateA: new Float64Array(d),
          stateB: new Float64Array(d),
          stateLo: new Float64Array(d),
          k1: new Float64Array(d),
          k2: new Float64Array(d),
          k3: new Float64Array(d),
          k4: new Float64Array(d),
          tmp: new Float64Array(d),
        };
        hs._scratchDim = d;
        hs._scratch = scratch;
        return scratch;
      }

      function eulerStepInto(out, state0, t0, h, dim, compiled, scratch) {
        if (!evalVecAtState(scratch.k1, t0, state0, dim, compiled)) return false;
        for (let i = 0; i < dim; i++) out[i] = state0[i] + h * scratch.k1[i];
        return true;
      }

      function rk4StepInto(out, state0, t0, h, dim, compiled, scratch) {
        const k1l = scratch.k1, k2l = scratch.k2, k3l = scratch.k3, k4l = scratch.k4, tmp = scratch.tmp;
        if (!evalVecAtState(k1l, t0, state0, dim, compiled)) return false;
        for (let i = 0; i < dim; i++) tmp[i] = state0[i] + 0.5 * h * k1l[i];
        if (!evalVecAtState(k2l, t0 + 0.5 * h, tmp, dim, compiled)) return false;
        for (let i = 0; i < dim; i++) tmp[i] = state0[i] + 0.5 * h * k2l[i];
        if (!evalVecAtState(k3l, t0 + 0.5 * h, tmp, dim, compiled)) return false;
        for (let i = 0; i < dim; i++) tmp[i] = state0[i] + h * k3l[i];
        if (!evalVecAtState(k4l, t0 + h, tmp, dim, compiled)) return false;
        const h6 = h / 6;
        for (let i = 0; i < dim; i++) out[i] = state0[i] + h6 * (k1l[i] + 2 * k2l[i] + 2 * k3l[i] + k4l[i]);
        return true;
      }

      function integrateInto(out, state0, t0, h, dim, compiled, solver, scratch) {
        const s = String(solver || 'rk4');
        if (s === 'euler') return eulerStepInto(out, state0, t0, h, dim, compiled, scratch);
        return rk4StepInto(out, state0, t0, h, dim, compiled, scratch);
      }

      function applyHybridReset(stateArr, dim) {
        const targets = runtime.hybrid.resetTargets;
        const exprs = runtime.hybrid.resetExprs;
        if (!targets || !exprs) return false;
        fillScopeFromArray(runtime.t, stateArr, dim);
        for (let i = 0; i < targets.length; i++) {
          let v;
          try { v = exprs[i].evaluate(runtime.scope); } catch (_) { return false; }
          if (!isFiniteNumber(v)) return false;
          stateArr[targets[i]] = v;
        }
        return true;
      }

      function parseIntStrict(text, label) {
        const v = Number(String(text || '').trim());
        if (!Number.isFinite(v)) throw new Error(`${label} is not a number.`);
        const n = Math.floor(v);
        return n;
      }

      function parseFloatStrict(text, label) {
        const v = Number(String(text || '').trim());
        if (!Number.isFinite(v)) throw new Error(`${label} is not a number.`);
        return v;
      }

      function parseFloatExpr(text, label, scope) {
        const s = String(text || '').trim();
        if (!s) throw new Error(`${label} is empty.`);
        try {
          const v = math.evaluate(s, { pi: Math.PI, e: Math.E, ...(scope || {}) });
          if (typeof v !== 'number' || !Number.isFinite(v)) throw new Error('not a finite number');
          return v;
        } catch (err) {
          throw new Error(`${label} is not a number.`);
        }
      }

      function compileSystemEquations() {
        const n = Math.max(1, parseIntStrict(ui.dim?.value ?? '3', 'Dimension N'));

        const stripPrefix = (line) => {
          let s = String(line || '').trim();
          s = s.replace(/(#|\/\/).*$/, '').trim();
          if (!s) return '';
          // If user writes "x1' = ..." or "dx/dt = ..." take RHS
          const eqIdx = s.indexOf('=');
          if (eqIdx >= 0) {
            // IMPORTANT: once we take RHS, do NOT strip leading variables (e.g., "x2")
            // otherwise lines like "x1' = x2" would become empty.
            s = s.slice(eqIdx + 1).trim();
            return s;
          }
          // Also remove leading "d.../dt" patterns if they didn't include '=' (e.g., "dx/dt sigma*(y-x)")
          // IMPORTANT: do NOT strip plain leading variables like "x*(...)".
          s = s.replace(/^d\s*(x\d+|x|y|z)\s*(\/dt)?\s*/i, '').trim();
          return s;
        };

        const eqMode = String(ui.eqMode?.value || 'simple');
        const vecText = (eqMode === 'vector') ? String(ui.eqs?.value || '').trim() : '';
        const compiled = [];

        if (vecText) {
          const lines = vecText.split(/\r?\n/).map(stripPrefix).filter(Boolean);
          if (lines.length < n) throw new Error(`Vector equations need at least ${n} non-empty lines.`);
          for (let i = 0; i < n; i++) compiled.push(math.compile(lines[i]));
          return { n, compiled };
        }

        // Backward-compat: use dx/dy/dz for N=3; for N>3 pad zeros.
        const dx = stripPrefix(ui.dx.value);
        const dy = (n >= 2) ? stripPrefix(ui.dy.value) : '0';
        const dz = (n >= 3) ? stripPrefix(ui.dz.value) : '0';
        if (!dx) throw new Error('dx must not be empty (or provide vector equations).');
        if (n >= 2 && !dy) throw new Error('dy must not be empty (or provide vector equations).');
        if (n >= 3 && !dz) throw new Error('dz must not be empty (or provide vector equations).');
        compiled.push(math.compile(dx), math.compile(dy), math.compile(dz));
        for (let i = 3; i < n; i++) compiled.push(math.compile('0'));
        return { n, compiled };
      }

      function compileDAE() {
        const stripPrefix = (line) => {
          let s = String(line || '').trim();
          s = s.replace(/(#|\/\/).*$/, '').trim();
          if (!s) return '';
          const eqIdx = s.indexOf('=');
          if (eqIdx >= 0) {
            s = s.slice(eqIdx + 1).trim();
            return s;
          }
          // remove leading "0" if user writes "0 g(...)" without '='
          s = s.replace(/^0\s+/, '').trim();
          return s;
        };

        const nx = Math.max(1, parseIntStrict(ui.daeNx?.value ?? '1', 'Nx'));
        const fLines = String(ui.daeF?.value || '').split(/\r?\n/).map(stripPrefix).filter(Boolean);
        if (fLines.length < nx) throw new Error(`DAE: need at least ${nx} non-empty differential lines.`);
        const f = [];
        for (let i = 0; i < nx; i++) f.push(math.compile(fLines[i]));

        const gLines = String(ui.daeG?.value || '').split(/\r?\n/).map(stripPrefix).filter(Boolean);
        const ny = gLines.length;
        if (ny < 1) throw new Error('DAE: need at least 1 algebraic constraint line.');
        const g = [];
        for (let i = 0; i < ny; i++) g.push(math.compile(gLines[i]));

        const dim = nx + ny;
        const tol = parseFloatStrict(ui.daeTol?.value ?? '1e-8', 'Newton tol');
        const maxIters = parseIntStrict(ui.daeNewtonIters?.value ?? '12', 'Newton max iters');
        if (!(tol > 0)) throw new Error('Newton tol must be > 0.');
        if (!(maxIters >= 1)) throw new Error('Newton max iters must be >= 1.');
        return { nx, ny, dim, f, g, tol, maxIters };
      }

      // ---- Renderer (dynamic BufferGeometry) ----
      const pathGeometry = new THREE.BufferGeometry();
      const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.95 });
      const pointsMaterial = new THREE.PointsMaterial({ size: 0.01, vertexColors: true, sizeAttenuation: true });
      const pathLine = new THREE.Line(pathGeometry, lineMaterial);
      const pathPoints = new THREE.Points(pathGeometry, pointsMaterial);
      pathLine.visible = true;
      pathPoints.visible = false;
      scene.add(pathLine);
      scene.add(pathPoints);

      // ---- PDE surface (u(x,y) height field) ----
      const pdeSurface = {
        mesh: null,
        geometry: null,
        positions: null,
        colors: null,
        nx: 0,
        ny: 0,
      };

      // ---- Implicit surface (F(x,y,z)=iso) ----
      const implicitSurface = {
        mesh: null,
        geometry: null,
        points: null,
        pointsMaterial: null,
      };

      // ---- Runtime state ----
      const runtime = {
        running: false,
        solver: 'rk4',
        systemType: 'ode', // 'ode' | 'map' | 'sde' | 'param' | 'pde'
        sigma: 0,
        dim: 3,
        proj: [0, 1, 2], // 0-based indices into state
        dt: 0.005, // fixed-step dt OR adaptive initial step size (h0)
        h: 0.005,  // current adaptive step size
        dtMin: 1e-6,
        dtMax: 0.05,
        absTol: 1e-6,
        relTol: 1e-3,
        maxSteps: 200000,
        transientSteps: 2000,
        pointsPerFrame: 1500,
        params: {},
        compiled: null, // { n, compiled: math.CompiledExpression[] }
        t: 0,
        stepIndex: 0,
        state: new Float64Array(3),
        lastGood: new Float64Array(3),
        skippedDerivs: 0,
        rejectedSteps: 0,
        // geometry buffers:
        capacity: 0,
        count: 0,
        positions: null,
        colors: null,
        scope: { x: 0, y: 0, z: 0, t: 0, pi: Math.PI, e: Math.E },
        // PDE runtime (only when systemType==='pde')
        pde: {
          type: 'heat2d',
          nx: 0,
          ny: 0,
          xmin: -1,
          xmax: 1,
          ymin: -1,
          ymax: 1,
          dx: 0,
          dy: 0,
          alpha: 0.25,
          bc: 'dirichlet0',
          zScale: 1,
          u: null,
          uNext: null,
          u0: null,
          source: null,
          sourceIsZero: true,
          nonlinear: null,
          nonlinearIsZero: true,
          uMin: 0,
          uMax: 0,
        },
        // DAE runtime (only when systemType==='dae')
        dae: {
          nx: 0,
          ny: 0,
          f: null, // math.CompiledExpression[]
          g: null, // math.CompiledExpression[]
          tol: 1e-8,
          maxIters: 12,
        },
        hybrid: {
          cond: null,              // math.CompiledExpression
          resetTargets: null,      // number[]
          resetExprs: null,        // math.CompiledExpression[]
          maxEventsPerStep: 6,
        },
      };
      renderObjectsReady = true;

      function hslToRgb(h, s, l) {
        // h in [0,1]
        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          };
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return [r, g, b];
      }

      function colorForFraction(f) {
        // Early = yellow (~55deg), late = red (~0deg)
        const h = (55 * (1 - f)) / 360;
        const [r, g, b] = hslToRgb(h, 1, 0.55);
        return [r, g, b];
      }

      function resetPathGeometry(capacity) {
        runtime.capacity = capacity;
        runtime.count = 0;
        runtime.positions = new Float32Array(capacity * 3);
        runtime.colors = new Float32Array(capacity * 3);
        pathGeometry.setAttribute('position', new THREE.BufferAttribute(runtime.positions, 3));
        pathGeometry.setAttribute('color', new THREE.BufferAttribute(runtime.colors, 3));
        pathGeometry.setDrawRange(0, 0);
        // Bounding volumes will be computed after we have valid points.
      }

      function disposePdeSurface() {
        if (pdeSurface.mesh) scene.remove(pdeSurface.mesh);
        if (pdeSurface.geometry) pdeSurface.geometry.dispose();
        if (pdeSurface.mesh && pdeSurface.mesh.material) {
          // material can be an array, but we only use a single material here
          pdeSurface.mesh.material.dispose?.();
        }
        pdeSurface.mesh = null;
        pdeSurface.geometry = null;
        pdeSurface.positions = null;
        pdeSurface.colors = null;
        pdeSurface.nx = 0;
        pdeSurface.ny = 0;
      }

      function disposeImplicitSurface() {
        if (implicitSurface.mesh) scene.remove(implicitSurface.mesh);
        if (implicitSurface.points) scene.remove(implicitSurface.points);
        if (implicitSurface.geometry) implicitSurface.geometry.dispose();
        if (implicitSurface.mesh && implicitSurface.mesh.material) {
          implicitSurface.mesh.material.dispose?.();
        }
        if (implicitSurface.pointsMaterial) implicitSurface.pointsMaterial.dispose?.();
        implicitSurface.mesh = null;
        implicitSurface.geometry = null;
        implicitSurface.points = null;
        implicitSurface.pointsMaterial = null;
      }

      function ensurePdeSurfaceGeometry(nx, ny, xmin, xmax, ymin, ymax) {
        const wantNx = Math.max(2, nx | 0);
        const wantNy = Math.max(2, ny | 0);
        if (pdeSurface.geometry && pdeSurface.nx === wantNx && pdeSurface.ny === wantNy) {
          return;
        }
        disposePdeSurface();

        const nVerts = wantNx * wantNy;
        const positions = new Float32Array(nVerts * 3);
        const colors = new Float32Array(nVerts * 3);

        const xSpan = (xmax - xmin);
        const ySpan = (ymax - ymin);
        for (let j = 0; j < wantNy; j++) {
          const y = ymin + (wantNy === 1 ? 0 : (j / (wantNy - 1)) * ySpan);
          for (let i = 0; i < wantNx; i++) {
            const x = xmin + (wantNx === 1 ? 0 : (i / (wantNx - 1)) * xSpan);
            const idx = i + wantNx * j;
            const p = idx * 3;
            positions[p + 0] = x;
            positions[p + 1] = y;
            positions[p + 2] = 0;
            colors[p + 0] = 0.2;
            colors[p + 1] = 0.4;
            colors[p + 2] = 1.0;
          }
        }

        const nTris = (wantNx - 1) * (wantNy - 1) * 2;
        const indices = new Uint16Array(nTris * 3);
        let w = 0;
        for (let j = 0; j < wantNy - 1; j++) {
          for (let i = 0; i < wantNx - 1; i++) {
            const a = i + wantNx * j;
            const b = (i + 1) + wantNx * j;
            const c = i + wantNx * (j + 1);
            const d = (i + 1) + wantNx * (j + 1);
            // two triangles: a-c-b and b-c-d (consistent winding)
            indices[w++] = a; indices[w++] = c; indices[w++] = b;
            indices[w++] = b; indices[w++] = c; indices[w++] = d;
          }
        }

        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geom.setIndex(new THREE.BufferAttribute(indices, 1));
        geom.computeBoundingSphere();

        const mat = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide, transparent: true, opacity: 0.98 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.visible = false;
        scene.add(mesh);

        pdeSurface.mesh = mesh;
        pdeSurface.geometry = geom;
        pdeSurface.positions = positions;
        pdeSurface.colors = colors;
        pdeSurface.nx = wantNx;
        pdeSurface.ny = wantNy;
      }

      function updatePdeSurfaceFromField(nx, ny, u, zScale) {
        if (!pdeSurface.geometry || !pdeSurface.positions || !pdeSurface.colors) return;
        if (!u) return;
        if (pdeSurface.nx !== nx || pdeSurface.ny !== ny) return;

        // min/max for color mapping
        let uMin = Infinity;
        let uMax = -Infinity;
        const n = nx * ny;
        for (let k = 0; k < n; k++) {
          const v = u[k];
          if (v < uMin) uMin = v;
          if (v > uMax) uMax = v;
        }
        if (!Number.isFinite(uMin) || !Number.isFinite(uMax)) { uMin = 0; uMax = 1; }
        const span = (uMax - uMin) || 1;

        for (let k = 0; k < n; k++) {
          const v = u[k];
          const p = k * 3;
          pdeSurface.positions[p + 2] = (Number.isFinite(v) ? v : 0) * zScale;
          const f = Math.max(0, Math.min(1, (v - uMin) / span));
          // blue (240deg) -> red (0deg)
          const h = (240 * (1 - f)) / 360;
          const [r, g, b] = hslToRgb(h, 1, 0.55);
          pdeSurface.colors[p + 0] = r;
          pdeSurface.colors[p + 1] = g;
          pdeSurface.colors[p + 2] = b;
        }

        runtime.pde.uMin = uMin;
        runtime.pde.uMax = uMax;

        pdeSurface.geometry.attributes.position.needsUpdate = true;
        pdeSurface.geometry.attributes.color.needsUpdate = true;
        pdeSurface.geometry.computeBoundingSphere();
      }

      function buildImplicitSurfaceGeometry(exprText, isoValue, bounds, resN, params) {
        const N = Math.max(10, Math.min(140, Math.floor(resN || 40)));
        const xmin = bounds.xmin, xmax = bounds.xmax;
        const ymin = bounds.ymin, ymax = bounds.ymax;
        const zmin = bounds.zmin, zmax = bounds.zmax;
        const f = math.compile(exprText);
        const scope = { ...(params || {}), pi: Math.PI, e: Math.E, t: 0, x: 0, y: 0, z: 0 };

        const dx = (xmax - xmin) / (N - 1);
        const dy = (ymax - ymin) / (N - 1);
        const dz = (zmax - zmin) / (N - 1);

        // Cache scalar field values
        const values = new Float32Array(N * N * N);
        let idx = 0;
        for (let k = 0; k < N; k++) {
          const z = zmin + k * dz;
          scope.z = z;
          for (let j = 0; j < N; j++) {
            const y = ymin + j * dy;
            scope.y = y;
            for (let i = 0; i < N; i++) {
              const x = xmin + i * dx;
              scope.x = x;
              let v = f.evaluate(scope);
              v = (typeof v === 'number' && Number.isFinite(v)) ? v : NaN;
              values[idx++] = v;
            }
          }
        }

        const tetraList = [
          [0, 5, 1, 6],
          [0, 1, 2, 6],
          [0, 2, 3, 6],
          [0, 3, 7, 6],
          [0, 7, 4, 6],
          [0, 4, 5, 6],
        ];
        // cube corner offsets: 0..7
        const cx = [0, 1, 1, 0, 0, 1, 1, 0];
        const cy = [0, 0, 1, 1, 0, 0, 1, 1];
        const cz = [0, 0, 0, 0, 1, 1, 1, 1];

        function vIndex(i, j, k) { return i + N * (j + N * k); }
        function lerpPoint(p1, p2, v1, v2) {
          const t = (isoValue - v1) / (v2 - v1);
          return [
            p1[0] + t * (p2[0] - p1[0]),
            p1[1] + t * (p2[1] - p1[1]),
            p1[2] + t * (p2[2] - p1[2]),
          ];
        }

        // marching tetrahedra edge connections for a tetra (6 edges)
        const tetEdges = [
          [0, 1], [1, 2], [2, 0],
          [0, 3], [1, 3], [2, 3],
        ];

        const positions = [];

        function emitTri(a, b, c) {
          positions.push(a[0], a[1], a[2], b[0], b[1], b[2], c[0], c[1], c[2]);
        }

        for (let k = 0; k < N - 1; k++) {
          for (let j = 0; j < N - 1; j++) {
            for (let i = 0; i < N - 1; i++) {
              // cube corner positions/values
              const p = new Array(8);
              const val = new Array(8);
              for (let c = 0; c < 8; c++) {
                const xi = i + cx[c], yj = j + cy[c], zk = k + cz[c];
                const x = xmin + xi * dx;
                const y = ymin + yj * dy;
                const z = zmin + zk * dz;
                p[c] = [x, y, z];
                val[c] = values[vIndex(xi, yj, zk)];
              }

              // process 6 tetrahedra
              for (const tIdx of tetraList) {
                const tp = [p[tIdx[0]], p[tIdx[1]], p[tIdx[2]], p[tIdx[3]]];
                const tv = [val[tIdx[0]], val[tIdx[1]], val[tIdx[2]], val[tIdx[3]]];
                if (!tv.every(Number.isFinite)) continue;

                const inside = tv.map(v => v <= isoValue);
                const nInside = inside.filter(Boolean).length;
                if (nInside === 0 || nInside === 4) continue;

                // Collect intersection points on edges that cross the iso
                const ip = [];
                for (const [a, b] of tetEdges) {
                  if (inside[a] === inside[b]) continue;
                  ip.push(lerpPoint(tp[a], tp[b], tv[a], tv[b]));
                }

                if (ip.length === 3) {
                  emitTri(ip[0], ip[1], ip[2]);
                } else if (ip.length === 4) {
                  // split quad into 2 tris
                  emitTri(ip[0], ip[1], ip[2]);
                  emitTri(ip[0], ip[2], ip[3]);
                }
              }
            }
          }
        }

        const geom = new THREE.BufferGeometry();
        const posArr = new Float32Array(positions);
        geom.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        geom.computeVertexNormals();
        geom.computeBoundingSphere();
        return geom;
      }

      function buildImplicitSurfaceFromUI() {
        const mode = String(ui.algMode?.value || 'parametric');
        if (mode !== 'implicit') return;
        const fText = String(ui.algF?.value || '').trim();
        if (!fText) throw new Error('Algebraic: F(x,y,z) must not be empty.');
        const iso = parseFloatExpr(ui.algIso?.value ?? '0', 'iso');
        const N = parseIntStrict(ui.algRes?.value ?? '40', 'resolution (N)');
        const xmin = parseFloatExpr(ui.algXMin?.value ?? '-1', 'x min');
        const xmax = parseFloatExpr(ui.algXMax?.value ?? '1', 'x max');
        const ymin = parseFloatExpr(ui.algYMin?.value ?? '-1', 'y min');
        const ymax = parseFloatExpr(ui.algYMax?.value ?? '1', 'y max');
        const zmin = parseFloatExpr(ui.algZMin?.value ?? '-1', 'z min');
        const zmax = parseFloatExpr(ui.algZMax?.value ?? '1', 'z max');
        if (!(xmax > xmin) || !(ymax > ymin) || !(zmax > zmin)) throw new Error('Algebraic bounds must satisfy max > min.');

        const params = parseParams(ui.params.value);
        const geom = buildImplicitSurfaceGeometry(
          fText,
          iso,
          { xmin, xmax, ymin, ymax, zmin, zmax },
          N,
          params
        );

        disposeImplicitSurface();
        const mat = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide, transparent: true, opacity: 0.95 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.visible = true;
        scene.add(mesh);
        // Points view (for render mode = Points)
        const pm = new THREE.PointsMaterial({
          color: 0xffffff,
          size: pointsMaterial.size ?? 0.01,
          sizeAttenuation: true,
          transparent: true,
          opacity: 0.95,
        });
        const pts = new THREE.Points(geom, pm);
        pts.visible = false;
        scene.add(pts);
        implicitSurface.mesh = mesh;
        implicitSurface.geometry = geom;
        implicitSurface.points = pts;
        implicitSurface.pointsMaterial = pm;

        runtime.systemType = 'implicit';
        runtime.running = false;
        runtime.compiled = null;
        runtime.params = params;
        // hide path buffers
        applyRenderMode();
      }

      function resetView() {
        camera.position.set(2.8, 1.9, 3.2);
        controls.target.set(0, 0, 0);
        controls.update();
      }

      function setRunning(r) {
        uiIsRunning = !!r;
        runtime.running = r;
        const d = I18N[getCurrentLang()] || I18N.vi;
        ui.pause.textContent = runtime.running ? d.pause : d.resume;
      }

      function isFiniteNumber(v) {
        return typeof v === 'number' && Number.isFinite(v);
      }

      function isFiniteVec(v) {
        for (let i = 0; i < v.length; i++) if (!isFiniteNumber(v[i])) return false;
        return true;
      }

      function clampIndex1Based(raw, n, fallback1Based) {
        const k = Math.floor(Number(raw));
        if (!Number.isFinite(k)) return fallback1Based;
        const c = Math.max(1, Math.min(n, k));
        return c;
      }

      function getProjectedXYZ(out3) {
        const n = runtime.dim;
        const px = runtime.proj[0], py = runtime.proj[1], pz = runtime.proj[2];
        const s = runtime.state;
        out3[0] = s[Math.max(0, Math.min(n - 1, px))] ?? 0;
        out3[1] = s[Math.max(0, Math.min(n - 1, py))] ?? 0;
        out3[2] = s[Math.max(0, Math.min(n - 1, pz))] ?? 0;
      }

      // ---- Solver ----
      function fillScopeFromState(tValue) {
        const s = runtime.scope;
        s.t = tValue;
        // inject params into scope (flat)
        for (const [k, v] of Object.entries(runtime.params)) s[k] = v;
        const st = runtime.state;
        const n = runtime.dim;
        // x1..xN
        for (let i = 0; i < n; i++) s['x' + (i + 1)] = st[i];
        // legacy aliases
        s.x = n >= 1 ? st[0] : 0;
        s.y = n >= 2 ? st[1] : 0;
        s.z = n >= 3 ? st[2] : 0;
      }

      function fillScopeFromArray(tValue, arr, dim) {
        const s = runtime.scope;
        s.t = tValue;
        for (const [k, v] of Object.entries(runtime.params)) s[k] = v;
        const n = dim | 0;
        for (let i = 0; i < n; i++) s['x' + (i + 1)] = arr[i] ?? 0;
        s.x = n >= 1 ? (arr[0] ?? 0) : 0;
        s.y = n >= 2 ? (arr[1] ?? 0) : 0;
        s.z = n >= 3 ? (arr[2] ?? 0) : 0;
      }

      function evalExpr3(out3, x, y, z, t) {
        const s = runtime.scope;
        s.x = x; s.y = y; s.z = z; s.t = t;
        // inject params into scope (flat)
        for (const [k, v] of Object.entries(runtime.params)) s[k] = v;
        let a, b, c;
        try {
          // Keep legacy path for 3-field mode only
          a = runtime.compiled.compiled[0].evaluate(s);
          b = runtime.compiled.compiled[1].evaluate(s);
          c = runtime.compiled.compiled[2].evaluate(s);
        } catch (_) {
          runtime.skippedDerivs++;
          out3[0] = out3[1] = out3[2] = 0;
          return false;
        }
        if (!isFiniteNumber(a) || !isFiniteNumber(b) || !isFiniteNumber(c)) {
          runtime.skippedDerivs++;
          out3[0] = out3[1] = out3[2] = 0;
          return false;
        }
        out3[0] = a; out3[1] = b; out3[2] = c;
        return true;
      }

      function evalVec(out, tValue) {
        if (!runtime.compiled) return false;
        fillScopeFromState(tValue);
        const exprs = runtime.compiled.compiled;
        const n = runtime.dim;
        for (let i = 0; i < n; i++) {
          let v;
          try {
            v = exprs[i].evaluate(runtime.scope);
          } catch (_) {
            runtime.skippedDerivs++;
            return false;
          }
          if (!isFiniteNumber(v)) {
            runtime.skippedDerivs++;
            return false;
          }
          out[i] = v;
        }
        return true;
      }

      // ---- Adaptive embedded Runge–Kutta steppers ----
      const AdaptiveMethods = {
        // Dormand–Prince 5(4)
        dp45: {
          order: 5,
          c: [0, 1/5, 3/10, 4/5, 8/9, 1, 1],
          a: [
            [],
            [1/5],
            [3/40, 9/40],
            [44/45, -56/15, 32/9],
            [19372/6561, -25360/2187, 64448/6561, -212/729],
            [9017/3168, -355/33, 46732/5247, 49/176, -5103/18656],
            [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84],
          ],
          bHigh: [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84, 0],
          bLow:  [5179/57600, 0, 7571/16695, 393/640, -92097/339200, 187/2100, 1/40],
        },
        // Fehlberg 5(4) (RKF45)
        rkf45: {
          order: 5,
          c: [0, 1/4, 3/8, 12/13, 1, 1/2],
          a: [
            [],
            [1/4],
            [3/32, 9/32],
            [1932/2197, -7200/2197, 7296/2197],
            [439/216, -8, 3680/513, -845/4104],
            [-8/27, 2, -3544/2565, 1859/4104, -11/40],
          ],
          bHigh: [16/135, 0, 6656/12825, 28561/56430, -9/50, 2/55],
          bLow:  [25/216, 0, 1408/2565, 2197/4104, -1/5, 0],
        },
        // Bogacki–Shampine 3(2) (RK23)
        bs23: {
          order: 3,
          c: [0, 1/2, 3/4, 1],
          a: [
            [],
            [1/2],
            [0, 3/4],
            [2/9, 1/3, 4/9],
          ],
          bHigh: [2/9, 1/3, 4/9, 0],
          bLow:  [7/24, 1/4, 1/3, 1/8],
        },
        // Cash–Karp 5(4)
        ck45: {
          order: 5,
          c: [0, 1/5, 3/10, 3/5, 1, 7/8],
          a: [
            [],
            [1/5],
            [3/40, 9/40],
            [3/10, -9/10, 6/5],
            [-11/54, 5/2, -70/27, 35/27],
            [1631/55296, 175/512, 575/13824, 44275/110592, 253/4096],
          ],
          bHigh: [37/378, 0, 250/621, 125/594, 0, 512/1771],
          bLow:  [2825/27648, 0, 18575/48384, 13525/55296, 277/14336, 1/4],
        }
      };

      let kStage = [];
      let yTmp = new Float64Array(3);
      let yHigh = new Float64Array(3);
      let yLow = new Float64Array(3);
      let errVec = new Float64Array(3);

      function isAdaptiveSolver(name) {
        return name === 'dp45' || name === 'rkf45' || name === 'bs23' || name === 'ck45';
      }

      function normErrRMSVec(err, scale) {
        let sum = 0;
        const n = err.length;
        for (let i = 0; i < n; i++) {
          const r = err[i] / scale[i];
          sum += r * r;
        }
        return Math.sqrt(sum / Math.max(1, n));
      }

      function stepAdaptiveOnce(methodKey) {
        const method = AdaptiveMethods[methodKey];
        if (!method) return false;

        // If state is non-finite, recover (silent)
        if (!isFiniteVec(runtime.state)) runtime.state.set(runtime.lastGood);

        const safety = 0.9;
        const minFactor = 0.2;
        const maxFactor = 5.0;
        const maxTries = 12;

        let h = Math.max(runtime.dtMin, Math.min(runtime.dtMax, runtime.h || runtime.dt));
        if (!(h > 0)) h = runtime.dt;

        for (let attempt = 0; attempt < maxTries; attempt++) {
          // Stage 0
          const ok0 = evalVec(kStage[0], runtime.t);
          if (!ok0) {
            runtime.rejectedSteps++;
            h = Math.max(runtime.dtMin, h * 0.5);
            if (h <= runtime.dtMin) break;
            continue;
          }

          const sCount = method.c.length;
          let ok = true;
          for (let i = 1; i < sCount; i++) {
            const ai = method.a[i];
            yTmp.set(runtime.state);
            for (let j = 0; j < ai.length; j++) {
              const aij = ai[j];
              const kj = kStage[j];
              for (let d = 0; d < runtime.dim; d++) yTmp[d] += h * aij * kj[d];
            }
            const ti = runtime.t + method.c[i] * h;
            const prev = runtime.state;
            runtime.state = yTmp;
            const okStage = evalVec(kStage[i], ti);
            runtime.state = prev;
            if (!okStage) {
              ok = false;
              break;
            }
          }

          if (!ok) {
            runtime.rejectedSteps++;
            h = Math.max(runtime.dtMin, h * 0.5);
            if (h <= runtime.dtMin) break;
            continue;
          }

          // Combine high/low
          yHigh.set(runtime.state);
          yLow.set(runtime.state);

          for (let i = 0; i < sCount; i++) {
            const bh = method.bHigh[i] || 0;
            const bl = method.bLow[i] || 0;
            const ki = kStage[i];
            for (let d = 0; d < runtime.dim; d++) {
              yHigh[d] += h * bh * ki[d];
              yLow[d]  += h * bl * ki[d];
            }
          }

          for (let d = 0; d < runtime.dim; d++) errVec[d] = yHigh[d] - yLow[d];
          // reuse yTmp as scale buffer
          for (let d = 0; d < runtime.dim; d++) {
            yTmp[d] = runtime.absTol + runtime.relTol * Math.max(Math.abs(runtime.state[d]), Math.abs(yHigh[d]));
          }
          const err = normErrRMSVec(errVec, yTmp);

          if (!Number.isFinite(err)) {
            runtime.rejectedSteps++;
            h = Math.max(runtime.dtMin, h * 0.5);
            if (h <= runtime.dtMin) break;
            continue;
          }

          // Propose new step
          const p = method.order;
          const exp = 1 / (p + 1);
          const factor = err === 0 ? maxFactor : Math.min(maxFactor, Math.max(minFactor, safety * Math.pow(1 / err, exp)));
          const hNew = Math.max(runtime.dtMin, Math.min(runtime.dtMax, h * factor));

          if (err <= 1) {
            // Accept
            runtime.t += h;
            runtime.state.set(yHigh);
            if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
            runtime.h = hNew;
            return true;
          } else {
            // Reject
            runtime.rejectedSteps++;
            h = hNew;
            runtime.h = h;
            continue;
          }
        }

        // If we reach here, we couldn't get a valid step. "Ignore infinite": advance time minimally.
        runtime.skippedDerivs++;
        const adv = Math.max(runtime.dtMin, 1e-9);
        runtime.t += adv;
        runtime.h = Math.max(runtime.dtMin, Math.min(runtime.dtMax, runtime.h || runtime.dt));
        return false;
      }

      let k1 = new Float64Array(3), k2 = new Float64Array(3), k3 = new Float64Array(3), k4 = new Float64Array(3);
      function stepEuler() {
        const dt = runtime.dt;
        if (!isFiniteVec(runtime.state)) runtime.state.set(runtime.lastGood);
        const ok = evalVec(k1, runtime.t);
        if (!ok) {
          runtime.t += dt;
          return;
        }
        for (let d = 0; d < runtime.dim; d++) runtime.state[d] += dt * k1[d];
        if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
        runtime.t += dt;
      }

      // ---- Map (discrete-time) ----
      function stepMap() {
        // Use t as iteration index for convenience
        const t = runtime.t;
        if (!evalVec(k1, t)) { runtime.t += 1; return; }
        runtime.state.set(k1);
        if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
        runtime.t += 1;
      }

      // ---- SDE (Euler–Maruyama, additive noise) ----
      let _randSpare = null;
      function randn() {
        if (_randSpare != null) {
          const v = _randSpare;
          _randSpare = null;
          return v;
        }
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const mag = Math.sqrt(-2.0 * Math.log(u));
        const z0 = mag * Math.cos(2.0 * Math.PI * v);
        const z1 = mag * Math.sin(2.0 * Math.PI * v);
        _randSpare = z1;
        return z0;
      }

      function stepSDEEulerMaruyama() {
        const dt = runtime.dt;
        const sigma = Math.max(0, Number(runtime.sigma) || 0);
        if (!evalVec(k1, runtime.t)) {
          runtime.t += dt;
          return;
        }
        const sdt = Math.sqrt(Math.max(0, dt));
        for (let d = 0; d < runtime.dim; d++) runtime.state[d] += dt * k1[d] + sigma * sdt * randn();
        if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
        runtime.t += dt;
      }

      // ---- Parametric equation (sample curve) ----
      function stepParametric() {
        const dt = runtime.dt;
        // Evaluate x_i(t) and set state directly
        if (!evalVec(k1, runtime.t)) {
          runtime.t += dt;
          return;
        }
        runtime.state.set(k1);
        if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
        runtime.t += dt;
      }

      function stepRK4() {
        const dt = runtime.dt;
        if (!isFiniteVec(runtime.state)) runtime.state.set(runtime.lastGood);
        const y0 = yTmp;
        y0.set(runtime.state);
        if (!evalVec(k1, runtime.t)) { runtime.t += dt; return; }
        for (let d = 0; d < runtime.dim; d++) runtime.state[d] = y0[d] + 0.5 * dt * k1[d];
        if (!evalVec(k2, runtime.t + 0.5 * dt)) { runtime.t += dt; runtime.state.set(y0); return; }
        for (let d = 0; d < runtime.dim; d++) runtime.state[d] = y0[d] + 0.5 * dt * k2[d];
        if (!evalVec(k3, runtime.t + 0.5 * dt)) { runtime.t += dt; runtime.state.set(y0); return; }
        for (let d = 0; d < runtime.dim; d++) runtime.state[d] = y0[d] + dt * k3[d];
        if (!evalVec(k4, runtime.t + dt)) { runtime.t += dt; runtime.state.set(y0); return; }
        for (let d = 0; d < runtime.dim; d++) {
          runtime.state[d] = y0[d] + (dt / 6) * (k1[d] + 2 * k2[d] + 2 * k3[d] + k4[d]);
        }
        if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
        runtime.t += dt;
      }

      const _projTmp = [0, 0, 0];
      function appendPointFromState() {
        getProjectedXYZ(_projTmp);
        const x = _projTmp[0], y = _projTmp[1], z = _projTmp[2];
        if (!isFiniteNumber(x) || !isFiniteNumber(y) || !isFiniteNumber(z)) return false;
        const i = runtime.count;
        if (i >= runtime.capacity) return false;
        const p = i * 3;
        runtime.positions[p + 0] = x;
        runtime.positions[p + 1] = y;
        runtime.positions[p + 2] = z;
        const f = runtime.capacity <= 1 ? 1 : (i / (runtime.capacity - 1));
        const [r, g, b] = colorForFraction(f);
        runtime.colors[p + 0] = r;
        runtime.colors[p + 1] = g;
        runtime.colors[p + 2] = b;
        runtime.count++;
        return true;
      }

      function streamSolveChunk() {
        if (!runtime.running) return;
        if (runtime.systemType === 'pde') {
          streamSolveChunkPde();
          return;
        }
        if (runtime.systemType === 'dae') {
          streamSolveChunkDAE();
          return;
        }
        if (runtime.systemType === 'hybrid') {
          streamSolveChunkHybrid();
          return;
        }
        if (!runtime.compiled) return;

        const stepFn = (runtime.systemType === 'map')
          ? stepMap
          : (runtime.systemType === 'sde')
            ? stepSDEEulerMaruyama
            : (runtime.systemType === 'param')
              ? stepParametric
              : ((runtime.solver === 'euler') ? stepEuler
                : isAdaptiveSolver(runtime.solver) ? () => stepAdaptiveOnce(runtime.solver)
                : stepRK4);
        const max = runtime.maxSteps;
        const transient = runtime.transientSteps;
        const perFrame = Math.max(1, runtime.pointsPerFrame | 0);

        let wrote = 0;
        for (let n = 0; n < perFrame; n++) {
          if (runtime.stepIndex >= max) {
            setRunning(false);
            break;
          }

          // advance integrator by 1 step (non-finite is ignored inside stepFn)
          stepFn();
          runtime.stepIndex++;

          if (runtime.stepIndex <= transient) continue;
          if (!appendPointFromState()) {
            // ignore non-finite points silently
            continue;
          }
          wrote++;
        }

        if (wrote > 0) {
          pathGeometry.setDrawRange(0, runtime.count);
          pathGeometry.attributes.position.needsUpdate = true;
          pathGeometry.attributes.color.needsUpdate = true;
          // computeBoundingSphere is useful for frustum culling; safe now because we guard non-finite points.
          pathGeometry.computeBoundingSphere();
        }
      }

      function resetSimulation() {
        showError('');
        setRunning(false);
        runtime.compiled = null;
        runtime.params = {};
        runtime.t = 0;
        runtime.stepIndex = 0;
        runtime.state = new Float64Array(runtime.dim);
        runtime.lastGood = new Float64Array(runtime.dim);
        runtime.skippedDerivs = 0;
        runtime.rejectedSteps = 0;
        runtime.systemType = 'ode';
        runtime.sigma = 0;
        resetPathGeometry(1);
        // PDE reset
        runtime.pde.u = null;
        runtime.pde.uNext = null;
        runtime.pde.u0 = null;
        runtime.pde.source = null;
        runtime.pde.sourceIsZero = true;
        runtime.pde.nonlinear = null;
        runtime.pde.nonlinearIsZero = true;
        // DAE reset
        runtime.dae.nx = 0;
        runtime.dae.ny = 0;
        runtime.dae.f = null;
        runtime.dae.g = null;
        // Hybrid reset
        runtime.hybrid.cond = null;
        runtime.hybrid.resetTargets = null;
        runtime.hybrid.resetExprs = null;
        // Algebraic implicit reset
        disposeImplicitSurface();
        if (pdeSurface.mesh) pdeSurface.mesh.visible = false;
        applyRenderMode();
      }

      function compilePdeLinearSettings() {
        const type = String(ui.pdeType?.value || 'heat2d');
        if (type !== 'heat2d') throw new Error(`Unsupported PDE type: ${type}`);

        const nx = parseIntStrict(ui.pdeNx?.value ?? '60', 'Nx');
        const ny = parseIntStrict(ui.pdeNy?.value ?? '60', 'Ny');
        if (nx < 2) throw new Error('Nx must be >= 2.');
        if (ny < 2) throw new Error('Ny must be >= 2.');

        const xmin = parseFloatExpr(ui.pdeXMin?.value ?? '-1', 'x min');
        const xmax = parseFloatExpr(ui.pdeXMax?.value ?? '1', 'x max');
        const ymin = parseFloatExpr(ui.pdeYMin?.value ?? '-1', 'y min');
        const ymax = parseFloatExpr(ui.pdeYMax?.value ?? '1', 'y max');
        if (!(xmax > xmin)) throw new Error('Require x max > x min.');
        if (!(ymax > ymin)) throw new Error('Require y max > y min.');

        const alpha = parseFloatExpr(ui.pdeAlpha?.value ?? '0.25', 'alpha');
        if (!(alpha >= 0)) throw new Error('alpha must be >= 0.');

        const bc = String(ui.pdeBC?.value || 'dirichlet0');
        if (!['dirichlet0', 'neumann0', 'periodic'].includes(bc)) throw new Error(`Unknown boundary: ${bc}`);

        const zScale = parseFloatExpr(ui.pdeZScale?.value ?? '1', 'Z scale');
        if (!Number.isFinite(zScale)) throw new Error('Z scale must be a finite number.');

        const u0Text = String(ui.pdeU0?.value || '').trim();
        if (!u0Text) throw new Error('Initial condition u0 must not be empty.');
        const srcTextRaw = String(ui.pdeSource?.value || '').trim();
        const srcText = srcTextRaw ? srcTextRaw : '0';
        const sourceIsZero = !srcTextRaw || srcTextRaw === '0' || srcTextRaw === '0.0';

        const u0 = math.compile(u0Text);
        const source = math.compile(srcText);

        // Nonlinear PDE: optional reaction term N(u,x,y,t)
        const category = String(ui.systemType?.value || 'pde_linear');
        const isNonlinear = category === 'pde_nonlinear';
        const nlTextRaw = String(ui.pdeNonlinear?.value || '').trim();
        const nlText = nlTextRaw ? nlTextRaw : '0';
        const nonlinearIsZero = !isNonlinear || !nlTextRaw || nlTextRaw === '0' || nlTextRaw === '0.0';
        const nonlinear = math.compile(nlText);

        return {
          type, nx, ny, xmin, xmax, ymin, ymax, alpha, bc, zScale,
          u0, source, sourceIsZero,
          isNonlinear, nonlinear, nonlinearIsZero
        };
      }

      function initPdeField() {
        const cfg = compilePdeLinearSettings();
        const params = parseParams(ui.params.value);
        const dt = parseFloatStrict(ui.dt.value, 'dt');
        const steps = parseIntStrict(ui.steps.value, 'steps');
        const ppf = parseIntStrict(ui.ppf.value, 'Iters/frame');

        if (!(dt > 0)) throw new Error('dt must be > 0.');
        if (!(steps > 0)) throw new Error('steps must be > 0.');
        if (!(ppf > 0)) throw new Error('Iters/frame must be > 0.');

        const dx = (cfg.xmax - cfg.xmin) / (cfg.nx - 1);
        const dy = (cfg.ymax - cfg.ymin) / (cfg.ny - 1);

        // Explicit FTCS stability (2D heat): alpha*dt*(1/dx^2 + 1/dy^2) <= 1/2
        // If alpha==0 (pure reaction), skip diffusion CFL.
        if (cfg.alpha > 0) {
          const dtMax = 0.5 / (cfg.alpha * (1 / (dx * dx) + 1 / (dy * dy)));
          if (dt > dtMax) {
            throw new Error(`Stability violated for explicit heat solver.\nSuggested dt <= ${dtMax.toExponential(3)} (current dt=${dt.toExponential(3)}).`);
          }
        }

        ensurePdeSurfaceGeometry(cfg.nx, cfg.ny, cfg.xmin, cfg.xmax, cfg.ymin, cfg.ymax);
        if (pdeSurface.mesh) pdeSurface.mesh.visible = true;

        // Configure runtime
        runtime.systemType = 'pde';
        runtime.compiled = null;
        runtime.params = params;
        runtime.dt = dt;
        runtime.maxSteps = steps;
        runtime.pointsPerFrame = Math.max(1, ppf | 0); // reuse as iterations/frame
        runtime.t = 0;
        runtime.stepIndex = 0;
        runtime.skippedDerivs = 0;
        runtime.rejectedSteps = 0;

        // Update scope with params once
        for (const [k, v] of Object.entries(params)) runtime.scope[k] = v;

        // Setup PDE runtime + field arrays
        runtime.pde.type = cfg.type;
        runtime.pde.nx = cfg.nx;
        runtime.pde.ny = cfg.ny;
        runtime.pde.xmin = cfg.xmin;
        runtime.pde.xmax = cfg.xmax;
        runtime.pde.ymin = cfg.ymin;
        runtime.pde.ymax = cfg.ymax;
        runtime.pde.dx = dx;
        runtime.pde.dy = dy;
        runtime.pde.alpha = cfg.alpha;
        runtime.pde.bc = cfg.bc;
        runtime.pde.zScale = cfg.zScale;
        runtime.pde.u0 = cfg.u0;
        runtime.pde.source = cfg.source;
        runtime.pde.sourceIsZero = cfg.sourceIsZero;
        runtime.pde.nonlinear = cfg.nonlinear;
        runtime.pde.nonlinearIsZero = cfg.nonlinearIsZero;
        runtime.pde.u = new Float64Array(cfg.nx * cfg.ny);
        runtime.pde.uNext = new Float64Array(cfg.nx * cfg.ny);

        const s = runtime.scope;
        s.t = 0;
        s.z = 0;
        s.u = 0;
        for (let j = 0; j < cfg.ny; j++) {
          const y = cfg.ymin + j * dy;
          for (let i = 0; i < cfg.nx; i++) {
            const x = cfg.xmin + i * dx;
            const idx = i + cfg.nx * j;
            s.x = x;
            s.y = y;
            const v = cfg.u0.evaluate(s);
            runtime.pde.u[idx] = (typeof v === 'number' && Number.isFinite(v)) ? v : 0;
          }
        }

        applyRenderMode();

        // Render initial field
        updatePdeSurfaceFromField(cfg.nx, cfg.ny, runtime.pde.u, runtime.pde.zScale);
      }

      function wrapIndex(i, n) {
        const m = i % n;
        return (m < 0) ? (m + n) : m;
      }
      function reflectIndex(i, n) {
        if (i < 0) return -i;
        if (i > n - 1) return 2 * (n - 1) - i;
        return i;
      }

      function pdeSample(u, i, j, nx, ny, bc) {
        if (bc === 'periodic') {
          const ii = wrapIndex(i, nx);
          const jj = wrapIndex(j, ny);
          return u[ii + nx * jj];
        }
        if (bc === 'neumann0') {
          const ii = reflectIndex(i, nx);
          const jj = reflectIndex(j, ny);
          return u[ii + nx * jj];
        }
        // Dirichlet0
        if (i < 0 || i >= nx || j < 0 || j >= ny) return 0;
        return u[i + nx * j];
      }

      function stepPdeHeatOnce() {
        const p = runtime.pde;
        const nx = p.nx;
        const ny = p.ny;
        const u = p.u;
        const un = p.uNext;
        if (!u || !un) return;

        const dt = runtime.dt;
        const alpha = p.alpha;
        const invDx2 = 1 / (p.dx * p.dx);
        const invDy2 = 1 / (p.dy * p.dy);
        const bc = p.bc;
        const s = runtime.scope;
        s.t = runtime.t;
        s.z = 0;

        for (let j = 0; j < ny; j++) {
          const y = p.ymin + j * p.dy;
          for (let i = 0; i < nx; i++) {
            const x = p.xmin + i * p.dx;
            const idx = i + nx * j;
            const c = u[idx];
            const ux = (pdeSample(u, i + 1, j, nx, ny, bc) - 2 * c + pdeSample(u, i - 1, j, nx, ny, bc)) * invDx2;
            const uy = (pdeSample(u, i, j + 1, nx, ny, bc) - 2 * c + pdeSample(u, i, j - 1, nx, ny, bc)) * invDy2;
            let src = 0;
            if (!p.sourceIsZero && p.source) {
              s.x = x; s.y = y;
              const vv = p.source.evaluate(s);
              src = (typeof vv === 'number' && Number.isFinite(vv)) ? vv : 0;
            }
            let nl = 0;
            if (!p.nonlinearIsZero && p.nonlinear) {
              s.x = x; s.y = y; s.u = c;
              const vv = p.nonlinear.evaluate(s);
              nl = (typeof vv === 'number' && Number.isFinite(vv)) ? vv : 0;
            }
            const next = c + dt * (alpha * (ux + uy) + src + nl);
            un[idx] = Number.isFinite(next) ? next : 0;
          }
        }

        if (bc === 'dirichlet0') {
          // enforce boundary u=0
          for (let i = 0; i < nx; i++) {
            un[i + nx * 0] = 0;
            un[i + nx * (ny - 1)] = 0;
          }
          for (let j = 0; j < ny; j++) {
            un[0 + nx * j] = 0;
            un[(nx - 1) + nx * j] = 0;
          }
        }

        // swap buffers
        p.u = un;
        p.uNext = u;
      }

      function streamSolveChunkPde() {
        if (!runtime.running) return;
        if (runtime.systemType !== 'pde') return;
        if (!runtime.pde.u) return;

        // enforce visibility
        applyRenderMode();

        const perFrame = Math.max(1, runtime.pointsPerFrame | 0);
        for (let n = 0; n < perFrame; n++) {
          if (runtime.stepIndex >= runtime.maxSteps) {
            setRunning(false);
            break;
          }
          stepPdeHeatOnce();
          runtime.t += runtime.dt;
          runtime.stepIndex++;
        }
        updatePdeSurfaceFromField(runtime.pde.nx, runtime.pde.ny, runtime.pde.u, runtime.pde.zScale);
      }

      function solveLinearSystemInPlace(A, b, n) {
        // Gaussian elimination with partial pivoting.
        // A: Float64Array length n*n, row-major. b: Float64Array length n.
        const N = n | 0;
        for (let k = 0; k < N; k++) {
          // pivot
          let pivotRow = k;
          let pivotVal = Math.abs(A[k * N + k]);
          for (let i = k + 1; i < N; i++) {
            const v = Math.abs(A[i * N + k]);
            if (v > pivotVal) { pivotVal = v; pivotRow = i; }
          }
          if (!(pivotVal > 0) || !Number.isFinite(pivotVal)) return false;
          if (pivotRow !== k) {
            // swap rows in A and b
            for (let j = k; j < N; j++) {
              const tmp = A[k * N + j];
              A[k * N + j] = A[pivotRow * N + j];
              A[pivotRow * N + j] = tmp;
            }
            const tb = b[k]; b[k] = b[pivotRow]; b[pivotRow] = tb;
          }
          const Akk = A[k * N + k];
          // eliminate
          for (let i = k + 1; i < N; i++) {
            const factor = A[i * N + k] / Akk;
            if (!Number.isFinite(factor)) return false;
            A[i * N + k] = 0;
            for (let j = k + 1; j < N; j++) {
              A[i * N + j] -= factor * A[k * N + j];
            }
            b[i] -= factor * b[k];
          }
        }
        // back substitution
        for (let i = N - 1; i >= 0; i--) {
          let sum = b[i];
          for (let j = i + 1; j < N; j++) sum -= A[i * N + j] * b[j];
          const Aii = A[i * N + i];
          if (!(Math.abs(Aii) > 0) || !Number.isFinite(Aii)) return false;
          b[i] = sum / Aii;
          if (!Number.isFinite(b[i])) return false;
        }
        return true;
      }

      function daeEvalG(out, tValue, stateArr, dim, gCompiled) {
        fillScopeFromArray(tValue, stateArr, dim);
        const s = runtime.scope;
        for (let i = 0; i < out.length; i++) {
          const v = gCompiled[i].evaluate(s);
          out[i] = (typeof v === 'number' && Number.isFinite(v)) ? v : NaN;
        }
        return out.every(Number.isFinite);
      }

      function daeEvalF(out, tValue, stateArr, dim, fCompiled) {
        fillScopeFromArray(tValue, stateArr, dim);
        const s = runtime.scope;
        for (let i = 0; i < out.length; i++) {
          const v = fCompiled[i].evaluate(s);
          out[i] = (typeof v === 'number' && Number.isFinite(v)) ? v : NaN;
        }
        return out.every(Number.isFinite);
      }

      function daeProjectY(stateArr, dim, nx, ny, tValue, gCompiled, tol, maxIters) {
        // Newton solve for y (last ny vars) with x fixed.
        const g = new Float64Array(ny);
        const gPert = new Float64Array(ny);
        const J = new Float64Array(ny * ny);
        const delta = new Float64Array(ny);

        for (let iter = 0; iter < maxIters; iter++) {
          if (!daeEvalG(g, tValue, stateArr, dim, gCompiled)) return { ok: false, iter, reason: 'g eval non-finite' };
          let maxAbs = 0;
          for (let i = 0; i < ny; i++) maxAbs = Math.max(maxAbs, Math.abs(g[i]));
          if (maxAbs <= tol) return { ok: true, iter };

          // numerical Jacobian wrt y
          for (let j = 0; j < ny; j++) {
            const idx = nx + j;
            const y0 = stateArr[idx];
            const eps = 1e-6 * (1 + Math.abs(y0));
            stateArr[idx] = y0 + eps;
            daeEvalG(gPert, tValue, stateArr, dim, gCompiled);
            stateArr[idx] = y0;
            for (let i = 0; i < ny; i++) {
              J[i * ny + j] = (gPert[i] - g[i]) / eps;
            }
          }

          // Solve J * delta = -g
          for (let i = 0; i < ny; i++) delta[i] = -g[i];
          const A = new Float64Array(J); // copy
          const okSolve = solveLinearSystemInPlace(A, delta, ny);
          if (!okSolve) return { ok: false, iter, reason: 'singular Jacobian' };

          // update y
          for (let j = 0; j < ny; j++) {
            const idx = nx + j;
            stateArr[idx] += delta[j];
          }
        }
        return { ok: false, iter: maxIters, reason: 'max iters' };
      }

      function streamSolveChunkDAE() {
        if (!runtime.running) return;
        const nx = runtime.dae.nx | 0;
        const ny = runtime.dae.ny | 0;
        const dim = nx + ny;
        if (!(nx >= 1) || !(ny >= 1) || runtime.dim !== dim) return;
        const f = runtime.dae.f;
        const g = runtime.dae.g;
        if (!f || !g) return;

        const dt = runtime.dt;
        const perFrame = Math.max(1, runtime.pointsPerFrame | 0);
        const maxSteps = runtime.maxSteps;
        const transient = runtime.transientSteps;

        const fVec = new Float64Array(nx);
        const next = new Float64Array(dim);

        let wrote = 0;
        for (let n = 0; n < perFrame; n++) {
          if (runtime.stepIndex >= maxSteps) { setRunning(false); break; }

          next.set(runtime.state);
          if (!daeEvalF(fVec, runtime.t, next, dim, f)) {
            setRunning(false);
            showError('DAE error: non-finite f(x,y,t).');
            break;
          }
          // Euler step on x
          for (let i = 0; i < nx; i++) next[i] = next[i] + dt * fVec[i];

          // Project y via constraints at t+dt
          const proj = daeProjectY(next, dim, nx, ny, runtime.t + dt, g, runtime.dae.tol, runtime.dae.maxIters);
          if (!proj.ok) {
            setRunning(false);
            showError(`DAE Newton failed (${proj.reason}) at step ${runtime.stepIndex}.\nTry: smaller dt, better initial guess, or simpler constraints.`);
            break;
          }

          runtime.state.set(next);
          runtime.lastGood.set(next);
          runtime.t += dt;
          runtime.stepIndex++;

          if (runtime.stepIndex <= transient) continue;
          if (!appendPointFromState()) continue;
          wrote++;
        }

        if (wrote > 0) {
          pathGeometry.setDrawRange(0, runtime.count);
          pathGeometry.attributes.position.needsUpdate = true;
          pathGeometry.attributes.color.needsUpdate = true;
          pathGeometry.computeBoundingSphere();
        }
      }

      function stepHybridOnce() {
        const dim = runtime.dim;
        const compiled = runtime.compiled;
        const cond = runtime.hybrid.cond;
        if (!compiled || !cond) return false;
        const maxEvents = runtime.hybrid.maxEventsPerStep | 0;
        const scratch = ensureHybridScratch(dim);

        let remaining = runtime.dt;
        let events = 0;
        // Use scratch buffers for sub-stepping (no allocations)
        scratch.stateA.set(runtime.state);
        let state = scratch.stateA;
        let t0 = runtime.t;

        // If we start already in triggered region, reset immediately (no time consumed)
        for (let guard = 0; guard < 3; guard++) {
          const c0 = evalBoolExpr(cond, t0, state, dim);
          if (c0 == null) return false;
          if (!c0) break;
          if (!applyHybridReset(state, dim)) return false;
        }

        while (remaining > 0) {
          if (events > maxEvents) return false;
          const cStart = evalBoolExpr(cond, t0, state, dim);
          if (cStart == null) return false;
          if (cStart) {
            // shouldn't happen often due to guard above, but handle safely
            if (!applyHybridReset(state, dim)) return false;
            events++;
            continue;
          }

          if (!integrateInto(scratch.stateB, state, t0, remaining, dim, compiled, runtime.solver, scratch)) return false;
          const cEnd = evalBoolExpr(cond, t0 + remaining, scratch.stateB, dim);
          if (cEnd == null) return false;
          if (!cEnd) {
            // no event in this remainder
            // swap A/B
            const tmpS = state;
            state = scratch.stateB;
            scratch.stateB = tmpS;
            t0 = t0 + remaining;
            remaining = 0;
            break;
          }

          // Event crossing: find time within (0, remaining] via bisection
          let lo = 0;
          let hi = remaining;
          scratch.stateLo.set(state);
          for (let it = 0; it < 28; it++) {
            const mid = 0.5 * (lo + hi);
            if (!integrateInto(scratch.stateB, state, t0, mid, dim, compiled, runtime.solver, scratch)) return false;
            const cMid = evalBoolExpr(cond, t0 + mid, scratch.stateB, dim);
            if (cMid == null) return false;
            if (cMid) {
              hi = mid;
            } else {
              lo = mid;
              scratch.stateLo.set(scratch.stateB);
            }
            if (hi - lo < Math.max(1e-6, 1e-3 * remaining)) break;
          }

          // Advance to event time ~hi
          if (!integrateInto(scratch.stateB, state, t0, hi, dim, compiled, runtime.solver, scratch)) return false;
          t0 = t0 + hi;
          remaining = remaining - hi;
          // swap
          const tmpS2 = state;
          state = scratch.stateB;
          scratch.stateB = tmpS2;

          // Apply reset instantly at event time
          runtime.t = t0; // for scope evaluation inside reset
          if (!applyHybridReset(state, dim)) return false;
          events++;
        }

        runtime.state.set(state);
        runtime.lastGood.set(state);
        runtime.t = t0;
        return true;
      }

      function streamSolveChunkHybrid() {
        if (!runtime.running) return;
        if (!runtime.compiled || !runtime.hybrid.cond) return;
        const max = runtime.maxSteps;
        const transient = runtime.transientSteps;
        const perFrame = Math.max(1, runtime.pointsPerFrame | 0);

        let wrote = 0;
        for (let n = 0; n < perFrame; n++) {
          if (runtime.stepIndex >= max) { setRunning(false); break; }
          const ok = stepHybridOnce();
          runtime.stepIndex++;
          if (!ok) {
            setRunning(false);
            showError('Hybrid error: event/reset evaluation failed. Check condition/reset expressions and dt.');
            break;
          }
          if (runtime.stepIndex <= transient) continue;
          if (!appendPointFromState()) continue;
          wrote++;
        }

        if (wrote > 0) {
          pathGeometry.setDrawRange(0, runtime.count);
          pathGeometry.attributes.position.needsUpdate = true;
          pathGeometry.attributes.color.needsUpdate = true;
          pathGeometry.computeBoundingSphere();
        }
      }

      function startSimulation() {
        try {
          showError('');
          // If we previously built an implicit surface, dispose it when starting other modes.
          if (runtime.systemType === 'implicit') {
            disposeImplicitSurface();
            runtime.systemType = 'param';
            applyRenderMode();
          }
          const category = String(ui.systemType?.value || 'ode_nonlinear');
          const systemType = categoryToEngineType(category);
          if (!systemType) throw new Error(`This category is not implemented yet: ${category}`);
          if (category === 'algebraic' && String(ui.algMode?.value || 'parametric') === 'implicit') {
            buildImplicitSurfaceFromUI();
            showNotice('Built implicit surface mesh.');
            setRunning(false);
            return;
          }
          if (systemType === 'pde') {
            initPdeField();
            setRunning(true);
            return;
          }
          if (systemType === 'hybrid') {
            syncDimAuto();
            const compiled = compileSystemEquations();
            const params = parseParams(ui.params.value);
            const initState = parseInit(ui.init.value);
            const dt = parseFloatStrict(ui.dt.value, 'dt');
            const steps = parseIntStrict(ui.steps.value, 'steps');
            const transient = parseIntStrict(ui.transient.value, 'transient');
            const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');
            if (!(dt > 0)) throw new Error('dt must be > 0.');
            if (!(steps > 10)) throw new Error('steps must be > 10.');
            if (!(transient >= 0)) throw new Error('transient must be >= 0.');
            if (transient >= steps) throw new Error('transient must be < steps.');
            if (!(ppf > 0)) throw new Error('Points/frame must be > 0.');

            const condText = String(ui.hybridEvent?.value || '').trim();
            if (!condText) throw new Error('Hybrid: event condition must not be empty.');
            const cond = math.compile(condText);
            const rr = parseHybridResetRules(ui.hybridReset?.value || '', compiled.n);

            runtime.systemType = 'hybrid';
            runtime.compiled = compiled;
            runtime.params = params;
            runtime.dim = compiled.n;
            runtime.dt = dt;
            runtime.maxSteps = steps;
            runtime.transientSteps = transient;
            runtime.pointsPerFrame = Math.max(1, ppf);
            runtime.t = 0;
            runtime.stepIndex = 0;
            runtime.skippedDerivs = 0;
            runtime.rejectedSteps = 0;
            runtime.state = initState;
            runtime.lastGood = new Float64Array(runtime.dim);
            runtime.lastGood.set(initState);

            runtime.hybrid.cond = cond;
            runtime.hybrid.resetTargets = rr.targets;
            runtime.hybrid.resetExprs = rr.exprs;

            // Hybrid supports fixed-step only
            runtime.solver = (String(ui.solver?.value || 'rk4') === 'euler') ? 'euler' : 'rk4';

            const px = clampIndex1Based(ui.projX?.value ?? '1', runtime.dim, 1) - 1;
            const py = clampIndex1Based(ui.projY?.value ?? '2', runtime.dim, Math.min(2, runtime.dim)) - 1;
            const pz = clampIndex1Based(ui.projZ?.value ?? '3', runtime.dim, Math.min(3, runtime.dim)) - 1;
            runtime.proj = [px, py, pz];

            resetPathGeometry(Math.max(1, steps - transient));
            appendPointFromState();
            pathGeometry.setDrawRange(0, runtime.count);
            pathGeometry.attributes.position.needsUpdate = true;
            pathGeometry.attributes.color.needsUpdate = true;
            pathGeometry.computeBoundingSphere();

            applyRenderMode();
            setRunning(true);
            return;
          }
          if (systemType === 'dae') {
            const cfg = compileDAE();
            const params = parseParams(ui.params.value);
            const dt = parseFloatStrict(ui.dt.value, 'dt');
            const steps = parseIntStrict(ui.steps.value, 'steps');
            const transient = parseIntStrict(ui.transient.value, 'transient');
            const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');
            if (!(dt > 0)) throw new Error('dt must be > 0.');
            if (!(steps > 10)) throw new Error('steps must be > 10.');
            if (!(transient >= 0)) throw new Error('transient must be >= 0.');
            if (transient >= steps) throw new Error('transient must be < steps.');
            if (!(ppf > 0)) throw new Error('Points/frame must be > 0.');

            runtime.systemType = 'dae';
            runtime.compiled = null;
            runtime.params = params;
            runtime.dim = cfg.dim;
            runtime.dt = dt;
            runtime.maxSteps = steps;
            runtime.transientSteps = transient;
            runtime.pointsPerFrame = Math.max(1, ppf | 0);
            runtime.solver = 'euler';
            runtime.t = 0;
            runtime.stepIndex = 0;
            runtime.skippedDerivs = 0;
            runtime.rejectedSteps = 0;

            runtime.dae.nx = cfg.nx;
            runtime.dae.ny = cfg.ny;
            runtime.dae.f = cfg.f;
            runtime.dae.g = cfg.g;
            runtime.dae.tol = cfg.tol;
            runtime.dae.maxIters = cfg.maxIters;

            const initState = parseInitForN(ui.init.value, cfg.dim);
            runtime.state = initState;
            runtime.lastGood = new Float64Array(cfg.dim);
            runtime.lastGood.set(initState);

            // Ensure initial constraints satisfied (project y at t=0)
            const proj0 = daeProjectY(runtime.state, cfg.dim, cfg.nx, cfg.ny, 0, cfg.g, cfg.tol, cfg.maxIters);
            if (!proj0.ok) throw new Error('DAE init: constraints could not be satisfied (Newton failed).');
            runtime.lastGood.set(runtime.state);

            // Projection indices
            const px = clampIndex1Based(ui.projX?.value ?? '1', runtime.dim, 1) - 1;
            const py = clampIndex1Based(ui.projY?.value ?? '2', runtime.dim, Math.min(2, runtime.dim)) - 1;
            const pz = clampIndex1Based(ui.projZ?.value ?? '3', runtime.dim, Math.min(3, runtime.dim)) - 1;
            runtime.proj = [px, py, pz];

            resetPathGeometry(Math.max(1, steps - transient));
            appendPointFromState();
            pathGeometry.setDrawRange(0, runtime.count);
            pathGeometry.attributes.position.needsUpdate = true;
            pathGeometry.attributes.color.needsUpdate = true;
            pathGeometry.computeBoundingSphere();

            applyRenderMode();
            setRunning(true);
            return;
          }

          syncDimAuto();

          const compiled = compileSystemEquations();
          const params = parseParams(ui.params.value);
          const initState = parseInit(ui.init.value);
          const dt = parseFloatStrict(ui.dt.value, 'dt');
          const sigma = parseFloatStrict(ui.sigma?.value ?? '0', 'sigma');
          const absTol = parseFloatStrict(ui.absTol?.value ?? '1e-6', 'absTol');
          const relTol = parseFloatStrict(ui.relTol?.value ?? '1e-3', 'relTol');
          const dtMin = parseFloatStrict(ui.dtMin?.value ?? '1e-6', 'dtMin');
          const dtMax = parseFloatStrict(ui.dtMax?.value ?? '0.05', 'dtMax');
          const steps = parseIntStrict(ui.steps.value, 'steps');
          const transient = parseIntStrict(ui.transient.value, 'transient');
          const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');

          if (!(dt > 0)) throw new Error('dt must be > 0.');
          if (!(absTol > 0)) throw new Error('absTol must be > 0.');
          if (!(relTol > 0)) throw new Error('relTol must be > 0.');
          if (!(dtMin > 0)) throw new Error('dtMin must be > 0.');
          if (!(dtMax > 0)) throw new Error('dtMax must be > 0.');
          if (dtMin > dtMax) throw new Error('dtMin must be <= dtMax.');
          if (!(steps > 10)) throw new Error('steps must be > 10.');
          if (!(transient >= 0)) throw new Error('transient must be >= 0.');
          if (transient >= steps) throw new Error('transient must be < steps.');

          runtime.compiled = compiled;
          runtime.params = params;
          runtime.dim = compiled.n;
          // allocate dimension-dependent buffers
          k1 = new Float64Array(runtime.dim);
          k2 = new Float64Array(runtime.dim);
          k3 = new Float64Array(runtime.dim);
          k4 = new Float64Array(runtime.dim);
          yTmp = new Float64Array(runtime.dim);
          yHigh = new Float64Array(runtime.dim);
          yLow = new Float64Array(runtime.dim);
          errVec = new Float64Array(runtime.dim);
          kStage = Array.from({ length: 7 }, () => new Float64Array(runtime.dim));

          const px = clampIndex1Based(ui.projX?.value ?? '1', runtime.dim, 1) - 1;
          const py = clampIndex1Based(ui.projY?.value ?? '2', runtime.dim, Math.min(2, runtime.dim)) - 1;
          const pz = clampIndex1Based(ui.projZ?.value ?? '3', runtime.dim, Math.min(3, runtime.dim)) - 1;
          runtime.proj = [px, py, pz];

          runtime.dt = dt;
          runtime.h = Math.max(dtMin, Math.min(dtMax, dt));
          runtime.absTol = absTol;
          runtime.relTol = relTol;
          runtime.dtMin = dtMin;
          runtime.dtMax = dtMax;
          runtime.systemType = systemType;
          runtime.sigma = sigma;
          runtime.maxSteps = steps;
          runtime.transientSteps = transient;
          runtime.pointsPerFrame = Math.max(1, ppf);
          runtime.solver = String(ui.solver.value || 'rk4');
          runtime.t = 0;
          runtime.stepIndex = 0;
          runtime.skippedDerivs = 0;
          runtime.rejectedSteps = 0;
          runtime.state = initState;
          runtime.lastGood = new Float64Array(runtime.dim);
          runtime.lastGood.set(initState);

          // Pre-allocate only for the kept points (after transient)
          resetPathGeometry(Math.max(1, steps - transient));
          appendPointFromState();
          pathGeometry.setDrawRange(0, runtime.count);
          pathGeometry.attributes.position.needsUpdate = true;
          pathGeometry.attributes.color.needsUpdate = true;
          pathGeometry.computeBoundingSphere();

          applyRenderMode();
          setRunning(true);
        } catch (err) {
          showError(`Start error:\n${String(err && err.message ? err.message : err)}`);
          setRunning(false);
        }
      }

      function validateSimulation() {
        try {
          showError('');
          const category = String(ui.systemType?.value || 'ode_nonlinear');
          const systemType = categoryToEngineType(category);
          if (!systemType) throw new Error(`This category is not implemented yet: ${category}`);

          if (category === 'algebraic' && String(ui.algMode?.value || 'parametric') === 'implicit') {
            const fText = String(ui.algF?.value || '').trim();
            if (!fText) throw new Error('Algebraic: F(x,y,z) must not be empty.');
            const iso = parseFloatExpr(ui.algIso?.value ?? '0', 'iso');
            const xmin = parseFloatExpr(ui.algXMin?.value ?? '-1', 'x min');
            const xmax = parseFloatExpr(ui.algXMax?.value ?? '1', 'x max');
            const ymin = parseFloatExpr(ui.algYMin?.value ?? '-1', 'y min');
            const ymax = parseFloatExpr(ui.algYMax?.value ?? '1', 'y max');
            const zmin = parseFloatExpr(ui.algZMin?.value ?? '-1', 'z min');
            const zmax = parseFloatExpr(ui.algZMax?.value ?? '1', 'z max');
            if (!(xmax > xmin) || !(ymax > ymin) || !(zmax > zmin)) throw new Error('Algebraic bounds must satisfy max > min.');
            // quick eval sanity
            const params = parseParams(ui.params.value);
            const f = math.compile(fText);
            const scope = { ...(params || {}), pi: Math.PI, e: Math.E, t: 0, x: xmin, y: ymin, z: zmin };
            const v = f.evaluate(scope);
            if (typeof v !== 'number' || !Number.isFinite(v)) throw new Error('F(x,y,z) did not evaluate to a finite number (check params).');
            void iso;
            showNotice('OK: algebraic implicit surface compiled successfully.');
            return;
          }

          if (systemType === 'pde') {
            // basic PDE validation
            compilePdeLinearSettings();
            parseParams(ui.params.value);
            const dt = parseFloatStrict(ui.dt.value, 'dt');
            const steps = parseIntStrict(ui.steps.value, 'steps');
            const ppf = parseIntStrict(ui.ppf.value, 'Iters/frame');
            if (!(dt > 0)) throw new Error('dt must be > 0.');
            if (!(steps > 0)) throw new Error('steps must be > 0.');
            if (!(ppf > 0)) throw new Error('Iters/frame must be > 0.');
            // stability check
            const cfg = compilePdeLinearSettings();
            const dx = (cfg.xmax - cfg.xmin) / (cfg.nx - 1);
            const dy = (cfg.ymax - cfg.ymin) / (cfg.ny - 1);
            if (cfg.alpha > 0) {
              const dtMax = 0.5 / (cfg.alpha * (1 / (dx * dx) + 1 / (dy * dy)));
              if (dt > dtMax) throw new Error(`Stability violated. Suggested dt <= ${dtMax.toExponential(3)}.`);
            }
            showNotice('OK: PDE inputs compiled successfully.');
            return;
          }
          if (systemType === 'hybrid') {
            syncDimAuto();
            compileSystemEquations();
            parseParams(ui.params.value);
            parseInit(ui.init.value);
            const dt = parseFloatStrict(ui.dt.value, 'dt');
            const steps = parseIntStrict(ui.steps.value, 'steps');
            const transient = parseIntStrict(ui.transient.value, 'transient');
            const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');
            if (!(dt > 0)) throw new Error('dt must be > 0.');
            if (!(steps > 10)) throw new Error('steps must be > 10.');
            if (!(transient >= 0)) throw new Error('transient must be >= 0.');
            if (transient >= steps) throw new Error('transient must be < steps.');
            if (!(ppf > 0)) throw new Error('Points/frame must be > 0.');
            const condText = String(ui.hybridEvent?.value || '').trim();
            if (!condText) throw new Error('Hybrid: event condition must not be empty.');
            math.compile(condText);
            parseHybridResetRules(ui.hybridReset?.value || '', parseIntStrict(ui.dim?.value ?? '2', 'Dimension N'));
            showNotice('OK: Hybrid inputs compiled successfully.');
            return;
          }
          if (systemType === 'dae') {
            const cfg = compileDAE();
            parseParams(ui.params.value);
            const dt = parseFloatStrict(ui.dt.value, 'dt');
            const steps = parseIntStrict(ui.steps.value, 'steps');
            const transient = parseIntStrict(ui.transient.value, 'transient');
            const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');
            if (!(dt > 0)) throw new Error('dt must be > 0.');
            if (!(steps > 10)) throw new Error('steps must be > 10.');
            if (!(transient >= 0)) throw new Error('transient must be >= 0.');
            if (transient >= steps) throw new Error('transient must be < steps.');
            if (!(ppf > 0)) throw new Error('Points/frame must be > 0.');
            // init vector length
            parseInitForN(ui.init.value, cfg.dim);
            showNotice('OK: DAE inputs compiled successfully.');
            return;
          }

          syncDimAuto();

          const compiled = compileSystemEquations();
          parseParams(ui.params.value);
          parseInit(ui.init.value);

          const dt = parseFloatStrict(ui.dt.value, 'dt');
          const steps = parseIntStrict(ui.steps.value, 'steps/iterations');
          const transient = parseIntStrict(ui.transient.value, 'transient');
          const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');

          if (!(steps > 10)) throw new Error('steps/iterations must be > 10.');
          if (!(transient >= 0)) throw new Error('transient must be >= 0.');
          if (transient >= steps) throw new Error('transient must be < steps/iterations.');
          if (!(ppf > 0)) throw new Error('Points/frame must be > 0.');

          if (systemType !== 'map') {
            if (!(dt > 0)) throw new Error('dt must be > 0.');
          }

          if (systemType === 'ode' && isAdaptiveSolver(String(ui.solver?.value || 'rk4'))) {
            const absTol = parseFloatStrict(ui.absTol?.value ?? '1e-6', 'absTol');
            const relTol = parseFloatStrict(ui.relTol?.value ?? '1e-3', 'relTol');
            const dtMin = parseFloatStrict(ui.dtMin?.value ?? '1e-6', 'dtMin');
            const dtMax = parseFloatStrict(ui.dtMax?.value ?? '0.05', 'dtMax');
            if (!(absTol > 0)) throw new Error('absTol must be > 0.');
            if (!(relTol > 0)) throw new Error('relTol must be > 0.');
            if (!(dtMin > 0)) throw new Error('dtMin must be > 0.');
            if (!(dtMax > 0)) throw new Error('dtMax must be > 0.');
            if (dtMin > dtMax) throw new Error('dtMin must be <= dtMax.');
          }

          // Projection indices sanity
          const n = compiled.n;
          clampIndex1Based(ui.projX?.value ?? '1', n, 1);
          clampIndex1Based(ui.projY?.value ?? '2', n, Math.min(2, n));
          clampIndex1Based(ui.projZ?.value ?? '3', n, Math.min(3, n));

          showNotice('OK: inputs compiled successfully.');
        } catch (err) {
          showError(`Validate error:\n${String(err && err.message ? err.message : err)}`);
        }
      }

      // ---- Buttons ----
      ui.start.addEventListener('click', startSimulation);
      ui.validate?.addEventListener('click', validateSimulation);
      ui.pause.addEventListener('click', () => setRunning(!runtime.running));
      ui.reset.addEventListener('click', () => resetSimulation());

      // ---- Wizards ----
      function splitCells(line) {
        return String(line || '').trim().split(/[,\s]+/).filter(Boolean);
      }

      // Wizards panel removed

      // ---- Settings panel wiring (no dat.gui) ----
      const settingsCache = loadSettingsCache();

      // language
      if (settings.langSelect) settings.langSelect.value = getCurrentLang();
      settings.langSelect?.addEventListener('change', () => setCurrentLang(String(settings.langSelect.value || 'vi')));

      // axes
      axes.visible = (settingsCache.axesVisible == null) ? true : !!settingsCache.axesVisible;
      if (settings.axesSelect) settings.axesSelect.value = axes.visible ? '1' : '0';
      settings.axesSelect?.addEventListener('change', () => {
        axes.visible = String(settings.axesSelect.value) === '1';
        saveSettingsCache({ axesVisible: axes.visible });
      });

      // render mode
      // Use var to avoid TDZ issues: applyRenderMode() can be called before this block runs.
      var currentMode = (settingsCache.renderMode === 'Points' || settingsCache.renderMode === 'Line') ? settingsCache.renderMode : 'Points';
      function applyRenderMode() {
        if (!renderObjectsReady) return;
        const isPoints = String(currentMode || 'Line') === 'Points';
        const isPde = runtime.systemType === 'pde';
        const isImplicit = runtime.systemType === 'implicit';
        // PDE/Implicit use their own meshes; ignore path render modes
        pathPoints.visible = !(isPde || isImplicit) && isPoints;
        pathLine.visible = !(isPde || isImplicit) && !isPoints;
        if (pdeSurface.mesh) pdeSurface.mesh.visible = isPde;
        if (implicitSurface.mesh) implicitSurface.mesh.visible = isImplicit && !isPoints;
        if (implicitSurface.points) implicitSurface.points.visible = isImplicit && isPoints;
      }
      if (settings.modeSelect) settings.modeSelect.value = currentMode;
      settings.modeSelect?.addEventListener('change', () => {
        currentMode = String(settings.modeSelect.value || 'Line');
        saveSettingsCache({ renderMode: currentMode });
        applyRenderMode();
      });
      applyRenderMode();

      // point size
      function clampPointSize(v) {
        return Math.max(0.001, Math.min(0.08, Number(v) || 0.01));
      }
      function setPointSize(v) {
        const s = clampPointSize(v);
        pointsMaterial.size = s;
        pointsMaterial.needsUpdate = true;
        if (implicitSurface.pointsMaterial) {
          implicitSurface.pointsMaterial.size = s;
          implicitSurface.pointsMaterial.needsUpdate = true;
        }
        if (settings.pointSize) settings.pointSize.value = String(s);
        if (settings.pointSizeNum) settings.pointSizeNum.value = String(s);
      }
      setPointSize((settingsCache.pointSize != null) ? settingsCache.pointSize : (pointsMaterial.size ?? 0.01));
      settings.pointSize?.addEventListener('input', () => {
        setPointSize(settings.pointSize.value);
        saveSettingsCache({ pointSize: clampPointSize(settings.pointSize.value) });
      });
      settings.pointSizeNum?.addEventListener('input', () => {
        setPointSize(settings.pointSizeNum.value);
        saveSettingsCache({ pointSize: clampPointSize(settings.pointSizeNum.value) });
      });

      // camera move speed (keyboard)
      function clampCamSpeed(v) {
        return Math.max(0.2, Math.min(3.5, Number(v) || 1.0));
      }
      function setCamSpeed(v) {
        const s = clampCamSpeed(v);
        cameraMoveSpeed = s;
        if (settings.camSpeed) settings.camSpeed.value = String(s);
        if (settings.camSpeedNum) settings.camSpeedNum.value = String(s);
      }
      setCamSpeed((settingsCache.cameraSpeed != null) ? settingsCache.cameraSpeed : 1.0);
      settings.camSpeed?.addEventListener('input', () => {
        setCamSpeed(settings.camSpeed.value);
        saveSettingsCache({ cameraSpeed: clampCamSpeed(settings.camSpeed.value) });
      });
      settings.camSpeedNum?.addEventListener('input', () => {
        setCamSpeed(settings.camSpeedNum.value);
        saveSettingsCache({ cameraSpeed: clampCamSpeed(settings.camSpeedNum.value) });
      });

      // mouse lock + sensitivity
      setPointerLockEnabled(settingsCache.mouseLock != null ? !!settingsCache.mouseLock : false);
      setMouseSensitivity((settingsCache.mouseSensitivity != null) ? settingsCache.mouseSensitivity : 1.0);
      settings.mouseLockBtn?.addEventListener('click', () => {
        if (!mouseLockEnabled) {
          // turn on and lock
          setPointerLockEnabled(true);
        }
        if (isPointerLocked()) { _unlockRequested = true; exitPointerLock(); }
        else requestPointerLock();
      });
      settings.mouseSense?.addEventListener('input', () => setMouseSensitivity(settings.mouseSense.value));
      settings.mouseSenseNum?.addEventListener('input', () => setMouseSensitivity(settings.mouseSenseNum.value));

      // reset view
      settings.resetView?.addEventListener('click', () => resetView());

      // ---- Animation loop ----
      // Lag / freeze watchdog: if frames are consistently too slow, auto-stop and show suggestions.
      let _tickPrevMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      let _lagConsecutive = 0;
      const LAG_FRAME_MS = 450;     // frame gap threshold
      const LAG_SOLVE_MS = 180;     // solver time threshold inside tick
      const LAG_CONSEC_LIMIT = 3;   // sustained slow frames before stopping

      function buildLagSuggestions() {
        const category = String(ui.systemType?.value || '');
        const isPde = category === 'pde_linear' || category === 'pde_nonlinear' || runtime.systemType === 'pde';
        const lines = [];
        if (isPde) {
          lines.push('- Reduce **Nx/Ny** (grid size)');
          lines.push('- Reduce **Iters/frame**');
          lines.push('- Reduce **steps**');
        } else {
          lines.push('- Reduce **Points/frame**');
          lines.push('- Reduce **steps**');
        }
        lines.push('- Close other heavy tabs/apps; try refreshing the page');
        return lines.join('\n');
      }

      function tick() {
        const nowMs = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        const frameGap = nowMs - _tickPrevMs;
        _tickPrevMs = nowMs;

        // keyboard movement (game-like hold keys)
        const nowMoveMs = nowMs;
        const dtMoveSec = Math.min(0.05, Math.max(0, (nowMoveMs - _movePrevMs) / 1000));
        _movePrevMs = nowMoveMs;
        applyKeyboardMove(dtMoveSec);

        controls.update();

        const solveStart = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        streamSolveChunk();
        const solveEnd = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        const solveMs = solveEnd - solveStart;

        // Detect sustained lag; stop simulation to avoid "frozen" feeling.
        const tooSlow = (frameGap > LAG_FRAME_MS) || (solveMs > LAG_SOLVE_MS);
        if (runtime.running && tooSlow) _lagConsecutive++;
        else _lagConsecutive = 0;

        if (runtime.running && _lagConsecutive >= LAG_CONSEC_LIMIT) {
          setRunning(false);
          _lagConsecutive = 0;
          showError(
            `Performance warning (auto-stopped):\n` +
            `This device is struggling to keep up.\n` +
            `frameGap=${frameGap.toFixed(0)}ms, solve=${solveMs.toFixed(0)}ms\n\n` +
            `Suggestions:\n${buildLagSuggestions()}`
          );
        }

        if (ui.stats) {
          if (runtime.systemType === 'pde') {
            const p = runtime.pde;
            ui.stats.innerHTML =
              `mode=<code>pde</code> ` +
              `t=<code>${runtime.t.toFixed(4)}</code> ` +
              `step=<code>${runtime.stepIndex}</code>/<code>${runtime.maxSteps}</code> ` +
              `grid=<code>${p.nx}×${p.ny}</code> ` +
              `range=<code>[${Number(p.uMin).toExponential(2)}, ${Number(p.uMax).toExponential(2)}]</code> ` +
              `iters/frame=<code>${runtime.pointsPerFrame | 0}</code> ` +
              `solve=<code>${solveMs.toFixed(0)}ms</code>`;
          } else {
            const hInfo = isAdaptiveSolver(runtime.solver) ? ` h=<code>${runtime.h.toExponential(2)}</code> rej=<code>${runtime.rejectedSteps}</code>` : '';
            const modeInfo = ` mode=<code>${runtime.systemType}</code>` + (runtime.systemType === 'sde' ? ` sigma=<code>${Number(runtime.sigma).toExponential(2)}</code>` : '');
            ui.stats.innerHTML =
              `t=<code>${runtime.t.toFixed(4)}</code> ` +
              `step=<code>${runtime.stepIndex}</code> ` +
              `points=<code>${runtime.count}</code> ` +
              `skippedDerivs=<code>${runtime.skippedDerivs}</code>` +
              hInfo +
              modeInfo +
              ` solve=<code>${solveMs.toFixed(0)}ms</code>`;
          }
        }
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }

      function syncSystemTypeUI() {
        const category = String(ui.systemType?.value || 'ode_nonlinear');
        const st = categoryToEngineType(category) || 'ode';
        // Map: hide dt + ODE solver/adaptive; SDE: show dt + sigma, hide ODE solver/adaptive.
        // Param: show dt + hide ODE solver/adaptive/sigma.
        if (ui.dtBox) ui.dtBox.style.display = (st === 'map') ? 'none' : 'block';
        if (ui.odeRow) ui.odeRow.style.display = (st === 'ode') ? 'grid' : 'none';
        if (ui.sdeRow) ui.sdeRow.style.display = (st === 'sde') ? 'grid' : 'none';
        const lang = getCurrentLang();
        const d = I18N[lang] || I18N.vi;
        if (ui.stepsLabel) ui.stepsLabel.textContent = (st === 'map') ? d.iterations : (st === 'param') ? d.samples : d.steps;
        if (ui.dtLabel) ui.dtLabel.textContent = (st === 'sde') ? d.dtSde : (st === 'param') ? d.dtParam : d.dt;

        // PDE mode: show PDE inputs and hide ODE/vector-state controls
        const isPde = st === 'pde';
        if (ui.pdeSection) ui.pdeSection.style.display = isPde ? 'block' : 'none';
        if (ui.pdeBox) ui.pdeBox.style.display = isPde ? 'block' : 'none';
        const isPdeNonlinear = category === 'pde_nonlinear';
        if (ui.pdeNonlinearRow) ui.pdeNonlinearRow.style.display = (isPde && isPdeNonlinear) ? 'block' : 'none';
        const isDae = st === 'dae';
        if (ui.daeSection) ui.daeSection.style.display = isDae ? 'block' : 'none';
        if (ui.daeBox) ui.daeBox.style.display = isDae ? 'block' : 'none';

        const isHybrid = st === 'hybrid';
        if (ui.hybridSection) ui.hybridSection.style.display = isHybrid ? 'block' : 'none';
        if (ui.hybridBox) ui.hybridBox.style.display = isHybrid ? 'block' : 'none';

        const isAlg = category === 'algebraic';
        if (ui.algSection) ui.algSection.style.display = isAlg ? 'block' : 'none';
        if (ui.algBox) ui.algBox.style.display = isAlg ? 'block' : 'none';
        const algMode = String(ui.algMode?.value || 'parametric');
        const isAlgImplicit = isAlg && algMode === 'implicit';
        if (ui.algImplicitRow) ui.algImplicitRow.style.display = isAlgImplicit ? 'block' : 'none';
        updateRenderModeOptionLabels(getCurrentLang());
        if (ui.dimProjRow) ui.dimProjRow.style.display = isPde ? 'none' : 'grid';
        if (ui.eqModeRow) ui.eqModeRow.style.display = (isPde || isDae || isAlgImplicit) ? 'none' : 'block';
        const vecRow = ui.eqs ? ui.eqs.closest('.row') : null;
        if (ui.simpleEqs) ui.simpleEqs.style.display = (isPde || isDae || isAlgImplicit) ? 'none' : ui.simpleEqs.style.display;
        if (vecRow) vecRow.style.display = (isPde || isDae || isAlgImplicit) ? 'none' : vecRow.style.display;
        if (ui.initRow) ui.initRow.style.display = (isPde || isAlgImplicit) ? 'none' : 'grid';
        if (!isPde && !isDae && !isAlgImplicit) syncEqModeUI();
        applyRenderMode();

        // Streaming controls: transient doesn't apply to PDE; ppf becomes iterations/frame
        if (ui.transientBox) ui.transientBox.style.display = isPde ? 'none' : 'block';
        if (ui.ppfLabel) ui.ppfLabel.textContent = isPde ? ((lang === 'vi') ? 'Vòng lặp/frame' : 'Iters/frame') : d.ppf;

        // Solver-dependent visibility (ODE only)
        const isOde = st === 'ode';
        const adaptive = isOde && isAdaptiveSolver(String(ui.solver?.value || 'rk4'));
        if (ui.adaptiveRow1) ui.adaptiveRow1.style.display = adaptive ? 'grid' : 'none';
        if (ui.adaptiveRow2) ui.adaptiveRow2.style.display = adaptive ? 'grid' : 'none';

        // DAE: force Euler and hide adaptive rows (not supported)
        if (st === 'dae' && ui.solver) ui.solver.value = 'euler';
        // Hybrid: fixed-step only
        if (st === 'hybrid' && ui.solver) {
          const s = String(ui.solver.value || 'rk4');
          if (isAdaptiveSolver(s)) ui.solver.value = 'rk4';
        }
      }
      ui.systemType?.addEventListener('change', () => syncSystemTypeUI());
      ui.solver?.addEventListener('change', () => syncSystemTypeUI());
      ui.algMode?.addEventListener('change', () => {
        // In algebraic mode, switching parametric/implicit should auto-pick a matching preset.
        if (String(ui.systemType?.value || '') === 'algebraic') {
          populatePresetDropdown(ui.preset.value);
          const want = pickAlgebraicPresetForMode(getAlgMode());
          if (want && Array.from(ui.preset.options).some(o => o.value === want)) ui.preset.value = want;
          setPreset(ui.preset.value);
          updatePresetButtons();
        }
        syncSystemTypeUI();
      });
      syncSystemTypeUI();

      // ---- Resize ----
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // ---- Boot ----
      axes.visible = true;
      resetSimulation();
      requestAnimationFrame(tick);
    })();

    function removeThirdPartyDiv() {
      // Find div with the specific styling pattern
      const allDivs = document.querySelectorAll('div');
      for (const div of allDivs) {
        const style = div.getAttribute('style');
        if (style && 
            style.includes('position: fixed') && 
            style.includes('bottom: 0%') && 
            style.includes('left: 0%') && 
            style.includes('right: 0%') && 
            style.includes('width: 100%') && 
            style.includes('height: 55px') && 
            style.includes('z-index: 9999')) {
            div.remove();
            return true;
        }
      }
      return false;
    }

  </script>
</body>
</html>

