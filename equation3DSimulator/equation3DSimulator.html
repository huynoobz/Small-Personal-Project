<!doctype html>
<html version="2.6.0(paused)" by="huynoobz" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Equation 3D Simulator</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; color: #eaeaea; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #app { position: fixed; inset: 0; overflow: hidden; }
    #ui-panel {
      position: fixed;
      left: 12px;
      top: 12px;
      width: min(420px, calc(100vw - 24px));
      max-height: calc(100vh - 24px);
      overflow: auto;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      z-index: 5;
    }
    #ui-panel.is-hidden { display: none; }
    #ui-panel .header { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 10px; }
    #ui-panel .title { font-weight: 700; margin: 0; }
    #ui-panel .close-btn {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #eaeaea;
      cursor: pointer;
      font-size: 18px;
      line-height: 32px;
      padding: 0;
    }

    #open-controls {
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 6;
      display: none;
      padding: 9px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: #eaeaea;
      cursor: pointer;
      backdrop-filter: blur(8px);
    }
    #open-controls.is-visible { display: inline-block; }
    #ui-panel .row { margin-bottom: 10px; }
    #ui-panel .preset-controls { display: flex; gap: 8px; align-items: center; }
    #ui-panel .preset-controls select { flex: 1 1 auto; }
    #ui-panel .preset-mini-btn {
      width: auto;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #eaeaea;
      cursor: pointer;
      white-space: nowrap;
    }
    #ui-panel .preset-mini-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    #ui-panel label { display: block; font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    #ui-panel textarea, #ui-panel input, #ui-panel select {
      width: 100%;
      box-sizing: border-box;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.15);
      color: #eaeaea;
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }
    #ui-panel textarea { min-height: 64px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    #ui-panel .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    #ui-panel .buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    #ui-panel button {
      width: 100%;
      padding: 9px 10px;
      border-radius: 10px;
      background: rgba(255, 211, 107, 0.12);
      border: 1px solid rgba(255, 211, 107, 0.25);
      color: #ffd36b;
      cursor: pointer;
    }
    #ui-panel button.secondary {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #eaeaea;
    }
    #ui-panel .hint { font-size: 12px; opacity: 0.78; line-height: 1.35; }
    #error {
      position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
      padding: 10px 12px; border-radius: 10px;
      background: rgba(140, 20, 20, 0.85); border: 1px solid rgba(255,255,255,0.12);
      max-width: min(900px, calc(100vw - 24px));
      display: none; white-space: pre-wrap;
    }
    #notice {
      position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
      padding: 10px 12px; border-radius: 10px;
      background: rgba(20, 110, 40, 0.85); border: 1px solid rgba(255,255,255,0.12);
      max-width: min(900px, calc(100vw - 24px));
      display: none; white-space: pre-wrap;
    }
    /* Right settings panel (no dat.gui) */
    #settings-panel {
      position: fixed;
      right: 12px;
      top: 12px;
      width: 340px;
      max-width: calc(100vw - 24px);
      max-height: calc(100vh - 24px);
      overflow: hidden;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      backdrop-filter: blur(8px);
      z-index: 6;
      display: flex;
      flex-direction: column;
    }
    #settings-panel.is-hidden { display: none; }
    #settings-panel .settings-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 10px 6px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    #settings-panel .settings-title { font-weight: 700; opacity: 0.95; }
    /* Close button in header: wrap to content (no full-width) */
    #settings-close {
      width: auto;
      min-width: 34px;
      height: 34px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #eaeaea;
      cursor: pointer;
      font-size: 18px;
      line-height: 32px;
      padding: 0 10px;
    }
    #settings-body {
      overflow: auto;
      padding: 10px;
      display: grid;
      gap: 10px;
    }
    #settings-panel.is-collapsed #settings-body { display: none; }
    #settings-panel label { display: block; font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    #settings-panel input, #settings-panel select {
      width: 100%;
      box-sizing: border-box;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.15);
      color: #eaeaea;
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }
    #settings-panel .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    #settings-panel button {
      width: 100%;
      padding: 9px 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      color: #eaeaea;
      cursor: pointer;
    }
    /* Override for header button */
    #settings-panel .settings-header button { width: auto; padding: 0 10px; }
    /* Help button style */
    .help-btn {
      width: 28px;
      height: 28px;
      border-radius: 8px;
      background: rgba(100, 150, 255, 0.15);
      border: 1px solid rgba(100, 150, 255, 0.3);
      color: #64a0ff;
      cursor: pointer;
      font-size: 16px;
      line-height: 26px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
    }
    .help-btn:hover {
      background: rgba(100, 150, 255, 0.25);
      border-color: rgba(100, 150, 255, 0.4);
    }
    /* Help modal */
    #help-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }
    #help-modal.is-visible {
      display: flex;
    }
    #help-modal-content {
      background: rgba(20, 20, 25, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 16px;
      padding: 24px;
      max-width: min(600px, calc(100vw - 48px));
      max-height: calc(100vh - 48px);
      overflow: auto;
      position: relative;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
    #help-modal-close {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #eaeaea;
      cursor: pointer;
      font-size: 20px;
      line-height: 30px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #help-modal-close:hover {
      background: rgba(255, 255, 255, 0.15);
    }
    #help-modal-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 16px;
      color: #64a0ff;
    }
    #help-modal-body {
      font-size: 14px;
      line-height: 1.6;
      color: #eaeaea;
    }
    #help-modal-body h3 {
      font-size: 16px;
      font-weight: 600;
      margin-top: 20px;
      margin-bottom: 8px;
      color: #ffd36b;
    }
    #help-modal-body h3:first-child {
      margin-top: 0;
    }
    #help-modal-body p {
      margin-bottom: 12px;
    }
    #help-modal-body ul, #help-modal-body ol {
      margin-left: 20px;
      margin-bottom: 12px;
    }
    #help-modal-body li {
      margin-bottom: 6px;
    }
    #help-modal-body code {
      background: rgba(0, 0, 0, 0.4);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
    }
    #open-settings {
      position: fixed;
      right: 12px;
      top: 12px;
      z-index: 7;
      display: none;
      padding: 9px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      color: #eaeaea;
      cursor: pointer;
      backdrop-filter: blur(8px);
    }

    /* Controller sections */
    .section-title {
      margin: 10px 0 6px;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0.75;
    }
    .section-title.is-collapsible {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 6px 8px;
      border-radius: 10px;
    }
    .section-title.is-collapsible:hover {
      background: rgba(255,255,255,0.04);
    }
    .section-title.is-collapsible::after {
      content: "▾";
      opacity: 0.85;
      transform: rotate(0deg);
      transition: transform 120ms ease;
    }
    .section-title.is-collapsible.is-collapsed::after {
      transform: rotate(-90deg);
    }
    .section-title.is-collapsible.is-collapsed + .section-box {
      display: none !important;
    }
    /* Sync toggle switch styling */
    .sync-toggle-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      padding: 10px 14px;
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.2s ease;
      margin: 0;
    }
    .sync-toggle-label:hover {
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.15);
    }
    .sync-toggle-label #sync-instances-label {
      font-weight: 500;
      font-size: 13px;
      color: #eaeaea;
      user-select: none;
    }
    .sync-toggle-switch {
      position: relative;
      width: 48px;
      height: 26px;
      flex-shrink: 0;
    }
    .sync-toggle-switch input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }
    .sync-toggle-slider {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.2);
      border-radius: 13px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
    }
    .sync-toggle-slider:before {
      content: '';
      position: absolute;
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 3px;
      background: #eaeaea;
      border-radius: 50%;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    #sync-instances:checked + .sync-toggle-slider {
      background: rgba(255, 211, 107, 0.35);
      border: 1px solid rgba(255, 211, 107, 0.6);
    }
    #sync-instances:checked + .sync-toggle-slider:before {
      transform: translateX(22px);
      background: #ffd36b;
      box-shadow: 0 2px 8px rgba(255, 211, 107, 0.5);
    }
    .section-box {
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 10px;
    }

    /* FPS crosshair (shown only during pointer lock) */
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 8;
      display: none;
      pointer-events: none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 18px;
      line-height: 18px;
      color: rgba(255,255,255,0.9);
      text-shadow: 0 0 6px rgba(0,0,0,0.8);
      user-select: none;
    }

    /* Basic/Advanced toggle removed: always show all controls */
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="error"></div>
  <div id="notice"></div>
  <div id="crosshair" aria-hidden="true">+</div>
  <button id="open-settings" title="Open settings" style="display:none;">Settings</button>
  <div id="settings-panel">
    <div class="settings-header">
      <div id="settings-title" class="settings-title">Settings</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="settings-help" class="help-btn" title="Help: Camera and First Person controls">?</button>
        <button id="settings-close" title="Close settings" aria-label="Close settings">-</button>
      </div>
    </div>
    <div id="settings-body">
      <div>
        <label id="settings-lang-label">Language</label>
        <select id="settings-language">
          <option value="vi">Tiếng Việt</option>
          <option value="en">English</option>
        </select>
      </div>
      <div class="grid">
        <div>
          <label id="settings-axes-label">Show axes</label>
          <select id="settings-axes">
            <option value="1">On</option>
            <option value="0">Off</option>
          </select>
        </div>
        <div>
          <label id="settings-mode-label">Render mode</label>
          <select id="settings-mode">
            <option value="Line">Line</option>
            <option value="Points" selected>Points</option>
          </select>
        </div>
      </div>
      <div>
        <label id="settings-pointsize-label">Point size</label>
        <div class="grid" style="grid-template-columns: 1fr 110px;">
          <input id="settings-pointsize" type="range" min="0.001" max="0.08" step="0.001" value="0.01" />
          <input id="settings-pointsize-num" type="number" min="0.001" max="0.08" step="0.001" value="0.01" />
        </div>
      </div>
      <div>
        <label id="settings-camspeed-label">Camera speed</label>
        <div class="grid" style="grid-template-columns: 1fr 110px;">
          <input id="settings-camspeed" type="range" min="0.2" max="3.5" step="0.05" value="1.0" />
          <input id="settings-camspeed-num" type="number" min="0.2" max="3.5" step="0.05" value="1.0" />
        </div>
      </div>
      <div>
        <label id="settings-mousesense-label">Mouse sensitivity</label>
        <div class="grid" style="grid-template-columns: 1fr 110px;">
          <input id="settings-mousesense" type="range" min="0.2" max="3.0" step="0.05" value="1.0" />
          <input id="settings-mousesense-num" type="number" min="0.2" max="3.0" step="0.05" value="1.0" />
        </div>
      </div>
      <div class="grid">
        <button id="settings-resetview">Reset view</button>
      </div>
    </div>
  </div>
  <div id="ui-panel">
    <div class="header">
      <div id="panel-title" class="title">3D Simulator Controller</div>
      <div style="display:flex; gap:8px; align-items:center;">
        <button id="ui-help" class="help-btn" title="Help: Creating simulations">?</button>
        <button id="close-controls" class="close-btn" title="Close controls" aria-label="Close controls">×</button>
      </div>
    </div>

    <div id="section-model" class="section-title">Model</div>
    <div class="section-box">
      <div class="row">
        <label>System category</label>
        <select id="systemType">
          <option value="algebraic" selected>Algebraic System</option>
          <option value="ode_linear">ODE – Linear</option>
          <option value="ode_nonlinear">ODE – Nonlinear</option>
          <option value="map">Discrete Map</option>
          <option value="pde_linear">PDE – Linear</option>
          <option value="pde_nonlinear">PDE – Nonlinear</option>
          <option value="dae">DAE System</option>
          <option value="stochastic">Stochastic System (SDE)</option>
          <option value="hybrid">Hybrid System</option>
          <option value="hamilton">Hamilton/Lagrange System</option>
          <option value="optimization">Optimization / Gradient Flow</option>
          <option value="markov">Markov / Probabilistic System</option>
        </select>
      </div>

      <div class="row">
        <label>Preset</label>
        <div class="preset-controls">
          <select id="preset"></select>
          <button id="save-custom" class="preset-mini-btn" title="Save current Custom as a new preset">Save</button>
          <button id="delete-saved" class="preset-mini-btn" title="Delete selected saved preset" style="display:none;">Delete</button>
        </div>
      </div>
      <div class="row">
        <label>Search presets</label>
        <input id="presetSearch" placeholder="Type to filter presets…" />
      </div>

      <div class="grid row" id="dimproj-row">
    <div>
          <label>
            <span id="dim-label">Dimension N</span>
            <span style="float:right; font-weight:500; opacity:0.9;">
              <input id="dimAuto" type="checkbox" checked style="width:auto; vertical-align:middle; margin-right:6px;" />
              <span id="dim-auto-label">Auto</span>
            </span>
          </label>
          <input id="dim" value="3" title="When Auto is ON: Simple=3, Vector=number of non-empty equation lines." />
        </div>
        <div data-advanced="1" id="proj-row">
          <label>3D projection (x,y,z) indices (1-based)</label>
          <div class="grid" style="grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
            <input id="projX" value="1" title="X component index (1-based)" />
            <input id="projY" value="2" title="Y component index (1-based)" />
            <input id="projZ" value="3" title="Z component index (1-based)" />
          </div>
    </div>
  </div>

      <div class="row" id="eqmode-row">
        <label>Equation mode</label>
        <select id="eqMode">
          <option value="simple" selected>Simple (dx/dy/dz)</option>
          <option value="vector">Vector (N lines)</option>
        </select>
      </div>

      <div class="row">
        <label>Vector equations (one per line). If not empty, this overrides dx/dy/dz. Variables: x1..xN, t, and params.</label>
        <textarea id="eqs" placeholder="Example (ODE):&#10;x1' = x2&#10;x2' = -sin(x1) - 0.1*x2&#10;..."></textarea>
      </div>

      <div id="simple-eqs">
        <div class="row">
          <label>dx/dt = F(x,y,z,t,params)</label>
          <textarea id="dx"></textarea>
        </div>
        <div class="row">
          <label>dy/dt = G(x,y,z,t,params)</label>
          <textarea id="dy"></textarea>
        </div>
        <div class="row">
          <label>dz/dt = H(x,y,z,t,params)</label>
          <textarea id="dz"></textarea>
        </div>
      </div>

      <div class="row">
        <label>Parameters (mỗi dòng: name = value)</label>
        <textarea id="params"></textarea>
      </div>

      <div class="grid row" id="init-row">
        <div>
          <label>Initial (comma-separated, length N)</label>
          <input id="init" value="0.1, 0.1, 0.1" />
        </div>
      </div>

      <!-- PDE (Linear) -->
      <div id="pde-linear-section" class="section-title" style="display:none;">PDE – Linear</div>
      <div id="pde-linear-box" class="section-box" style="display:none;">
        <div class="row">
          <label>PDE type</label>
          <select id="pdeType">
            <option value="heat2d" selected>Heat / Diffusion (2D): u_t = α(uxx + uyy) + S</option>
          </select>
    </div>

        <div class="grid row">
          <div>
            <label>Nx</label>
            <input id="pdeNx" value="90" />
          </div>
          <div>
            <label>Ny</label>
            <input id="pdeNy" value="90" />
          </div>
        </div>

        <div class="grid row">
          <div>
            <label>x min</label>
            <input id="pdeXMin" value="-1" />
          </div>
          <div>
            <label>x max</label>
            <input id="pdeXMax" value="1" />
          </div>
        </div>
        <div class="grid row">
          <div>
            <label>y min</label>
            <input id="pdeYMin" value="-1" />
          </div>
          <div>
            <label>y max</label>
            <input id="pdeYMax" value="1" />
          </div>
        </div>

        <div class="grid row">
          <div>
            <label>α (diffusivity)</label>
            <input id="pdeAlpha" value="0.25" />
          </div>
          <div>
            <label>Boundary</label>
            <select id="pdeBC">
              <option value="dirichlet0" selected>Dirichlet: u=0</option>
              <option value="neumann0">Neumann: ∂u/∂n=0</option>
              <option value="periodic">Periodic</option>
            </select>
          </div>
        </div>

        <div class="grid row">
          <div>
            <label>Z scale</label>
            <input id="pdeZScale" value="1.0" />
          </div>
          <div class="hint" style="margin-top:22px;">
            Variables: <code>x</code>, <code>y</code>, <code>t</code>, params. Use <code>sin</code>, <code>exp</code>, etc.
          </div>
        </div>

      <div class="row">
          <label>Initial condition u(x,y,t=0)</label>
          <textarea id="pdeU0" placeholder="Example: exp(-20*(x^2+y^2))"></textarea>
        </div>
        <div class="row" data-advanced="1">
          <label>Source term S(x,y,t) (optional)</label>
          <textarea id="pdeSource" placeholder="Example: 0"></textarea>
        </div>
        <div class="row" id="pde-nonlinear-row" style="display:none;">
          <label>Nonlinear term N(u,x,y,t) (optional)</label>
          <textarea id="pdeNonlinear" placeholder="Examples: u*(1-u)  or  u - u^3"></textarea>
        </div>
      </div>

      <!-- DAE (index-1 semi-explicit): x' = f(x,y,t), 0 = g(x,y,t) -->
      <div id="dae-section" class="section-title" style="display:none;">DAE</div>
      <div id="dae-box" class="section-box" style="display:none;">
        <div class="grid row">
          <div>
            <label>DAE Index</label>
            <select id="daeIndex">
              <option value="1" selected>Index-1</option>
              <option value="2">Index-2</option>
              <option value="3">Index-3</option>
            </select>
          </div>
          <div class="hint" style="margin-top:22px;" id="daeIndexHint">
            <span id="daeIndexHintText">Index-1: g depends on algebraic variables y</span>
          </div>
        </div>
        <div class="grid row">
          <div>
            <label>Nx (differential vars)</label>
            <input id="daeNx" value="1" />
          </div>
          <div class="hint" style="margin-top:22px;">
            State is <code>[x1..xNx, y1..yNy]</code>. Use variables <code>x1..xN</code>, <code>t</code>, params.
          </div>
        </div>
        <div class="row">
          <label>DAE differential equations (Nx lines): x' = f(x,y,t)</label>
          <textarea id="daeF" placeholder="Example (Nx=1):&#10;x1' = -x1 + x2"></textarea>
        </div>
        <div class="row" id="daeGPosRow" style="display:none;">
          <label id="daeGPosLabel">Position constraint g(x) = 0 (Ny lines, for index-2/3)</label>
          <textarea id="daeGPos" placeholder="Example:&#10;0 = x1^2 + x2^2 + x3^2 - R^2"></textarea>
          <div class="hint">This is the original constraint. The velocity constraint (below) will be used for solving.</div>
        </div>
        <div class="row">
          <label id="daeGLabel">Constraint for solving (Ny lines): 0 = g(x,y,t) or dg/dt</label>
          <textarea id="daeG" placeholder="Example (index-1):&#10;0 = x2 - x1^2&#10;Example (index-2):&#10;0 = 2*x1*x4 + 2*x2*x5 + 2*x3*x6"></textarea>
          <div class="hint" id="daeGHint">For index-1: g(x,y,t). For index-2/3: velocity constraint dg/dt (differentiated form).</div>
        </div>
        <div class="grid row" data-advanced="1">
          <div>
            <label>Newton tol</label>
            <input id="daeTol" value="1e-8" />
          </div>
          <div>
            <label>Newton max iters</label>
            <input id="daeNewtonIters" value="12" />
          </div>
        </div>
      </div>

    </div>

      <!-- Hybrid rules (event + reset) -->
      <div id="hybrid-section" class="section-title" style="display:none;">Hybrid rules</div>
      <div id="hybrid-box" class="section-box" style="display:none;">
        <div class="row">
          <label>Event condition (trigger when this becomes true)</label>
          <input id="hybridEvent" placeholder="Example: x1 >= v_th" />
        </div>
        <div class="row">
          <label>Reset rules (each line: x1 = ..., x2 = ...)</label>
          <textarea id="hybridReset" placeholder="Example:&#10;x1 = v_reset&#10;x2 = spikeAmp"></textarea>
        </div>
        <div class="hint">
          When the event triggers, the solver finds the crossing time inside the current step, advances to it, then applies the reset instantly.
        </div>
      </div>

    <!-- Algebraic (implicit surface) -->
    <div id="alg-section" class="section-title" style="display:none;">Algebraic</div>
    <div id="alg-box" class="section-box" style="display:none;">
      <div class="row">
        <label>Algebraic mode</label>
        <select id="algMode">
          <option value="parametric" selected>Parametric curve (x(t),y(t),z(t))</option>
          <option value="implicit">Implicit surface (F(x,y,z)=iso)</option>
        </select>
      </div>
      <div id="alg-implicit-row" style="display:none;">
        <div class="row">
          <label>F(x,y,z)</label>
          <textarea id="algF" placeholder="Example (sphere): x^2+y^2+z^2-1"></textarea>
        </div>
        <div class="grid row">
          <div>
            <label>iso</label>
            <input id="algIso" value="0" />
          </div>
          <div>
            <label>resolution (N)</label>
            <input id="algRes" value="40" />
          </div>
        </div>
        <div class="grid row">
          <div>
            <label>x min</label>
            <input id="algXMin" value="-1.5" />
          </div>
          <div>
            <label>x max</label>
            <input id="algXMax" value="1.5" />
          </div>
        </div>
        <div class="grid row">
          <div>
            <label>y min</label>
            <input id="algYMin" value="-1.5" />
          </div>
          <div>
            <label>y max</label>
            <input id="algYMax" value="1.5" />
          </div>
        </div>
        <div class="grid row">
          <div>
            <label>z min</label>
            <input id="algZMin" value="-1.5" />
          </div>
          <div>
            <label>z max</label>
            <input id="algZMax" value="1.5" />
          </div>
        </div>
        <div class="hint">
          Use variables <code>x</code>, <code>y</code>, <code>z</code> and params (e.g. <code>a,b,c</code>, <code>n</code>). Example torus: <code>(x^2+y^2+z^2+R^2-r^2)^2-4*R^2*(x^2+y^2)</code>.
        </div>
      </div>
    </div>

    <div id="section-run" class="section-title">Run</div>
    <div class="section-box">
      <div class="grid row">
        <div id="dt-box">
          <label id="dt-label">dt</label>
          <input id="dt" value="0.005" />
        </div>
        <div>
          <label id="steps-label">steps</label>
          <input id="steps" value="200000" />
        </div>
      </div>

      <div class="grid row" id="ode-row">
        <div>
          <label>Solver</label>
          <select id="solver">
            <option value="rk4" selected>RK4 (fixed step)</option>
            <option value="euler">Euler (fixed step)</option>
            <option value="dp45">Dormand–Prince RK45 (adaptive)</option>
            <option value="rkf45">Fehlberg RKF45 (adaptive)</option>
            <option value="bs23">Bogacki–Shampine RK23 (adaptive)</option>
            <option value="ck45">Cash–Karp CK45 (adaptive)</option>
          </select>
        </div>
        <div class="hint" style="margin-top:22px;">
          ODE uses selected solver. Hybrid: fixed-step only. DAE: Euler only. Map ignores dt/solver. SDE uses Euler–Maruyama.
        </div>
      </div>

      <div class="grid row" id="sde-row" style="display:none;">
        <div>
          <label>sigma (SDE noise)</label>
          <input id="sigma" value="0.0" />
        </div>
        <div>
          <label>Note</label>
          <input value="x += f*dt + sigma*sqrt(dt)*N(0,1)" disabled />
        </div>
      </div>

      <div class="grid row" id="adaptive-row-1">
        <div>
          <label>absTol (adaptive)</label>
          <input id="absTol" value="1e-6" />
        </div>
        <div>
          <label>relTol (adaptive)</label>
          <input id="relTol" value="1e-3" />
        </div>
      </div>

      <div class="grid row" id="adaptive-row-2">
        <div>
          <label>dtMin (adaptive)</label>
          <input id="dtMin" value="1e-6" />
        </div>
        <div>
          <label>dtMax (adaptive)</label>
          <input id="dtMax" value="0.05" />
        </div>
      </div>

      <div class="grid row" data-advanced="1" id="stream-row">
        <div id="transient-box">
          <label>Transient (skip)</label>
          <input id="transient" value="2000" />
        </div>
        <div id="ppf-box">
          <label id="ppf-label">Points/frame (streaming)</label>
          <input id="ppf" value="1500" />
        </div>
      </div>
    </div>

    <div id="section-instances" class="section-title">Instances</div>
    <div class="section-box">
      <div id="instances-list" style="margin-bottom: 10px;"></div>
      <button id="add-instance" style="width: 100%;">+ Add Instance</button>
      <div class="row" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">
        <label class="sync-toggle-label" for="sync-instances">
          <span id="sync-instances-label">Sync all instances</span>
          <div class="sync-toggle-switch">
            <input type="checkbox" id="sync-instances" />
            <span class="sync-toggle-slider"></span>
          </div>
        </label>
      </div>
    </div>

    <div class="buttons row">
      <button id="start">Start</button>
      <button id="validate" class="secondary">Validate</button>
      <button id="pause" class="secondary">Pause</button>
      <button id="reset" class="secondary">Reset</button>
    </div>

    <div id="main-hint" class="hint">
      Hỗ trợ biến <b>x,y,z,t</b> và tham số tuỳ ý. Dùng hàm math.js như <code>sin</code>, <code>cos</code>, <code>pow</code>.<br/>
      Ví dụ Lorenz: <code>dx=sigma*(y-x)</code>, <code>dy=x*(rho-z)-y</code>, <code>dz=x*y-beta*z</code>.
    </div>
    <div id="stats" class="hint" style="margin-top:10px;"></div>
  </div>
  <button id="open-controls" title="Open controls">Open controls</button>

  <!-- Three.js (ES Modules via import map) -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <!-- math.js (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/mathjs@11.12.0/lib/browser/math.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    (() => {
      const errorEl = document.getElementById('error');
      const noticeEl = document.getElementById('notice');
      const getNowMs = () => (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      function showError(message) {
        if (noticeEl) { noticeEl.style.display = 'none'; noticeEl.textContent = ''; }
        if (!message) {
          errorEl.style.display = 'none';
          errorEl.textContent = '';
          return;
        }
        errorEl.style.display = 'block';
        errorEl.textContent = message;
      }
      function showNotice(message) {
        if (errorEl) { errorEl.style.display = 'none'; errorEl.textContent = ''; }
        if (!noticeEl) return;
        if (!message) { noticeEl.style.display = 'none'; noticeEl.textContent = ''; return; }
        noticeEl.style.display = 'block';
        noticeEl.textContent = message;
        window.setTimeout(() => {
          if (noticeEl.textContent === message) {
            noticeEl.style.display = 'none';
            noticeEl.textContent = '';
          }
        }, 2200);
      }

      const appEl = document.getElementById('app');

      // ---- Three.js base ----
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 2000);
      camera.position.set(2.8, 1.9, 3.2);

      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      appEl.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = false;
      controls.dampingFactor = 0.08;
      controls.zoomSpeed = 0.9;
      controls.rotateSpeed = 0.7;
      controls.panSpeed = 0.7;

      function isTypingInControl() {
        const el = document.activeElement;
        if (!el) return false;
        const tag = String(el.tagName || '').toLowerCase();
        if (tag === 'input' || tag === 'textarea' || tag === 'select') return true;
        // contenteditable
        if (el.isContentEditable) return true;
        return false;
      }

      // WASD movement (game-like). Shift = up, Ctrl = down.
      const _moveKeys = { left: false, right: false, forward: false, back: false, shiftUp: false, ctrlDown: false };
      let _movePrevMs = getNowMs();
      const _kbForward = new THREE.Vector3();
      const _kbRight = new THREE.Vector3();
      const _kbDelta = new THREE.Vector3();
      let cameraMoveSpeed = 1.0; // user setting
      let mouseLockEnabled = false;
      let mouseSensitivity = 0.2;
      let pointerLocked = false;
      let _unlockRequested = false;
      const crosshairEl = document.getElementById('crosshair');

      // True FPS look (yaw/pitch) while pointer is locked.
      let fpYaw = 0;
      let fpPitch = 0;
      let fpLookDist = 10;
      const _fpEuler = new THREE.Euler(0, 0, 0, 'YXZ');
      const _fpDir = new THREE.Vector3();
      const _orbitPrev = { enableDamping: !!controls.enableDamping, dampingFactor: Number(controls.dampingFactor) || 0.08 };
      // Web-FPS style mouse look: accumulate mouse deltas, apply once per frame (prevents snapping/jitter).
      const FP_MOUSE_SENS_BASE = 0.0022;
      const FP_MAX_EVENT_DELTA = 140;   // clamp per mousemove event
      const FP_IGNORE_DELTA = 900;      // ignore extreme spikes
      const FP_SMOOTH = 0.35;           // exponential smoothing factor (0..1)
      const FP_MAX_FRAME_DELTA = 85;    // cap total applied delta per frame (prevents big snaps on low FPS)
      const FP_DROP_ON_FRAME_GAP_MS = 140; // if frame gap is huge, drop queued mouse deltas to avoid jump
      let _fpPendingDX = 0;
      let _fpPendingDY = 0;
      let _fpSmDX = 0;
      let _fpSmDY = 0;

      function syncFpAnglesFromCamera() {
        _fpEuler.setFromQuaternion(camera.quaternion, 'YXZ');
        fpPitch = _fpEuler.x;
        fpYaw = _fpEuler.y;
      }
      function updateFpTarget() {
        camera.getWorldDirection(_fpDir).normalize();
        controls.target.copy(camera.position).addScaledVector(_fpDir, fpLookDist);
      }
      function applyFpRotation() {
        // Clamp pitch to avoid flipping
        const lim = Math.PI * 0.5 - 0.001;
        fpPitch = Math.max(-lim, Math.min(lim, fpPitch));
        _fpEuler.set(fpPitch, fpYaw, 0, 'YXZ');
        camera.quaternion.setFromEuler(_fpEuler);
      }
      function applyFpMouseLookFrame(frameGapMs) {
        if (!pointerLocked) return;
        // If the frame stuttered badly, don't apply a large accumulated mouse delta as a single snap.
        if (Number(frameGapMs) > FP_DROP_ON_FRAME_GAP_MS) {
          _fpPendingDX = 0;
          _fpPendingDY = 0;
          _fpSmDX = 0;
          _fpSmDY = 0;
          return;
        }
        const dx = _fpPendingDX;
        const dy = _fpPendingDY;
        _fpPendingDX = 0;
        _fpPendingDY = 0;
        if (dx === 0 && dy === 0) return;
        // Cap per-frame delta so low FPS cannot create a huge yaw/pitch jump.
        const cdx = Math.max(-FP_MAX_FRAME_DELTA, Math.min(FP_MAX_FRAME_DELTA, dx));
        const cdy = Math.max(-FP_MAX_FRAME_DELTA, Math.min(FP_MAX_FRAME_DELTA, dy));
        _fpSmDX = _fpSmDX * (1 - FP_SMOOTH) + cdx * FP_SMOOTH;
        _fpSmDY = _fpSmDY * (1 - FP_SMOOTH) + cdy * FP_SMOOTH;
        const sens = FP_MOUSE_SENS_BASE * mouseSensitivity;
        fpYaw += -_fpSmDX * sens;
        fpPitch += -_fpSmDY * sens;
        applyFpRotation();
        updateFpTarget();
      }

      function isPointerLocked() {
        return document.pointerLockElement === renderer.domElement;
      }

      function setPointerLockEnabled(on) {
        mouseLockEnabled = !!on;
        saveSettingsCache({ mouseLock: mouseLockEnabled ? 1 : 0 });
      }

      function clampMouseSensitivity(v) {
        return Math.max(0.2, Math.min(3.0, Number(v) || 1.0));
      }
      function setMouseSensitivity(v) {
        const s = clampMouseSensitivity(v);
        mouseSensitivity = s;
        if (settings.mouseSense) settings.mouseSense.value = String(s);
        if (settings.mouseSenseNum) settings.mouseSenseNum.value = String(s);
        saveSettingsCache({ mouseSensitivity: s });
      }

      function requestPointerLock() {
        if (!mouseLockEnabled) return;
        try { renderer.domElement.requestPointerLock?.(); } catch (_) {}
      }
      function exitPointerLock() {
        try { document.exitPointerLock?.(); } catch (_) {}
      }

      function onPointerLockChange() {
        pointerLocked = isPointerLocked();
        if (crosshairEl) crosshairEl.style.display = pointerLocked ? 'block' : 'none';

        if (pointerLocked) {
          // Enter FPS mode: disable orbit UI interactions, keep target in front of camera.
          _orbitPrev.enableDamping = !!controls.enableDamping;
          _orbitPrev.dampingFactor = Number(controls.dampingFactor) || _orbitPrev.dampingFactor;
          controls.enabled = false;
          // IMPORTANT: OrbitControls' damping/lookAt can fight FPS quaternion and cause "snap".
          controls.enableDamping = false;
          fpLookDist = camera.position.distanceTo(controls.target) || 10;
          _fpPendingDX = _fpPendingDY = 0;
          _fpSmDX = _fpSmDY = 0;
          syncFpAnglesFromCamera();
          applyFpRotation();
          updateFpTarget();
        } else {
          // Exit FPS mode: re-enable OrbitControls.
          controls.enabled = true;
          controls.enableDamping = _orbitPrev.enableDamping;
          controls.dampingFactor = _orbitPrev.dampingFactor;
          controls.update();

          // If lock was lost unexpectedly (e.g. Alt key triggering browser menu),
          // keep the feature enabled and tell user to re-lock.
          if (mouseLockEnabled && !_unlockRequested) {
            showNotice('Mouse lock lost. Press Alt to re-enter.');
          }
          _unlockRequested = false;
        }
      }
      document.addEventListener('pointerlockchange', onPointerLockChange);

      function onLockedMouseMove(e) {
        if (!pointerLocked) return;
        const rawDX = Number(e.movementX || 0);
        const rawDY = Number(e.movementY || 0);
        // Ignore extreme spikes (can happen on focus changes / OS quirks)
        if (Math.abs(rawDX) > FP_IGNORE_DELTA || Math.abs(rawDY) > FP_IGNORE_DELTA) return;
        const dx = Math.max(-FP_MAX_EVENT_DELTA, Math.min(FP_MAX_EVENT_DELTA, rawDX));
        const dy = Math.max(-FP_MAX_EVENT_DELTA, Math.min(FP_MAX_EVENT_DELTA, rawDY));
        _fpPendingDX += dx;
        _fpPendingDY += dy;
      }
      document.addEventListener('mousemove', onLockedMouseMove);

      function anyMoveKeyDown() {
        return _moveKeys.left || _moveKeys.right || _moveKeys.forward || _moveKeys.back || _moveKeys.shiftUp || _moveKeys.ctrlDown;
      }

      function applyKeyboardMove(dtSec) {
        if (isTypingInControl()) return;
        if (!anyMoveKeyDown()) return;
        const lr = (_moveKeys.right ? 1 : 0) + (_moveKeys.left ? -1 : 0);
        const fb = (_moveKeys.forward ? 1 : 0) + (_moveKeys.back ? -1 : 0);
        const ud = (_moveKeys.shiftUp ? 1 : 0) + (_moveKeys.ctrlDown ? -1 : 0);
        if (lr === 0 && fb === 0 && ud === 0) return;

        // Normalize diagonal so speed stays consistent
        const mag = Math.hypot(lr, fb, ud) || 1;
        const nlr = lr / mag;
        const nfb = fb / mag;
        const nud = ud / mag;

        const target = controls.target;
        const dist = pointerLocked ? fpLookDist : camera.position.distanceTo(target);
        const step = dist * 0.9 * dtSec * cameraMoveSpeed; // game-like feel (scaled)

        camera.getWorldDirection(_kbForward).normalize();
        _kbRight.crossVectors(_kbForward, camera.up).normalize();
        _kbDelta.set(0, 0, 0);
        _kbDelta.addScaledVector(_kbRight, nlr * step);
        _kbDelta.addScaledVector(_kbForward, nfb * step);
        _kbDelta.addScaledVector(camera.up, nud * step);
        camera.position.add(_kbDelta);
        if (pointerLocked) {
          // FPS: target stays in front of camera
          updateFpTarget();
        } else {
          // Orbit-style move: translate camera and target together
          target.add(_kbDelta);
        }
      }

      window.addEventListener('keydown', (e) => {
        // Allow normal cursor movement inside inputs/textareas/selects.
        if (isTypingInControl()) return;
        const k = e.key;
        const code = e.code;
        // Alt toggles pointer lock (and also prevents browser menu focus on Windows).
        if ((k === 'Alt' || code === 'AltLeft' || code === 'AltRight') && !e.repeat && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
          e.preventDefault();
          e.stopPropagation();
          if (pointerLocked) {
            _unlockRequested = true;
            exitPointerLock();
          } else {
            // Enable feature if user had it off, then lock
            if (!mouseLockEnabled) setPointerLockEnabled(true);
            requestPointerLock();
          }
          return;
        }
        if (k === 'Shift') { _moveKeys.shiftUp = true; e.preventDefault(); return; }
        if (k === 'Control') { _moveKeys.ctrlDown = true; e.preventDefault(); return; }
        if (code === 'KeyA') { _moveKeys.left = true; e.preventDefault(); }
        if (code === 'KeyD') { _moveKeys.right = true; e.preventDefault(); }
        if (code === 'KeyW') { _moveKeys.forward = true; e.preventDefault(); }
        if (code === 'KeyS') { _moveKeys.back = true; e.preventDefault(); }
      }, { passive: false });

      window.addEventListener('keyup', (e) => {
        const k = e.key;
        const code = e.code;
        if (k === 'Shift') _moveKeys.shiftUp = false;
        if (k === 'Control') _moveKeys.ctrlDown = false;
        if (code === 'KeyA') _moveKeys.left = false;
        if (code === 'KeyD') _moveKeys.right = false;
        if (code === 'KeyW') _moveKeys.forward = false;
        if (code === 'KeyS') _moveKeys.back = false;
      });

      window.addEventListener('blur', () => {
        _moveKeys.left = _moveKeys.right = _moveKeys.forward = _moveKeys.back = _moveKeys.shiftUp = _moveKeys.ctrlDown = false;
      });

      const ambient = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.55);
      dir.position.set(3, 4, 2);
      scene.add(dir);

      const axes = new THREE.AxesHelper(1.25);
      axes.visible = true;
      scene.add(axes);

      // =====================================================================
      // UI (inputs), Parser (math.js), Solver (Euler/RK4), Renderer (Three.js)
      // =====================================================================

      // ---- UI refs ----
      const ui = {
        panel: document.getElementById('ui-panel'),
        openControls: document.getElementById('open-controls'),
        closeControls: document.getElementById('close-controls'),
        panelTitle: document.getElementById('panel-title'),
        sectionModel: document.getElementById('section-model'),
        sectionRun: document.getElementById('section-run'),
        sectionInstances: document.getElementById('section-instances'),
        instancesList: document.getElementById('instances-list'),
        addInstance: document.getElementById('add-instance'),
        syncInstances: document.getElementById('sync-instances'),
        syncInstancesLabel: document.getElementById('sync-instances-label'),
        mainHint: document.getElementById('main-hint'),
        stats: document.getElementById('stats'),
        preset: document.getElementById('preset'),
        presetSearch: document.getElementById('presetSearch'),
        saveCustom: document.getElementById('save-custom'),
        deleteSaved: document.getElementById('delete-saved'),
        systemType: document.getElementById('systemType'),
        dtBox: document.getElementById('dt-box'),
        dtLabel: document.getElementById('dt-label'),
        stepsLabel: document.getElementById('steps-label'),
        odeRow: document.getElementById('ode-row'),
        adaptiveRow1: document.getElementById('adaptive-row-1'),
        adaptiveRow2: document.getElementById('adaptive-row-2'),
        sdeRow: document.getElementById('sde-row'),
        streamRow: document.getElementById('stream-row'),
        transientBox: document.getElementById('transient-box'),
        ppfLabel: document.getElementById('ppf-label'),
        sigma: document.getElementById('sigma'),
        dimProjRow: document.getElementById('dimproj-row'),
        dim: document.getElementById('dim'),
        dimAuto: document.getElementById('dimAuto'),
        dimLabel: document.getElementById('dim-label'),
        dimAutoLabel: document.getElementById('dim-auto-label'),
        projX: document.getElementById('projX'),
        projY: document.getElementById('projY'),
        projZ: document.getElementById('projZ'),
        eqModeRow: document.getElementById('eqmode-row'),
        eqMode: document.getElementById('eqMode'),
        eqs: document.getElementById('eqs'),
        simpleEqs: document.getElementById('simple-eqs'),
        dx: document.getElementById('dx'),
        dy: document.getElementById('dy'),
        dz: document.getElementById('dz'),
        params: document.getElementById('params'),
        initRow: document.getElementById('init-row'),
        init: document.getElementById('init'),
        dt: document.getElementById('dt'),
        absTol: document.getElementById('absTol'),
        relTol: document.getElementById('relTol'),
        dtMin: document.getElementById('dtMin'),
        dtMax: document.getElementById('dtMax'),
        steps: document.getElementById('steps'),
        transient: document.getElementById('transient'),
        solver: document.getElementById('solver'),
        ppf: document.getElementById('ppf'),
        start: document.getElementById('start'),
        validate: document.getElementById('validate'),
        pause: document.getElementById('pause'),
        reset: document.getElementById('reset'),
        exportBtn: null,
        // PDE (linear)
        pdeSection: document.getElementById('pde-linear-section'),
        pdeBox: document.getElementById('pde-linear-box'),
        pdeType: document.getElementById('pdeType'),
        pdeNx: document.getElementById('pdeNx'),
        pdeNy: document.getElementById('pdeNy'),
        pdeXMin: document.getElementById('pdeXMin'),
        pdeXMax: document.getElementById('pdeXMax'),
        pdeYMin: document.getElementById('pdeYMin'),
        pdeYMax: document.getElementById('pdeYMax'),
        pdeAlpha: document.getElementById('pdeAlpha'),
        pdeBC: document.getElementById('pdeBC'),
        pdeZScale: document.getElementById('pdeZScale'),
        pdeU0: document.getElementById('pdeU0'),
        pdeSource: document.getElementById('pdeSource'),
        pdeNonlinearRow: document.getElementById('pde-nonlinear-row'),
        pdeNonlinear: document.getElementById('pdeNonlinear'),
        // DAE
        daeSection: document.getElementById('dae-section'),
        daeBox: document.getElementById('dae-box'),
        daeIndex: document.getElementById('daeIndex'),
        daeNx: document.getElementById('daeNx'),
        daeF: document.getElementById('daeF'),
        daeGPos: document.getElementById('daeGPos'),
        daeG: document.getElementById('daeG'),
        daeTol: document.getElementById('daeTol'),
        daeNewtonIters: document.getElementById('daeNewtonIters'),
        daeIndexHint: document.getElementById('daeIndexHintText'),
        daeGLabel: document.getElementById('daeGLabel'),
        daeGPosLabel: document.getElementById('daeGPosLabel'),
        daeGPosRow: document.getElementById('daeGPosRow'),
        daeGHint: document.getElementById('daeGHint'),
        // Hybrid
        hybridSection: document.getElementById('hybrid-section'),
        hybridBox: document.getElementById('hybrid-box'),
        hybridEvent: document.getElementById('hybridEvent'),
        hybridReset: document.getElementById('hybridReset'),
        // Algebraic (implicit surface)
        algSection: document.getElementById('alg-section'),
        algBox: document.getElementById('alg-box'),
        algMode: document.getElementById('algMode'),
        algImplicitRow: document.getElementById('alg-implicit-row'),
        algF: document.getElementById('algF'),
        algIso: document.getElementById('algIso'),
        algRes: document.getElementById('algRes'),
        algXMin: document.getElementById('algXMin'),
        algXMax: document.getElementById('algXMax'),
        algYMin: document.getElementById('algYMin'),
        algYMax: document.getElementById('algYMax'),
        algZMin: document.getElementById('algZMin'),
        algZMax: document.getElementById('algZMax'),
      };

      // ---- Collapsible panels (Model / Algebraic / Wizards / Run) ----
      const UI_COLLAPSE_KEY = 'sim_ui_collapsed_panels_v1';
      function loadCollapseMap() {
        try {
          const raw = localStorage.getItem(UI_COLLAPSE_KEY);
          const v = safeJsonParse(raw, {});
          return (v && typeof v === 'object') ? v : {};
        } catch (_) {
          return {};
        }
      }
      function saveCollapseMap(next) {
        try { localStorage.setItem(UI_COLLAPSE_KEY, JSON.stringify(next || {})); } catch (_) {}
      }
      function setCollapsed(titleEl, collapsed) {
        if (!titleEl) return;
        const box = titleEl.nextElementSibling;
        if (!box || !box.classList || !box.classList.contains('section-box')) return;
        titleEl.classList.toggle('is-collapsed', !!collapsed);
        titleEl.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
      }
      function makePanelCollapsible(titleEl, key) {
        if (!titleEl) return;
        const box = titleEl.nextElementSibling;
        if (!box || !box.classList || !box.classList.contains('section-box')) return;
        titleEl.classList.add('is-collapsible');
        titleEl.setAttribute('role', 'button');
        titleEl.setAttribute('tabindex', '0');
        const map = loadCollapseMap();
        setCollapsed(titleEl, !!map[key]);
        const toggle = () => {
          const now = titleEl.classList.contains('is-collapsed');
          const nextCollapsed = !now;
          const m = loadCollapseMap();
          m[key] = nextCollapsed;
          saveCollapseMap(m);
          setCollapsed(titleEl, nextCollapsed);
        };
        titleEl.addEventListener('click', toggle);
        titleEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggle();
          }
        });
      }

      // ---- Right settings panel (no dat.gui) ----
      const settings = {
        panel: document.getElementById('settings-panel'),
        title: document.getElementById('settings-title'),
        close: document.getElementById('settings-close'),
        openBtn: document.getElementById('open-settings'),
        langLabel: document.getElementById('settings-lang-label'),
        langSelect: document.getElementById('settings-language'),
        axesLabel: document.getElementById('settings-axes-label'),
        axesSelect: document.getElementById('settings-axes'),
        modeLabel: document.getElementById('settings-mode-label'),
        modeSelect: document.getElementById('settings-mode'),
        pointSizeLabel: document.getElementById('settings-pointsize-label'),
        pointSize: document.getElementById('settings-pointsize'),
        pointSizeNum: document.getElementById('settings-pointsize-num'),
        camSpeedLabel: document.getElementById('settings-camspeed-label'),
        camSpeed: document.getElementById('settings-camspeed'),
        camSpeedNum: document.getElementById('settings-camspeed-num'),
        mouseSenseLabel: document.getElementById('settings-mousesense-label'),
        mouseSense: document.getElementById('settings-mousesense'),
        mouseSenseNum: document.getElementById('settings-mousesense-num'),
        resetView: document.getElementById('settings-resetview'),
      };

      // Setup collapsible panels now that elements exist
      makePanelCollapsible(ui.sectionModel, 'model');
      makePanelCollapsible(ui.algSection, 'algebraic');
      makePanelCollapsible(ui.sectionRun, 'run');
      if (ui.sectionInstances) makePanelCollapsible(ui.sectionInstances, 'instances');
      const SETTINGS_OPEN_KEY = 'sim_settings_open';
      const SETTINGS_CACHE_KEY = 'sim_settings_cache_v1';
      function loadSettingsCache() {
        try {
          const raw = localStorage.getItem(SETTINGS_CACHE_KEY);
          const v = safeJsonParse(raw, {});
          return (v && typeof v === 'object') ? v : {};
        } catch (_) {
          return {};
        }
      }
      function saveSettingsCache(patch) {
        const prev = loadSettingsCache();
        const next = { ...prev, ...patch };
        try { localStorage.setItem(SETTINGS_CACHE_KEY, JSON.stringify(next)); } catch (_) {}
      }
      function setSettingsOpen(open) {
        const isOpen = !!open;
        settings.panel?.classList.toggle('is-hidden', !isOpen);
        if (settings.openBtn) settings.openBtn.style.display = isOpen ? 'none' : 'inline-block';
        try { localStorage.setItem(SETTINGS_OPEN_KEY, isOpen ? '1' : '0'); } catch (_) {}
      }
      function getSettingsOpenDefault() {
        try {
          const v = localStorage.getItem(SETTINGS_OPEN_KEY);
          if (v === '0') return false;
          if (v === '1') return true;
        } catch (_) {}
        return true;
      }
      setSettingsOpen(getSettingsOpenDefault());
      settings.close?.addEventListener('click', () => setSettingsOpen(false));
      settings.openBtn?.addEventListener('click', () => setSettingsOpen(true));

      // ---- Help Modal ----
      const helpModal = document.getElementById('help-modal');
      const helpModalClose = document.getElementById('help-modal-close');
      const helpModalTitle = document.getElementById('help-modal-title');
      const helpModalBody = document.getElementById('help-modal-body');
      const uiHelpBtn = document.getElementById('ui-help');
      const settingsHelpBtn = document.getElementById('settings-help');

      function showHelp(title, content) {
        if (!helpModal || !helpModalTitle || !helpModalBody) return;
        helpModalTitle.textContent = title;
        helpModalBody.innerHTML = content;
        helpModal.classList.add('is-visible');
      }

      function hideHelp() {
        if (!helpModal) return;
        helpModal.classList.remove('is-visible');
      }

      helpModalClose?.addEventListener('click', hideHelp);
      helpModal?.addEventListener('click', (e) => {
        if (e.target === helpModal) hideHelp();
      });

      // Help content for UI panel (creating simulations)
      const uiHelpContent = {
        vi: `
          <h3>Tạo mô phỏng mới</h3>
          <p>Để tạo một mô phỏng 3D, làm theo các bước sau:</p>
          <ol>
            <li><strong>Chọn System category:</strong> Chọn loại hệ thống bạn muốn mô phỏng (ODE, PDE, Hybrid, v.v.)</li>
            <li><strong>Chọn Preset:</strong> Chọn một preset có sẵn hoặc tạo mới từ Custom</li>
            <li><strong>Nhập phương trình:</strong> Nhập các phương trình vi phân hoặc đại số vào các trường tương ứng</li>
            <li><strong>Thiết lập tham số:</strong> Định nghĩa các tham số (ví dụ: sigma=10, rho=28)</li>
            <li><strong>Thiết lập điều kiện ban đầu:</strong> Nhập giá trị khởi tạo (ví dụ: 0.1, 0.1, 0.1)</li>
            <li><strong>Cấu hình Run:</strong> Đặt dt (bước thời gian), steps (số bước), và các tham số khác</li>
            <li><strong>Nhấn Start:</strong> Bắt đầu mô phỏng</li>
          </ol>
          <h3>Lưu ý</h3>
          <ul>
            <li>Sử dụng biến <code>x, y, z, t</code> và các tham số tùy ý</li>
            <li>Dùng các hàm math.js như <code>sin</code>, <code>cos</code>, <code>pow</code>, <code>exp</code></li>
            <li>Ví dụ Lorenz: <code>dx=sigma*(y-x)</code>, <code>dy=x*(rho-z)-y</code>, <code>dz=x*y-beta*z</code></li>
            <li>Bạn có thể tạo nhiều instances và chạy đồng bộ với sync mode</li>
          </ul>
        `,
        en: `
          <h3>Creating a new simulation</h3>
          <p>To create a 3D simulation, follow these steps:</p>
          <ol>
            <li><strong>Select System category:</strong> Choose the type of system you want to simulate (ODE, PDE, Hybrid, etc.)</li>
            <li><strong>Choose Preset:</strong> Select an existing preset or create a new one from Custom</li>
            <li><strong>Enter equations:</strong> Input differential or algebraic equations into the corresponding fields</li>
            <li><strong>Set parameters:</strong> Define parameters (e.g., sigma=10, rho=28)</li>
            <li><strong>Set initial conditions:</strong> Enter initial values (e.g., 0.1, 0.1, 0.1)</li>
            <li><strong>Configure Run:</strong> Set dt (time step), steps (number of steps), and other parameters</li>
            <li><strong>Press Start:</strong> Begin the simulation</li>
          </ol>
          <h3>Notes</h3>
          <ul>
            <li>Use variables <code>x, y, z, t</code> and arbitrary parameters</li>
            <li>Use math.js functions like <code>sin</code>, <code>cos</code>, <code>pow</code>, <code>exp</code></li>
            <li>Lorenz example: <code>dx=sigma*(y-x)</code>, <code>dy=x*(rho-z)-y</code>, <code>dz=x*y-beta*z</code></li>
            <li>You can create multiple instances and run them in sync mode</li>
          </ul>
        `
      };

      // Help content for Settings panel (camera and FP controls)
      const settingsHelpContent = {
        vi: `
          <h3>Điều khiển Camera</h3>
          <p><strong>Chế độ Orbit (mặc định):</strong></p>
          <ul>
            <li><strong>WASD:</strong> Di chuyển tiến/lùi/trái/phải</li>
            <li><strong>Shift:</strong> Di chuyển lên</li>
            <li><strong>Ctrl:</strong> Di chuyển xuống</li>
            <li><strong>Kéo chuột trái:</strong> Xoay camera quanh đối tượng</li>
            <li><strong>Scroll chuột:</strong> Zoom in/out</li>
            <li><strong>Kéo chuột phải:</strong> Pan (di chuyển view)</li>
          </ul>
          <h3>Chế độ First Person (FP)</h3>
          <p>Kích hoạt bằng cách nhấn phím <code>Alt</code> hoặc chọn trong Settings</p>
          <ul>
            <li><strong>WASD:</strong> Di chuyển tiến/lùi/trái/phải</li>
            <li><strong>Shift:</strong> Di chuyển lên</li>
            <li><strong>Ctrl:</strong> Di chuyển xuống</li>
            <li><strong>Di chuyển chuột:</strong> Xoay camera</li>
            <li><strong>Scroll:</strong> Điều chỉnh tốc độ di chuyển</li>
            <li><strong>Nhấn Alt lại:</strong> Tắt chế độ FP</li>
          </ul>
          <h3>Cài đặt</h3>
          <ul>
            <li><strong>Camera speed:</strong> Tốc độ di chuyển trong chế độ FP</li>
            <li><strong>Mouse sensitivity:</strong> Độ nhạy khi xoay camera</li>
            <li><strong>Point size:</strong> Kích thước điểm hiển thị</li>
            <li><strong>Render mode:</strong> Chế độ hiển thị (Line hoặc Points)</li>
            <li><strong>Reset view:</strong> Đặt lại vị trí camera về mặc định</li>
          </ul>
        `,
        en: `
          <h3>Camera Controls</h3>
          <p><strong>Orbit mode (default):</strong></p>
          <ul>
            <li><strong>WASD:</strong> Move forward/backward/left/right</li>
            <li><strong>Shift:</strong> Move up</li>
            <li><strong>Ctrl:</strong> Move down</li>
            <li><strong>Left mouse drag:</strong> Rotate camera around object</li>
            <li><strong>Mouse scroll:</strong> Zoom in/out</li>
            <li><strong>Right mouse drag:</strong> Pan (move view)</li>
          </ul>
          <h3>First Person (FP) Mode</h3>
          <p>Activate by pressing <code>Alt</code> key or selecting in Settings</p>
          <ul>
            <li><strong>WASD:</strong> Move forward/backward/left/right</li>
            <li><strong>Shift:</strong> Move up</li>
            <li><strong>Ctrl:</strong> Move down</li>
            <li><strong>Mouse movement:</strong> Rotate camera</li>
            <li><strong>Scroll:</strong> Adjust movement speed</li>
            <li><strong>Press Alt again:</strong> Exit FP mode</li>
          </ul>
          <h3>Settings</h3>
          <ul>
            <li><strong>Camera speed:</strong> Movement speed in FP mode</li>
            <li><strong>Mouse sensitivity:</strong> Sensitivity when rotating camera</li>
            <li><strong>Point size:</strong> Display point size</li>
            <li><strong>Render mode:</strong> Display mode (Line or Points)</li>
            <li><strong>Reset view:</strong> Reset camera position to default</li>
          </ul>
        `
      };

      // Get current language
      function getCurrentHelpLang() {
        try {
          const lang = localStorage.getItem('sim_ui_lang') || 'vi';
          return lang === 'en' ? 'en' : 'vi';
        } catch (_) {
          return 'vi';
        }
      }

      uiHelpBtn?.addEventListener('click', () => {
        const lang = getCurrentHelpLang();
        const title = lang === 'en' ? 'Help: Creating Simulations' : 'Hướng dẫn: Tạo mô phỏng';
        showHelp(title, uiHelpContent[lang]);
      });

      settingsHelpBtn?.addEventListener('click', () => {
        const lang = getCurrentHelpLang();
        const title = lang === 'en' ? 'Help: Camera and First Person Controls' : 'Hướng dẫn: Điều khiển Camera và First Person';
        showHelp(title, settingsHelpContent[lang]);
      });

      // ---- Language (i18n) ----
      const UI_LANG_KEY = 'sim_ui_lang';
      const I18N = {
        vi: {
          panelTitle: 'Bảng điều khiển mô phỏng 3D',
          openControls: 'Mở điều khiển',
          advanced: 'Nâng cao',
          basic: 'Cơ bản',
          sectionModel: 'Mô hình',
          // sectionWizards removed
          sectionRun: 'Chạy mô phỏng',
          sectionInstances: 'Các mô phỏng',
          addInstance: '+ Thêm mô phỏng',
          removeInstance: 'Xóa',
          toggleInstance: 'Ẩn/Hiện',
          syncInstances: 'Đồng bộ tất cả instances',
          systemCategory: 'Phân loại hệ',
          preset: 'Preset',
          presetSearch: 'Tìm preset',
          eqMode: 'Chế độ nhập',
          eqModeSimple: 'Đơn giản (dx/dy/dz)',
          eqModeVector: 'Vector (N dòng)',
          vectorEqs: 'Phương trình vector (mỗi dòng 1 phương trình). Biến: x1..xN, t, và params.',
          dx: 'dx/dt = F(x,y,z,t,params)',
          dy: 'dy/dt = G(x,y,z,t,params)',
          dz: 'dz/dt = H(x,y,z,t,params)',
          params: 'Tham số (mỗi dòng: name = value)',
          init: 'Điều kiện đầu (cách nhau bởi dấu phẩy, độ dài N)',
          dt: 'dt',
          dtSde: 'dt (SDE)',
          dtParam: 'Bước t',
          steps: 'Số bước',
          iterations: 'Số vòng lặp',
          samples: 'Số mẫu',
          solverOde: 'Solver (chỉ ODE)',
          sigma: 'sigma (nhiễu SDE)',
          note: 'Ghi chú',
          absTol: 'absTol (adaptive)',
          relTol: 'relTol (adaptive)',
          dtMin: 'dtMin (adaptive)',
          dtMax: 'dtMax (adaptive)',
          transient: 'Bỏ qua (transient)',
          ppf: 'Điểm/frame (streaming)',
          start: 'Chạy',
          validate: 'Kiểm tra',
          pause: 'Tạm dừng',
          resume: 'Tiếp tục',
          reset: 'Đặt lại',
          export: 'Xuất PNG',
          hint: 'Hỗ trợ biến x,y,z,t và tham số tuỳ ý. Dùng hàm math.js như sin, cos, pow. Ví dụ Lorenz: dx=sigma*(y-x), dy=x*(rho-z)-y, dz=x*y-beta*z.',
          langName: 'Ngôn ngữ',
          systemOptions: {
            algebraic: 'Hệ đại số (Algebraic)',
            ode_linear: 'ODE – Tuyến tính',
            ode_nonlinear: 'ODE – Phi tuyến',
            map: 'Hệ sai phân (Discrete Map)',
            pde_linear: 'PDE – Tuyến tính',
            pde_nonlinear: 'PDE – Phi tuyến',
            dae: 'DAE',
            stochastic: 'Hệ ngẫu nhiên (SDE)',
            hybrid: 'Hybrid',
            hamilton: 'Hamilton/Lagrange',
            optimization: 'Tối ưu / Gradient Flow',
            markov: 'Markov / Xác suất',
          },
          // wizard strings removed
        },
        en: {
          panelTitle: '3D Simulator Controller',
          openControls: 'Open controls',
          advanced: 'Advanced',
          basic: 'Basic',
          sectionModel: 'Model',
          // sectionWizards removed
          sectionRun: 'Run',
          sectionInstances: 'Instances',
          addInstance: '+ Add Instance',
          removeInstance: 'Remove',
          toggleInstance: 'Hide/Show',
          syncInstances: 'Sync all instances',
          systemCategory: 'System category',
          preset: 'Preset',
          presetSearch: 'Search presets',
          eqMode: 'Equation mode',
          eqModeSimple: 'Simple (dx/dy/dz)',
          eqModeVector: 'Vector (N lines)',
          vectorEqs: 'Vector equations (one per line). Variables: x1..xN, t, and params.',
          dx: 'dx/dt = F(x,y,z,t,params)',
          dy: 'dy/dt = G(x,y,z,t,params)',
          dz: 'dz/dt = H(x,y,z,t,params)',
          params: 'Parameters (one per line: name = value)',
          init: 'Initial (comma-separated, length N)',
          dt: 'dt',
          dtSde: 'dt (SDE)',
          dtParam: 't step',
          steps: 'steps',
          iterations: 'iterations',
          samples: 'samples',
          solverOde: 'Solver (ODE only)',
          sigma: 'sigma (SDE noise)',
          note: 'Note',
          absTol: 'absTol (adaptive)',
          relTol: 'relTol (adaptive)',
          dtMin: 'dtMin (adaptive)',
          dtMax: 'dtMax (adaptive)',
          transient: 'Transient (skip)',
          ppf: 'Points/frame (streaming)',
          start: 'Start',
          validate: 'Validate',
          pause: 'Pause',
          resume: 'Resume',
          reset: 'Reset',
          export: 'Export PNG',
          hint: 'Supports variables x,y,z,t and arbitrary parameters. Use math.js functions like sin, cos, pow. Lorenz example: dx=sigma*(y-x), dy=x*(rho-z)-y, dz=x*y-beta*z.',
          langName: 'Language',
          systemOptions: {
            algebraic: 'Algebraic System',
            ode_linear: 'ODE – Linear',
            ode_nonlinear: 'ODE – Nonlinear',
            map: 'Discrete Map',
            pde_linear: 'PDE – Linear',
            pde_nonlinear: 'PDE – Nonlinear',
            dae: 'DAE System',
            stochastic: 'Stochastic System (SDE)',
            hybrid: 'Hybrid System',
            hamilton: 'Hamilton/Lagrange System',
            optimization: 'Optimization / Gradient Flow',
            markov: 'Markov / Probabilistic System',
          },
          // wizard strings removed
        }
      };

      function getCurrentLang() {
        try {
          const v = localStorage.getItem(UI_LANG_KEY);
          if (v === 'en' || v === 'vi') return v;
        } catch (_) {}
        return 'vi';
      }
      function setCurrentLang(lang) {
        const l = (lang === 'en' || lang === 'vi') ? lang : 'vi';
        try { localStorage.setItem(UI_LANG_KEY, l); } catch (_) {}
        applyLanguage(l);
      }
      function setLabelForControl(controlEl, text) {
        if (!controlEl) return;
        // Prefer the label within the immediate field container (<div><label>..</label><input/></div>)
        const parent = controlEl.parentElement;
        const directLabel = parent ? parent.querySelector('label') : null;
        if (directLabel) {
          directLabel.textContent = text;
          return;
        }
        // Fallback: previous sibling label
        const prev = controlEl.previousElementSibling;
        if (prev && prev.tagName === 'LABEL') {
          prev.textContent = text;
          return;
        }
        // Last resort: first label in row
        const row = controlEl.closest('.row');
        const label = row ? row.querySelector('label') : null;
        if (label) label.textContent = text;
      }
      // Boot-safe running flag (avoid touching runtime before it's initialized)
      let uiIsRunning = false;
      // Some functions are hoisted and can be called during early preset setup
      // before render objects/runtime are initialized. Use this guard to avoid TDZ.
      var renderObjectsReady = false;

      function updateRenderModeOptionLabels(lang) {
        if (!settings.modeSelect) return;
        const l = (lang === 'en' || lang === 'vi') ? lang : getCurrentLang();
        const optLine = settings.modeSelect.querySelector('option[value="Line"]');
        const optPts = settings.modeSelect.querySelector('option[value="Points"]');
        if (optPts) optPts.textContent = (l === 'vi') ? 'Điểm' : 'Points';

        // In Algebraic+Implicit context, "Line" actually means Surface (mesh).
        const isAlgImplicit = String(ui.systemType?.value || '') === 'algebraic'
          && String(ui.algMode?.value || 'parametric') === 'implicit';
        if (optLine) {
          optLine.textContent = isAlgImplicit
            ? ((l === 'vi') ? 'Bề mặt' : 'Surface')
            : ((l === 'vi') ? 'Quỹ đạo' : 'Path');
        }
      }

      function applyLanguage(lang) {
        const d = I18N[lang] || I18N.vi;
        if (ui.panelTitle) ui.panelTitle.textContent = d.panelTitle;
        if (ui.openControls) ui.openControls.textContent = d.openControls;
        if (ui.sectionModel) ui.sectionModel.textContent = d.sectionModel;
        if (ui.sectionRun) ui.sectionRun.textContent = d.sectionRun;
        if (ui.sectionInstances) ui.sectionInstances.textContent = d.sectionInstances;
        if (ui.addInstance) ui.addInstance.textContent = d.addInstance;
        if (ui.syncInstancesLabel) ui.syncInstancesLabel.textContent = d.syncInstances;

        // Basic/Advanced removed

        setLabelForControl(ui.systemType, d.systemCategory);
        setLabelForControl(ui.preset, d.preset);
        setLabelForControl(ui.presetSearch, d.presetSearch);
        setLabelForControl(ui.eqMode, d.eqMode);
        if (ui.dimLabel) ui.dimLabel.textContent = (lang === 'vi') ? 'Số chiều N' : 'Dimension N';
        if (ui.dimAutoLabel) ui.dimAutoLabel.textContent = (lang === 'vi') ? 'Tự động' : 'Auto';

        // eqMode option labels
        if (ui.eqMode) {
          const optSimple = ui.eqMode.querySelector('option[value="simple"]');
          const optVector = ui.eqMode.querySelector('option[value="vector"]');
          if (optSimple) optSimple.textContent = d.eqModeSimple;
          if (optVector) optVector.textContent = d.eqModeVector;
        }

        // system category option labels
        if (ui.systemType) {
          for (const opt of ui.systemType.querySelectorAll('option')) {
            const v = opt.value;
            if (d.systemOptions && d.systemOptions[v]) opt.textContent = d.systemOptions[v];
          }
        }

        // Vector eq label
        if (ui.eqs) {
          const row = ui.eqs.closest('.row');
          const label = row ? row.querySelector('label') : null;
          if (label) label.textContent = d.vectorEqs;
        }
        setLabelForControl(ui.dx, d.dx);
        setLabelForControl(ui.dy, d.dy);
        setLabelForControl(ui.dz, d.dz);
        setLabelForControl(ui.params, d.params);
        setLabelForControl(ui.init, d.init);

        // PDE (linear) labels (minimal)
        if (ui.pdeSection) {
          const cat = String(ui.systemType?.value || '');
          const isNl = cat === 'pde_nonlinear';
          ui.pdeSection.textContent = isNl
            ? ((lang === 'vi') ? 'PDE – Phi tuyến' : 'PDE – Nonlinear')
            : ((lang === 'vi') ? 'PDE – Tuyến tính' : 'PDE – Linear');
        }
        if (ui.pdeType) setLabelForControl(ui.pdeType, (lang === 'vi') ? 'Loại PDE' : 'PDE type');
        if (ui.pdeNx) setLabelForControl(ui.pdeNx, 'Nx');
        if (ui.pdeNy) setLabelForControl(ui.pdeNy, 'Ny');
        if (ui.pdeXMin) setLabelForControl(ui.pdeXMin, 'x min');
        if (ui.pdeXMax) setLabelForControl(ui.pdeXMax, 'x max');
        if (ui.pdeYMin) setLabelForControl(ui.pdeYMin, 'y min');
        if (ui.pdeYMax) setLabelForControl(ui.pdeYMax, 'y max');
        if (ui.pdeAlpha) setLabelForControl(ui.pdeAlpha, (lang === 'vi') ? 'α (khuếch tán)' : 'α (diffusivity)');
        if (ui.pdeBC) setLabelForControl(ui.pdeBC, (lang === 'vi') ? 'Điều kiện biên' : 'Boundary');
        if (ui.pdeZScale) setLabelForControl(ui.pdeZScale, (lang === 'vi') ? 'Tỉ lệ Z' : 'Z scale');
        if (ui.pdeU0) setLabelForControl(ui.pdeU0, (lang === 'vi') ? 'Điều kiện đầu u(x,y,t=0)' : 'Initial condition u(x,y,t=0)');
        if (ui.pdeSource) setLabelForControl(ui.pdeSource, (lang === 'vi') ? 'Nguồn S(x,y,t) (tuỳ chọn)' : 'Source term S(x,y,t) (optional)');
        if (ui.pdeNonlinear) setLabelForControl(ui.pdeNonlinear, (lang === 'vi') ? 'Hạng phi tuyến N(u,x,y,t) (tuỳ chọn)' : 'Nonlinear term N(u,x,y,t) (optional)');

        // DAE labels (minimal)
        if (ui.daeSection) ui.daeSection.textContent = 'DAE';
        if (ui.daeIndex) setLabelForControl(ui.daeIndex, (lang === 'vi') ? 'Chỉ số DAE' : 'DAE Index');
        updateDaeIndexHint();
        if (ui.daeNx) setLabelForControl(ui.daeNx, (lang === 'vi') ? 'Nx (biến vi phân)' : 'Nx (differential vars)');
        if (ui.daeF) setLabelForControl(ui.daeF, (lang === 'vi') ? "Phương trình vi phân (Nx dòng): x' = f" : "DAE differential eqs (Nx lines): x' = f");
        if (ui.daeG) updateDaeGLabel();
        if (ui.daeTol) setLabelForControl(ui.daeTol, (lang === 'vi') ? 'Newton tol' : 'Newton tol');
        if (ui.daeNewtonIters) setLabelForControl(ui.daeNewtonIters, (lang === 'vi') ? 'Newton tối đa' : 'Newton max iters');

        // Algebraic (implicit) labels (minimal)
        if (ui.algSection) ui.algSection.textContent = (lang === 'vi') ? 'Hệ đại số' : 'Algebraic';
        if (ui.algMode) setLabelForControl(ui.algMode, (lang === 'vi') ? 'Chế độ đại số' : 'Algebraic mode');
        if (ui.algF) setLabelForControl(ui.algF, 'F(x,y,z)');
        if (ui.algIso) setLabelForControl(ui.algIso, 'iso');
        if (ui.algRes) setLabelForControl(ui.algRes, (lang === 'vi') ? 'độ phân giải (N)' : 'resolution (N)');
        if (ui.algXMin) setLabelForControl(ui.algXMin, 'x min');
        if (ui.algXMax) setLabelForControl(ui.algXMax, 'x max');
        if (ui.algYMin) setLabelForControl(ui.algYMin, 'y min');
        if (ui.algYMax) setLabelForControl(ui.algYMax, 'y max');
        if (ui.algZMin) setLabelForControl(ui.algZMin, 'z min');
        if (ui.algZMax) setLabelForControl(ui.algZMax, 'z max');

        // Run labels
        const category = String(ui.systemType?.value || 'ode_nonlinear');
        const engine = categoryToEngineType(category) || 'ode';
        if (ui.dtLabel) ui.dtLabel.textContent = (engine === 'sde') ? d.dtSde : (engine === 'param') ? d.dtParam : d.dt;
        if (ui.stepsLabel) ui.stepsLabel.textContent = (engine === 'map') ? d.iterations : (engine === 'param') ? d.samples : d.steps;

        // ODE/SDE/adaptive labels
        if (ui.solver) {
          const odeLabel = ui.solver.closest('.grid')?.querySelector('label');
          if (odeLabel) odeLabel.textContent = d.solverOde;
        }
        if (ui.sigma) setLabelForControl(ui.sigma, d.sigma);
        if (ui.sdeRow) {
          const noteLabel = ui.sdeRow.querySelectorAll('label')[1];
          if (noteLabel) noteLabel.textContent = d.note;
        }
        if (ui.absTol) setLabelForControl(ui.absTol, d.absTol);
        if (ui.relTol) setLabelForControl(ui.relTol, d.relTol);
        if (ui.dtMin) setLabelForControl(ui.dtMin, d.dtMin);
        if (ui.dtMax) setLabelForControl(ui.dtMax, d.dtMax);
        if (ui.transient) setLabelForControl(ui.transient, d.transient);
        if (ui.ppf) setLabelForControl(ui.ppf, d.ppf);

        // Buttons
        if (ui.start) ui.start.textContent = d.start;
        if (ui.validate) ui.validate.textContent = d.validate;
        if (ui.pause) ui.pause.textContent = uiIsRunning ? d.pause : d.resume;
        if (ui.reset) ui.reset.textContent = d.reset;
        if (ui.exportBtn) ui.exportBtn.textContent = d.export;

        // Wizard labels/buttons (best-effort)
        if (ui.mainHint) ui.mainHint.textContent = d.hint;

        // Settings panel labels (right)
        if (settings.title) settings.title.textContent = (lang === 'vi') ? 'Cài đặt' : 'Settings';
        if (settings.langLabel) settings.langLabel.textContent = d.langName;
        if (settings.axesLabel) settings.axesLabel.textContent = (lang === 'vi') ? 'Hiện trục' : 'Show axes';
        if (settings.modeLabel) settings.modeLabel.textContent = (lang === 'vi') ? 'Chế độ vẽ' : 'Render mode';
        updateRenderModeOptionLabels(lang);
        if (settings.pointSizeLabel) settings.pointSizeLabel.textContent = (lang === 'vi') ? 'Kích thước điểm' : 'Point size';
        if (settings.camSpeedLabel) settings.camSpeedLabel.textContent = (lang === 'vi') ? 'Tốc độ camera' : 'Camera speed';
        if (settings.mouseSenseLabel) settings.mouseSenseLabel.textContent = (lang === 'vi') ? 'Độ nhạy chuột' : 'Mouse sensitivity';
        if (settings.resetView) settings.resetView.textContent = (lang === 'vi') ? 'Reset góc nhìn' : 'Reset view';
      }

      // ---- Basic/Advanced removed (always show all controls) ----
      applyLanguage(getCurrentLang());

      function syncEqModeUI() {
        const mode = String(ui.eqMode?.value || 'simple');
        const showVector = mode === 'vector';
        const eqRow = ui.eqs ? ui.eqs.closest('.row') : null;
        if (eqRow) eqRow.style.display = showVector ? 'block' : 'none';
        if (ui.simpleEqs) ui.simpleEqs.style.display = showVector ? 'none' : 'block';
      }
      ui.eqMode?.addEventListener('change', () => syncEqModeUI());
      syncEqModeUI();

      // ---- Dimension N (auto) ----
      let projAuto = true;
      let lastAutoDim = null;
      function setProjDefaultsForN(n) {
        if (!ui.projX || !ui.projY || !ui.projZ) return;
        ui.projX.value = '1';
        ui.projY.value = String(Math.min(2, n));
        ui.projZ.value = String(Math.min(3, n));
      }

      function countNonEmptyVectorLines(text) {
        const lines = String(text || '').split(/\r?\n/);
        let count = 0;
        for (let i = 0; i < lines.length; i++) {
          let s = lines[i].trim();
          if (!s) continue;
          s = s.replace(/(#|\/\/).*$/, '').trim();
          if (!s) continue;
          if (s.includes('=')) {
            const rhs = s.slice(s.indexOf('=') + 1).trim();
            if (!rhs) continue;
          }
          count++;
        }
        return count;
      }

      function syncDimAuto() {
        const mode = String(ui.eqMode?.value || 'simple');
        const n = (mode === 'vector')
          ? Math.max(1, countNonEmptyVectorLines(ui.eqs?.value || ''))
          : 3;
        if (ui.dimAuto?.checked) {
          if (ui.dim) ui.dim.value = String(n);
        }

        // Auto projection: if user hasn't overridden, keep a sensible default for current dim.
        const nEffective = Math.max(1, Math.floor(Number(ui.dim?.value || n)) || n);
        if (projAuto) {
          setProjDefaultsForN(nEffective);
        } else {
          // If current projection is out of range (e.g., moved from 3D->2D), force reset.
          const px = Math.floor(Number(ui.projX?.value || 1));
          const py = Math.floor(Number(ui.projY?.value || 2));
          const pz = Math.floor(Number(ui.projZ?.value || 3));
          if (![px, py, pz].every(v => Number.isFinite(v) && v >= 1 && v <= nEffective)) {
            projAuto = true;
            setProjDefaultsForN(nEffective);
          }
        }

        lastAutoDim = nEffective;
      }

      ui.eqMode?.addEventListener('change', () => syncDimAuto());
      ui.eqs?.addEventListener('input', () => syncDimAuto());
      ui.dimAuto?.addEventListener('change', () => syncDimAuto());
      ui.dim?.addEventListener('input', () => {
        // If user types N manually, disable auto
        if (ui.dimAuto) ui.dimAuto.checked = false;
        syncDimAuto();
      });
      ui.projX?.addEventListener('input', () => { projAuto = false; });
      ui.projY?.addEventListener('input', () => { projAuto = false; });
      ui.projZ?.addEventListener('input', () => { projAuto = false; });
      syncDimAuto();

      // ---- Run settings cache (Transient + Points/frame) ----
      const RUN_CACHE_KEY = 'sim_run_cache_v1';
      function loadRunCache() {
        try {
          const raw = localStorage.getItem(RUN_CACHE_KEY);
          const v = safeJsonParse(raw, {});
          return (v && typeof v === 'object') ? v : {};
        } catch (_) {
          return {};
        }
      }
      function saveRunCache(patch) {
        const prev = loadRunCache();
        const next = { ...prev, ...patch };
        try { localStorage.setItem(RUN_CACHE_KEY, JSON.stringify(next)); } catch (_) {}
      }
      // Apply cached values on boot (and keep across preset changes)
      (() => {
        const cache = loadRunCache();
        if (ui.transient && cache.transient != null) ui.transient.value = String(cache.transient);
        if (ui.ppf && cache.ppf != null) ui.ppf.value = String(cache.ppf);
      })();
      ui.transient?.addEventListener('input', () => saveRunCache({ transient: ui.transient.value }));
      ui.ppf?.addEventListener('input', () => saveRunCache({ ppf: ui.ppf.value }));

      // ---- UI panel open/close ----
      const UI_PANEL_KEY = 'ode_ui_panel_open';
      function setPanelOpen(isOpen) {
        const open = !!isOpen;
        ui.panel.classList.toggle('is-hidden', !open);
        ui.openControls.classList.toggle('is-visible', !open);
        try { localStorage.setItem(UI_PANEL_KEY, open ? '1' : '0'); } catch (_) {}
      }
      function getPanelOpenDefault() {
        try {
          const v = localStorage.getItem(UI_PANEL_KEY);
          if (v === '0') return false;
          if (v === '1') return true;
        } catch (_) {}
        return true;
      }
      setPanelOpen(getPanelOpenDefault());
      ui.closeControls.addEventListener('click', () => setPanelOpen(false));
      ui.openControls.addEventListener('click', () => setPanelOpen(true));

      // ---- Presets (ODE attractors) ----
      const builtinPresets = {
        'Lorenz (1963) — Edward Lorenz / “butterfly”': {
          dx: 'sigma*(y-x)',
          dy: 'x*(rho-z)-y',
          dz: 'x*y-beta*z',
          params: 'sigma=10\nrho=28\nbeta=8/3',
          init: '0.1, 0.1, 0.1',
          dt: '0.005',
          steps: '200000',
          transient: '2000',
        },
        'Linear ODE — damped oscillator (2D)': {
          // x1' = x2
          // x2' = -w^2 x1 - c x2
          category: 'ode_linear',
          systemType: 'ode',
          dim: '2',
          projX: '1',
          projY: '2',
          projZ: '2',
          eqs: "x1' = x2\nx2' = -w*w*x1 - c*x2",
          params: 'w=1\nc=0.08',
          init: '1, 0',
          dt: '0.01',
          absTol: '1e-8',
          relTol: '1e-5',
          dtMin: '1e-6',
          dtMax: '0.05',
          steps: '120000',
          transient: '0',
        },
        'Linear ODE — 3D Rotation (perfect circle)': {
          // x'=-y, y'=x, z'=0 (rotation in xy-plane)
          category: 'ode_linear',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = -x2\nx2' = x1\nx3' = 0",
          params: '',
          init: '1, 0, 0',
          dt: '0.01',
          absTol: '1e-8',
          relTol: '1e-5',
          dtMin: '1e-6',
          dtMax: '0.05',
          steps: '12000',
          transient: '0',
        },
        'Linear ODE — Spiral Sink (3D vortex in)': {
          // x'=-x-y, y'=x-y, z'=-0.5 z
          category: 'ode_linear',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = -x1 - x2\nx2' = x1 - x2\nx3' = -0.5*x3",
          params: '',
          init: '1, 0, 1',
          dt: '0.01',
          absTol: '1e-8',
          relTol: '1e-5',
          dtMin: '1e-6',
          dtMax: '0.05',
          steps: '12000',
          transient: '0',
        },
        'Linear ODE — Spiral Source (3D vortex out)': {
          // x'=x+y, y'=-x+y, z'=0.5 z
          category: 'ode_linear',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x1 + x2\nx2' = -x1 + x2\nx3' = 0.5*x3",
          params: '',
          init: '0.2, 0.1, 0.2',
          dt: '0.008',
          absTol: '1e-8',
          relTol: '1e-5',
          dtMin: '1e-6',
          dtMax: '0.05',
          steps: '80000',
          transient: '0',
        },
        'Linear ODE — Saddle (3D)': {
          // x'=x, y'=-y, z'=-z
          category: 'ode_linear',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x1\nx2' = -x2\nx3' = -x3",
          params: '',
          init: '0.2, 0.2, 0.2',
          dt: '0.01',
          absTol: '1e-8',
          relTol: '1e-5',
          dtMin: '1e-6',
          dtMax: '0.05',
          steps: '12000',
          transient: '0',
        },
        'Linear ODE — Pure Scaling (a*x, a*y, a*z)': {
          // x'=a x, y'=a y, z'=a z
          category: 'ode_linear',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = a*x1\nx2' = a*x2\nx3' = a*x3",
          params: 'a=0.12',
          init: '0.6, 0.2, 0.4',
          dt: '0.01',
          absTol: '1e-8',
          relTol: '1e-5',
          dtMin: '1e-6',
          dtMax: '0.05',
          steps: '90000',
          transient: '0',
        },
        'Linear ODE — Coupled Oscillator (3D ellipse)': {
          // x'=y, y'=z, z'=-x
          category: 'ode_linear',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x2\nx2' = x3\nx3' = -x1",
          params: '',
          init: '1, 0, 0',
          dt: '0.01',
          absTol: '1e-8',
          relTol: '1e-5',
          dtMin: '1e-6',
          dtMax: '0.05',
          steps: '12000',
          transient: '0',
        },
        'Linear ODE — Shear Flow (x\'=y)': {
          // x'=y, y'=0, z'=0
          category: 'ode_linear',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x2\nx2' = 0\nx3' = 0",
          params: '',
          init: '0, 1, 0',
          dt: '0.01',
          absTol: '1e-8',
          relTol: '1e-5',
          dtMin: '1e-6',
          dtMax: '0.05',
          steps: '12000',
          transient: '0',
        },
        'Linear ODE — Anisotropic Spiral (skewed)': {
          // x'=-x-3y, y'=x-y, z'=-0.2 z
          category: 'ode_linear',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = -x1 - 3*x2\nx2' = x1 - x2\nx3' = -0.2*x3",
          params: '',
          init: '1, 0, 1',
          dt: '0.01',
          absTol: '1e-8',
          relTol: '1e-5',
          dtMin: '1e-6',
          dtMax: '0.05',
          steps: '12000',
          transient: '0',
        },
        'Lü (Lu) System (2002) — Lü & Chen': {
          // Lü system (2002):
          // xdot = a(y - x)
          // ydot = -x z + c y
          // zdot = x y - b z
          dx: 'a*(y-x)',
          dy: '-x*z + c*y',
          dz: 'x*y - b*z',
          params: 'a=36\nb=3\nc=20',
          init: '0.1, 0.1, 0.1',
          dt: '0.003',
          steps: '240000',
          transient: '2500',
        },
        'Rössler (1976) — Otto Rössler': {
          dx: '-y - z',
          dy: 'x + a*y',
          dz: 'b + z*(x - c)',
          params: 'a=0.2\nb=0.2\nc=5.7',
          init: '0.1, 0, 0',
          dt: '0.01',
          steps: '160000',
          transient: '1500',
        },
        'Chen (1999) — Chen & Ueta': {
          dx: 'a*(y-x)',
          dy: '(c-a)*x - x*z + c*y',
          dz: 'x*y - b*z',
          params: 'a=35\nb=3\nc=28',
          init: '0.1, 0.1, 0.1',
          dt: '0.005',
          steps: '220000',
          transient: '2500',
        },
        'Halvorsen (1996) — Halvorsen attractor': {
          dx: '-a*x - 4*y - 4*z - y*y',
          dy: '-a*y - 4*z - 4*x - z*z',
          dz: '-a*z - 4*x - 4*y - x*x',
          params: 'a=1.4',
          init: '1, 0, 0',
          dt: '0.004',
          steps: '220000',
          transient: '3000',
        },
        'Chua Circuit (1986) — double scroll (Leon O. Chua)': {
          // Chua double-scroll (normalized form):
          // xdot = alpha (y - x - f(x))
          // ydot = x - y + z
          // zdot = -beta y
          // f(x) = m1*x + 0.5*(m0-m1)*(abs(x+1)-abs(x-1))
          dx: 'alpha*(y - x - (m1*x + 0.5*(m0-m1)*(abs(x+1)-abs(x-1))))',
          dy: 'x - y + z',
          dz: '-beta*y',
          params: 'alpha=15.6\nbeta=28\nm0=-1.143\nm1=-0.714',
          init: '0.1, 0, 0',
          dt: '0.004',
          steps: '260000',
          transient: '4000',
        },
        'Qi (2005) — Qi et al. (yz coupling)': {
          // A commonly cited Qi-system form (with yz term):
          // xdot = a (y - x) + y z
          // ydot = b x - y - x z
          // zdot = -c z + x y
          dx: 'a*(y-x) + y*z',
          dy: 'b*x - y - x*z',
          dz: '-c*z + x*y',
          params: 'a=35\nb=80\nc=8/3',
          init: '0.1, 0.0, 0.1',
          dt: '0.002',
          steps: '280000',
          transient: '5000',
        },
        'Rabinovich–Fabrikant (1979) — RF equations': {
          // xdot = y (z - 1 + x^2) + gamma x
          // ydot = x (3 z + 1 - x^2) + gamma y
          // zdot = -2 z (alpha + x y)
          dx: 'y*(z - 1 + x*x) + gamma*x',
          dy: 'x*(3*z + 1 - x*x) + gamma*y',
          dz: '-2*z*(alpha + x*y)',
          params: 'alpha=0.14\ngamma=0.10',
          init: '0.1, 0.1, 0.1',
          dt: '0.002',
          steps: '300000',
          transient: '6000',
        },
        'Thomas (1999) — cyclically symmetric attractor': {
          // Thomas cyclically symmetric attractor
          dx: 'sin(y) - b*x',
          dy: 'sin(z) - b*y',
          dz: 'sin(x) - b*z',
          params: 'b=0.208186',
          init: '0.1, 0, 0',
          dt: '0.01',
          steps: '200000',
          transient: '2000',
        },
        'Finance — Sornette–Andersen (search: “chaotic finance system”)': {
          // A 3D nonlinear finance-style system often used in chaotic finance demos:
          dx: '-a*x + y + z - x*x*x',
          dy: '-b*y + x*z',
          dz: '-c*z + x*y',
          params: 'a=0.1\nb=0.1\nc=14',
          init: '0.2, 0.1, 0.1',
          dt: '0.003',
          steps: '240000',
          transient: '4000',
        },
        'Henon map (Hénon 1976) — discrete-time': {
          // Classic Hénon map (2D):
          // x_{n+1} = 1 - a x_n^2 + y_n
          // y_{n+1} = b x_n
          // z_{n+1} = 0
          systemType: 'map',
          dx: '1 - a*x*x + y',
          dy: 'b*x',
          dz: '0',
          params: 'a=1.4\nb=0.3',
          init: '0, 0, 0',
          dt: '1',
          steps: '200000',
          transient: '100',
        },
        'Ikeda map (Ikeda 1979) — discrete-time': {
          // Ikeda map (2D) with parameter u:
          // t = 0.4 - 6/(1 + x^2 + y^2)
          // x_{n+1} = 1 + u (x cos t - y sin t)
          // y_{n+1} = u (x sin t + y cos t)
          // z_{n+1} = 0
          systemType: 'map',
          dx: '1 + u*(x*cos(0.4 - 6/(1 + x*x + y*y)) - y*sin(0.4 - 6/(1 + x*x + y*y)))',
          dy: 'u*(x*sin(0.4 - 6/(1 + x*x + y*y)) + y*cos(0.4 - 6/(1 + x*x + y*y)))',
          dz: '0',
          params: 'u=0.9',
          init: '0.1, 0, 0',
          dt: '1',
          steps: '220000',
          transient: '200',
        },
        'Linear Rotation Map (3D) — discrete rotation about z': {
          // [x_{n+1}, y_{n+1}, z_{n+1}]^T = Rz(theta) [x_n, y_n, z_n]^T
          category: 'map',
          systemType: 'map',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: 'cos(theta)*x - sin(theta)*y',
          dy: 'sin(theta)*x + cos(theta)*y',
          dz: 'z',
          params: 'theta=0.1*pi',
          init: '1, 0, 1',
          dt: '1',
          steps: '2000',
          transient: '0',
        },
        '3D Spiral Contraction Map — spiral sink': {
          // x_{n+1}=a x_n - y_n; y_{n+1}=x_n + a y_n; z_{n+1}=b z_n
          category: 'map',
          systemType: 'map',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: 'a*x - y',
          dy: 'x + a*y',
          dz: 'b*z',
          params: 'a=0.9\nb=0.95',
          init: '1, 0, 1',
          dt: '1',
          steps: '2000',
          transient: '0',
        },
        'Ikeda 3D Map — with z decay': {
          // t = k - 0.4/(1 + x^2 + y^2)
          // x_{n+1}=1+u(x cos t - y sin t)
          // y_{n+1}=u(x sin t + y cos t)
          // z_{n+1}=d z_n
          category: 'map',
          systemType: 'map',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '1 + u*(x*cos(k - 0.4/(1 + x*x + y*y)) - y*sin(k - 0.4/(1 + x*x + y*y)))',
          dy: 'u*(x*sin(k - 0.4/(1 + x*x + y*y)) + y*cos(k - 0.4/(1 + x*x + y*y)))',
          dz: 'd*z',
          params: 'k=0.9\nu=0.9\nd=0.98',
          init: '0.1, 0, 1',
          dt: '1',
          steps: '2200',
          transient: '200',
        },
        'Linear Saddle Map (3D)': {
          // x_{n+1}=1.2 x_n; y_{n+1}=0.7 y_n; z_{n+1}=0.6 z_n
          category: 'map',
          systemType: 'map',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '1.2*x',
          dy: '0.7*y',
          dz: '0.6*z',
          params: '',
          init: '0.2, 0.2, 0.2',
          dt: '1',
          steps: '1200',
          transient: '0',
        },
        'Quaternion Rotation Map (3D) — smooth': {
          // Rotate vector v by unit quaternion q:
          // t = 2 * cross(qv, v)
          // v' = v + qw*t + cross(qv, t)
          category: 'map',
          systemType: 'map',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: "x + qw*(2*(qy*z - qz*y)) + (qy*(2*(qx*y - qy*x)) - qz*(2*(qz*x - qx*z)))",
          dy: "y + qw*(2*(qz*x - qx*z)) + (qz*(2*(qy*z - qz*y)) - qx*(2*(qx*y - qy*x)))",
          dz: "z + qw*(2*(qx*y - qy*x)) + (qx*(2*(qz*x - qx*z)) - qy*(2*(qy*z - qz*y)))",
          params: [
            'angle=0.1*pi',
            'ax=1/sqrt(3)',
            'ay=1/sqrt(3)',
            'az=1/sqrt(3)',
            'qw=cos(angle/2)',
            'qx=ax*sin(angle/2)',
            'qy=ay*sin(angle/2)',
            'qz=az*sin(angle/2)',
          ].join('\n'),
          init: '1, 0, 1',
          dt: '1',
          steps: '2000',
          transient: '0',
        },
        'Orthogonal Map (3D) — rotation matrix (random-like)': {
          // X_{n+1} = Q X_n where Q is orthogonal (constructed from Euler angles)
          // Q = Rz(a) * Ry(b) * Rx(c)
          category: 'map',
          systemType: 'map',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '(cos(a)*cos(b))*x + (cos(a)*sin(b)*sin(c) - sin(a)*cos(c))*y + (cos(a)*sin(b)*cos(c) + sin(a)*sin(c))*z',
          dy: '(sin(a)*cos(b))*x + (sin(a)*sin(b)*sin(c) + cos(a)*cos(c))*y + (sin(a)*sin(b)*cos(c) - cos(a)*sin(c))*z',
          dz: '(-sin(b))*x + (cos(b)*sin(c))*y + (cos(b)*cos(c))*z',
          params: 'a=1.1\nb=0.7\nc=2.0',
          init: '1, 0, 0',
          dt: '1',
          steps: '200000',
          transient: '0',
        },
        'Noisy Lorenz (SDE) — Lorenz + Gaussian noise': {
          // SDE mode: x += f*dt + sigma*sqrt(dt)*N(0,1)
          category: 'stochastic',
          systemType: 'sde',
          sigma: '0.8',
          dx: 'sigmaL*(y-x)',
          dy: 'x*(rho-z)-y',
          dz: 'x*y-beta*z',
          params: 'sigmaL=10\nrho=28\nbeta=8/3',
          init: '0.1, 0.1, 0.1',
          dt: '0.003',
          steps: '200000',
          transient: '0',
        },
        'Stochastic Hopf Oscillator (3D embedding)': {
          // dr = (μ − r²)r dt + σ dW, dθ = ω dt
          // x = r cosθ, y = r sinθ, z = h
          category: 'stochastic',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '(mu - (x*x + y*y))*x - omega*y',
          dy: 'omega*x + (mu - (x*x + y*y))*y',
          dz: '0',
          params: 'mu=1\nomega=1',
          init: '0.5, 0, 0.1',
          dt: '0.01',
          sigma: '0.3',
          steps: '200000',
          transient: '0',
        },
        'Stochastic Double Gyre Flow (3D)': {
          // vₓ = −π A sin(π f(x,t)) cos(π y)
          // vᵧ =  π A cos(π f(x,t)) sin(π y)
          // v𝓏 = 0
          // f(x,t) = a(t)*x² + b(t)*x, a(t) = ε sin(ωt), b(t) = 1 - 2ε sin(ωt)
          category: 'stochastic',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '-pi*A*sin(pi*(eps*sin(omega*t)*x*x + (1 - 2*eps*sin(omega*t))*x))*cos(pi*y)',
          dy: 'pi*A*cos(pi*(eps*sin(omega*t)*x*x + (1 - 2*eps*sin(omega*t))*x))*sin(pi*y)',
          dz: '0',
          params: 'A=0.1\neps=0.25\nomega=2*pi/10',
          init: '0.1, 0.1, 0',
          dt: '0.01',
          sigma: '0.15',
          steps: '200000',
          transient: '0',
        },
        '3D Ornstein–Uhlenbeck (OU) in a Potential Well': {
          // dx = −αx dt + σ dWₓ
          // dy = −αy dt + σ dWᵧ
          // dz = −αz dt + σ dW𝓏
          category: 'stochastic',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '-alpha*x',
          dy: '-alpha*y',
          dz: '-alpha*z',
          params: 'alpha=0.5',
          init: '1, 1, 1',
          dt: '0.01',
          sigma: '0.4',
          steps: '200000',
          transient: '0',
        },
        'Stochastic Kuramoto Ensemble (3D embedding)': {
          // dθᵢ = ωᵢ dt + (K/N) Σ sin(θⱼ − θᵢ) dt + σ dWᵢ
          // Simplified: single oscillator with coupling term
          // x = cosθ, y = sinθ, z = 0 or random direction
          category: 'stochastic',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '-(omega + K*sin(theta_mean - atan2(y, x)))*y',
          dy: '(omega + K*sin(theta_mean - atan2(y, x)))*x',
          dz: '0.1*sin(2*atan2(y, x))',
          params: 'omega=1\nK=0.5\ntheta_mean=0',
          init: '1, 0, 0',
          dt: '0.01',
          sigma: '0.2',
          steps: '200000',
          transient: '0',
        },
        'Stochastic Reaction–Diffusion Particle Tracking (3D)': {
          // dx = μ dt + √(2D) dW with soft attraction force F = −∇U(r)
          // U(r) = -A*exp(-r²/(2*σ²)) (Gaussian well)
          category: 'stochastic',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: 'mu_x - A*x*exp(-(x*x + y*y + z*z)/(2*sigmaU*sigmaU))/(sigmaU*sigmaU)',
          dy: 'mu_y - A*y*exp(-(x*x + y*y + z*z)/(2*sigmaU*sigmaU))/(sigmaU*sigmaU)',
          dz: 'mu_z - A*z*exp(-(x*x + y*y + z*z)/(2*sigmaU*sigmaU))/(sigmaU*sigmaU)',
          params: 'mu_x=0\nmu_y=0\nmu_z=0\nA=2\nsigmaU=0.5',
          init: '0.5, 0.5, 0.5',
          dt: '0.01',
          sigma: '0.3',
          steps: '200000',
          transient: '0',
        },
        'Stochastic Rigid Body Rotation': {
          // Euler equations: dω = I⁻¹(τ − ω×Iω)dt + σ dW
          // Quaternion rotation: dq = ½ q⊗ω dt
          // Simplified: 3D rotation with noise
          category: 'stochastic',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: 'omega_y*z - omega_z*y',
          dy: 'omega_z*x - omega_x*z',
          dz: 'omega_x*y - omega_y*x',
          params: 'omega_x=0.5\nomega_y=0.3\nomega_z=0.2',
          init: '1, 0, 0',
          dt: '0.01',
          sigma: '0.15',
          steps: '200000',
          transient: '0',
        },
        'Random Walk on a Sphere (S² diffusion)': {
          // Geometric Brownian motion constrained: dx = P(x) dW
          // P = I − xxᵀ (projection onto tangent space)
          // Simplified: drift toward sphere + noise
          category: 'stochastic',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '-(x*x + y*y + z*z - 1)*x',
          dy: '-(x*x + y*y + z*z - 1)*y',
          dz: '-(x*x + y*y + z*z - 1)*z',
          params: '',
          init: '1, 0, 0',
          dt: '0.01',
          sigma: '0.2',
          steps: '200000',
          transient: '0',
        },
        'Stochastic Gradient Flow in 3D Potential Landscape': {
          // dx = −∇U(x) dt + σ dW
          // U(x) = (x² + y² + z²)²/4 - (x² + y² + z²)/2 (multi-well potential)
          category: 'stochastic',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '-(x*x + y*y + z*z - 1)*x',
          dy: '-(x*x + y*y + z*z - 1)*y',
          dz: '-(x*x + y*y + z*z - 1)*z',
          params: '',
          init: '0.5, 0.5, 0.5',
          dt: '0.01',
          sigma: '0.25',
          steps: '200000',
          transient: '0',
        },
        'Helix (parametric)': {
          // x(t)=cos(t), y(t)=sin(t), z(t)=0.05*t
          category: 'algebraic',
          systemType: 'param',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: 'x1 = cos(t)\nx2 = sin(t)\nx3 = 0.05*t',
          params: '',
          init: '0, 0, 0',
          dt: '0.02',
          steps: '120000',
          transient: '0',
        },
        'Sphere (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^2 + y^2 + z^2 - R^2',
          algIso: '0',
          algRes: '52',
          algXMin: '-1.3',
          algXMax: '1.3',
          algYMin: '-1.3',
          algYMax: '1.3',
          algZMin: '-1.3',
          algZMax: '1.3',
          params: 'R=1',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Ellipsoid (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^2/a^2 + y^2/b^2 + z^2/c^2 - 1',
          algIso: '0',
          algRes: '56',
          algXMin: '-1.6',
          algXMax: '1.6',
          algYMin: '-1.6',
          algYMax: '1.6',
          algZMin: '-1.6',
          algZMax: '1.6',
          params: 'a=1.2\nb=0.9\nc=0.7',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Hyperboloid (1 sheet) (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^2/a^2 + y^2/b^2 - z^2/c^2 - 1',
          algIso: '0',
          algRes: '58',
          algXMin: '-2',
          algXMax: '2',
          algYMin: '-2',
          algYMax: '2',
          algZMin: '-2',
          algZMax: '2',
          params: 'a=1\nb=1\nc=1.2',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Paraboloid (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'z - (x^2/a^2 + y^2/b^2)',
          algIso: '0',
          algRes: '60',
          algXMin: '-1.4',
          algXMax: '1.4',
          algYMin: '-1.4',
          algYMax: '1.4',
          algZMin: '-0.2',
          algZMax: '2.2',
          params: 'a=1\nb=1',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Torus (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: '(x^2+y^2+z^2+R^2-r^2)^2 - 4*R^2*(x^2+y^2)',
          algIso: '0',
          algRes: '64',
          algXMin: '-1.8',
          algXMax: '1.8',
          algYMin: '-1.8',
          algYMax: '1.8',
          algZMin: '-1.8',
          algZMax: '1.8',
          params: 'R=1\nr=0.45',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Fermat surface (degree n) (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^n + y^n + z^n - 1',
          algIso: '0',
          algRes: '64',
          algXMin: '-1.2',
          algXMax: '1.2',
          algYMin: '-1.2',
          algYMax: '1.2',
          algZMin: '-1.2',
          algZMax: '1.2',
          params: 'n=4',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Clebsch diagonal cubic (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^3 + y^3 + z^3 - (x+y+z)^3',
          algIso: '0',
          algRes: '70',
          algXMin: '-1.2',
          algXMax: '1.2',
          algYMin: '-1.2',
          algYMax: '1.2',
          algZMin: '-1.2',
          algZMax: '1.2',
          params: '',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Roman surface (Steiner) (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'x^2*y^2 + y^2*z^2 + z^2*x^2 - x*y*z',
          algIso: '0',
          algRes: '68',
          algXMin: '-1.2',
          algXMax: '1.2',
          algYMin: '-1.2',
          algYMax: '1.2',
          algZMin: '-1.2',
          algZMax: '1.2',
          params: '',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Gyroid (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          algF: 'sin(x)*cos(y) + sin(y)*cos(z) + sin(z)*cos(x)',
          algIso: '0',
          algRes: '64',
          algXMin: '-pi',
          algXMax: 'pi',
          algYMin: '-pi',
          algYMax: 'pi',
          algZMin: '-pi',
          algZMax: 'pi',
          params: '',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Barth Sextic (implicit)': {
          category: 'algebraic',
          systemType: 'param',
          algMode: 'implicit',
          // One common form of Barth sextic (scaled). phi is the golden ratio.
          algF: '4*(phi^2*x^2 - y^2)*(phi^2*y^2 - z^2)*(phi^2*z^2 - x^2) - (1 + 2*phi)*(x^2 + y^2 + z^2 - 1)^2',
          algIso: '0',
          algRes: '78',
          algXMin: '-1.6',
          algXMax: '1.6',
          algYMin: '-1.6',
          algYMax: '1.6',
          algZMin: '-1.6',
          algZMax: '1.6',
          params: 'phi=(1+sqrt(5))/2',
          eqs: '',
          init: '',
          dt: '0.01',
          steps: '1',
          transient: '0',
        },
        'Lissajous Knot (parametric)': {
          category: 'algebraic',
          systemType: 'param',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          algMode: 'parametric',
          eqs: 'x1 = sin(a*t + delta)\nx2 = sin(b*t)\nx3 = sin(c*t)',
          params: 'a=3\nb=4\nc=5\ndelta=pi/2',
          init: '0, 0, 0',
          dt: '0.003',
          steps: '6000',
          transient: '0',
        },
        'Sprott (1994) — simple chaotic flow #1 (J.C. Sprott)': {
          // Example Sprott simple chaotic flow:
          // xdot = y + z
          // ydot = -x + a y
          // zdot = x^2 - z
          dx: 'y + z',
          dy: '-x + a*y',
          dz: 'x*x - z',
          params: 'a=0.2',
          init: '0.1, 0, 0',
          dt: '0.01',
          steps: '180000',
          transient: '2000',
        },
        'Sprott (1994) — simple chaotic flow #2 (J.C. Sprott)': {
          // Another Sprott-type simple flow:
          // xdot = y
          // ydot = z
          // zdot = -A z + y^2 - x
          dx: 'y',
          dy: 'z',
          dz: '-A*z + y*y - x',
          params: 'A=2.017',
          init: '0.1, 0, 0',
          dt: '0.01',
          steps: '180000',
          transient: '2000',
        },
        'Dequan Li (2007) — Li 3-scroll attractor': {
          // Commonly cited Li 3-scroll form:
          // xdot = a(y-x) + d x z
          // ydot = k x + f y - x z
          // zdot = -e x^2 + x y + c z
          dx: 'a*(y-x) + d*x*z',
          dy: 'k*x + f*y - x*z',
          dz: '-e*x^2 + x*y + c*z',
          params: 'a=40\nd=0.16\nk=55\nf=20\ne=0.65\nc=11/6',
          init: '2, 2, 2',
          dt: '0.0025',
          steps: '260000',
          transient: '4000',
        },
        'Heat (2D) — Gaussian blob': {
          category: 'pde_linear',
          // ODE fields (unused in PDE mode)
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          init: '',
          params: '',
          dt: '0.00025',
          steps: '30000',
          sigma: '0',
          // PDE fields
          pdeType: 'heat2d',
          pdeNx: '90',
          pdeNy: '90',
          pdeXMin: '-1',
          pdeXMax: '1',
          pdeYMin: '-1',
          pdeYMax: '1',
          pdeAlpha: '0.25',
          pdeBC: 'dirichlet0',
          pdeZScale: '1.0',
          pdeU0: 'exp(-25*(x^2+y^2))',
          pdeSource: '0',
        },
        'Heat (2D) — Periodic sine decay': {
          category: 'pde_linear',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          init: '',
          params: '',
          dt: '0.002',
          steps: '15000',
          sigma: '0',
          pdeType: 'heat2d',
          pdeNx: '90',
          pdeNy: '90',
          pdeXMin: '0',
          pdeXMax: '2*pi',
          pdeYMin: '0',
          pdeYMax: '2*pi',
          pdeAlpha: '0.2',
          pdeBC: 'periodic',
          pdeZScale: '1.0',
          pdeU0: 'sin(x)*sin(y)',
          pdeSource: '0',
        },
        'Heat (2D) — Center source': {
          category: 'pde_linear',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          init: '',
          params: '',
          dt: '0.0003',
          steps: '25000',
          sigma: '0',
          pdeType: 'heat2d',
          pdeNx: '90',
          pdeNy: '90',
          pdeXMin: '-1',
          pdeXMax: '1',
          pdeYMin: '-1',
          pdeYMax: '1',
          pdeAlpha: '0.18',
          pdeBC: 'dirichlet0',
          pdeZScale: '1.0',
          pdeU0: '0',
          pdeSource: '3*exp(-40*(x^2+y^2))',
        },
        'Reaction–Diffusion (2D) — Fisher-KPP': {
          category: 'pde_nonlinear',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          init: '',
          params: 'r=2.0',
          dt: '0.00025',
          steps: '30000',
          sigma: '0',
          pdeType: 'heat2d',
          pdeNx: '90',
          pdeNy: '90',
          pdeXMin: '-1',
          pdeXMax: '1',
          pdeYMin: '-1',
          pdeYMax: '1',
          pdeAlpha: '0.08',
          pdeBC: 'neumann0',
          pdeZScale: '1.0',
          pdeU0: '0.15*exp(-35*(x^2+y^2))',
          pdeSource: '0',
          pdeNonlinear: 'r*u*(1-u)',
        },
        'Reaction–Diffusion (2D) — Allen–Cahn': {
          category: 'pde_nonlinear',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          init: '',
          params: '',
          dt: '0.0002',
          steps: '32000',
          sigma: '0',
          pdeType: 'heat2d',
          pdeNx: '90',
          pdeNy: '90',
          pdeXMin: '-1',
          pdeXMax: '1',
          pdeYMin: '-1',
          pdeYMax: '1',
          pdeAlpha: '0.06',
          pdeBC: 'neumann0',
          pdeZScale: '1.0',
          pdeU0: '0.6*(sin(3*x)+sin(3*y))',
          pdeSource: '0',
          pdeNonlinear: 'u - u^3',
        },
        "DAE — x'=-x+y, 0=y-x^2 (index-1)": {
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: '',
          // state is [x1, y1] => x1 is differential, x2 is algebraic
          init: '0.2, 0.04',
          dt: '0.01',
          steps: '1200',
          transient: '2000',
          daeIndex: '1',
          daeNx: '1',
          daeF: "x1' = -x1 + x2",
          daeG: "0 = x2 - x1^2",
          daeTol: '1e-10',
          daeNewtonIters: '12',
        },
        'DAE — Simple Control System (index-1)': {
          // x' = -x + y, y' = x - y + lambda, constraint: y = x^2 + lambda
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: '',
          // state: [x, y, lambda]
          init: '0.5, 0.25, 0',
          dt: '0.01',
          steps: '5000',
          transient: '0',
          daeIndex: '1',
          daeNx: '2',
          daeF: "x1' = -x1 + x2\nx2' = x1 - x2 + x3",
          daeG: '0 = x2 - x1^2 - x3',
          daeTol: '1e-8',
          daeNewtonIters: '12',
        },
        'DAE — Linear Constraint System (index-1)': {
          // x' = y, y' = -x + lambda, constraint: y = x + lambda
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: '',
          // state: [x, y, lambda]
          init: '1, 1, 0',
          dt: '0.01',
          steps: '5000',
          transient: '0',
          daeIndex: '1',
          daeNx: '2',
          daeF: "x1' = x2\nx2' = -x1 + x3",
          daeG: '0 = x2 - x1 - x3',
          daeTol: '1e-8',
          daeNewtonIters: '12',
        },
        'DAE — RLC Circuit with Control (index-1)': {
          // RLC circuit: C*v' = iL - G*v, L*iL' = -v + lambda
          // Constraint: v + lambda = E (lambda is control to maintain v near E)
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: 'C=1\nL=1\nG=0.1\nE=5',
          // state: [v, iL, lambda]
          init: '5, 0.5, 0',
          dt: '0.01',
          steps: '15000',
          transient: '0',
          daeIndex: '1',
          daeNx: '2',
          daeF: "x1' = (x2 - G*x1)/C\nx2' = (-x1 + x3)/L",
          daeG: '0 = x1 + x3 - E',
          daeTol: '1e-8',
          daeNewtonIters: '12',
        },
        'DAE — Circuit with Current Constraint (index-1)': {
          // Simple circuit: v' = i - v, i' = -v + lambda, constraint: i = I0 + lambda
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: 'I0=1',
          // state: [v, i, lambda]
          init: '0, 1, 0',
          dt: '0.01',
          steps: '5000',
          transient: '0',
          daeIndex: '1',
          daeNx: '2',
          daeF: "x1' = x2 - x1\nx2' = -x1 + x3",
          daeG: '0 = x2 - I0 - x3',
          daeTol: '1e-8',
          daeNewtonIters: '12',
        },
        'DAE — Chemical Reaction with Control (index-1)': {
          // A' = -k1*A + k2*B + lambda, B' = k1*A - k2*B - lambda
          // Constraint: A + B + lambda = C0 (lambda explicitly in constraint)
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: 'k1=1\nk2=0.5\nC0=2',
          // state: [A, B, lambda]
          init: '2, 0, 0',
          dt: '0.01',
          steps: '5000',
          transient: '0',
          daeIndex: '1',
          daeNx: '2',
          daeF: "x1' = -k1*x1 + k2*x2 + x3\nx2' = k1*x1 - k2*x2 - x3",
          daeG: '0 = x1 + x2 + x3 - C0',
          daeTol: '1e-8',
          daeNewtonIters: '12',
        },
        'DAE — Slider with Friction (index-1)': {
          // Slider with friction: x'=v, v'=F - mu*lambda, constraint: v + lambda = v0
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: 'F=1\nmu=0.1\nv0=0',
          // state: [x, v, lambda]
          init: '0, 0, 0',
          dt: '0.01',
          steps: '5000',
          transient: '0',
          daeIndex: '1',
          daeNx: '2',
          daeF: "x1' = x2\nx2' = F - mu*x3",
          daeG: '0 = x2 + x3 - v0',
          daeTol: '1e-8',
          daeNewtonIters: '12',
        },
        'DAE — Constrained Rigid Body on Sphere (index-2)': {
          // Particle on sphere: x'=v, m*v'=F - lambda*x
          // Position constraint: g = x1² + x2² + x3² - R² = 0
          // d²g/dt² = 2*(x1*x4' + x2*x5' + x3*x6') + 2*(x4² + x5² + x6²)
          //         = 2*(x1*(Fx-lambda*x1)/m + x2*(Fy-lambda*x2)/m + x3*(Fz-lambda*x3)/m) + 2*(x4²+x5²+x6²)
          //         = 2*(x1*Fx+x2*Fy+x3*Fz)/m - 2*lambda*R²/m + 2*(x4²+x5²+x6²)
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: 'm=1\nR=1\ng=9.8\nFx=0\nFy=0\nFz=-m*g',
          // state: [x, y, z, vx, vy, vz, lambda]
          init: '1, 0, 0, 0, 0.5, 0, 0',
          dt: '0.005',
          steps: '28000',
          transient: '0',
          daeIndex: '2',
          daeNx: '6',
          daeF: "x1' = x4\nx2' = x5\nx3' = x6\nx4' = (Fx - x7*x1)/m\nx5' = (Fy - x7*x2)/m\nx6' = (Fz - x7*x3)/m",
          daeGPos: '0 = x1^2 + x2^2 + x3^2 - R^2',
          daeG: '0 = 2*(x1*(Fx - x7*x1)/m + x2*(Fy - x7*x2)/m + x3*(Fz - x7*x3)/m) + 2*(x4^2 + x5^2 + x6^2)',
          daeTol: '1e-8',
          daeNewtonIters: '20',
        },
        'DAE — Spatial Slider–Crank Mechanism (index-2)': {
          // Slider-crank: crank rotates at (R*cos(ωt), R*sin(ωt)), rod at (x1, x2) constrained by |(x1,x2) - crank| = L
          // Position constraint: g = (x1 - R*cos(ωt))² + (x2 - R*sin(ωt))² - L² = 0
          // d²g/dt² involves lambda through rod acceleration
          // State: [x1, x2, vx1, vx2, lambda] where (x1,x2) is rod position
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: 'L=1\nR=0.5\nomega=1',
          // state: [x1, x2, vx1, vx2, lambda] = rod position, velocity, lambda
          // Initial: rod at (R+L, 0) to satisfy constraint when crank is at (R, 0)
          init: '1.5, 0, 0, 0, 0',
          dt: '0.01',
          steps: '25000',
          transient: '0',
          daeIndex: '2',
          daeNx: '4',
          daeF: "x1' = x3\nx2' = x4\nx3' = -x5*(x1 - R*cos(omega*t))\nx4' = -x5*(x2 - R*sin(omega*t))",
          daeGPos: '0 = (x1 - R*cos(omega*t))^2 + (x2 - R*sin(omega*t))^2 - L^2',
          daeG: '0 = 2*(x3 + omega*R*sin(omega*t))^2 + 2*(x4 - omega*R*cos(omega*t))^2 + 2*(x1 - R*cos(omega*t))*(-x5*(x1 - R*cos(omega*t)) + omega^2*R*cos(omega*t)) + 2*(x2 - R*sin(omega*t))*(-x5*(x2 - R*sin(omega*t)) + omega^2*R*sin(omega*t))',
          daeTol: '1e-8',
          daeNewtonIters: '20',
        },
        'DAE — Nonholonomic Rolling Sphere (index-2)': {
          // Sphere rolling on plane z=0 without slipping
          // Nonholonomic constraint: v = R*ω × n, where n = (0,0,1) is normal
          // vx = R*omega_y, vy = -R*omega_x, vz = 0
          // Position constraint (implicit): z = R (sphere touches plane)
          // Velocity constraint: g = [vx - R*omega_y, vy + R*omega_x, vz] = 0
          // d²g/dt² involves lambda through acceleration
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: 'R=1\nm=1\nI=0.4\ng=9.8',
          // state: [x, y, z, omega_x, omega_y, omega_z, vx, vy, vz, lambda1, lambda2, lambda3]
          // For 2D rolling: [x, y, omega_z, vx, vy, lambda1, lambda2]
          // Actually simpler: [x, y, omega, vx, vy, lambda1, lambda2] where omega is about z-axis
          // But constraint is vx = R*omega_y, vy = -R*omega_x, so need both omega_x and omega_y
          // Let's use: [x, y, omega_x, omega_y, vx, vy, lambda1, lambda2]
          init: '0, 0, 0, 1, 1, 0, 0, 0',
          dt: '0.01',
          steps: '10000',
          transient: '0',
          daeIndex: '2',
          daeNx: '6',
          daeF: "x1' = x5\nx2' = x6\nx3' = R*x8/I\nx4' = -R*x7/I\nx5' = -x7/m\nx6' = -x8/m",
          daeGPos: '0 = x5 - R*x4\n0 = x6 + R*x3',
          daeG: '0 = -x7/m - R*(-R*x7/I)\n0 = -x8/m + R*(R*x8/I)',
          daeTol: '1e-8',
          daeNewtonIters: '20',
        },
        'DAE — Double Pendulum 3D (index-3)': {
          // Double pendulum: two masses connected by rigid rods
          // Position constraints: |x1 - x0|² = L1², |x2 - x1|² = L2²
          // g1 = x1² + y1² + z1² - L1² = 0 (x0 = origin)
          // g2 = (x2-x1)² + (y2-y1)² + (z2-z1)² - L2² = 0
          // d²g1/dt² = 2*(vx1²+vy1²+vz1²) + 2*(x1*ax1 + y1*ay1 + z1*az1) involves lambda
          // Simplified 2D version: [x1, y1, x2, y2, vx1, vy1, vx2, vy2, lambda1, lambda2]
          category: 'dae',
          dx: '',
          dy: '',
          dz: '',
          eqs: '',
          params: 'm1=1\nm2=1\nL1=1\nL2=1\ng=9.8',
          // state: [x1, y1, x2, y2, vx1, vy1, vx2, vy2, lambda1, lambda2]
          // Initial: first mass at (L1,0), second at (L1+L2,0) to satisfy constraints
          init: '1, 0, 2, 0, 0, 0, 0, 0, 0, 0',
          dt: '0.005',
          steps: '11000',
          transient: '0',
          daeIndex: '3',
          daeNx: '8',
          daeF: "x1' = x5\nx2' = x6\nx3' = x7\nx4' = x8\nx5' = -x9*x1/m1\nx6' = -x9*x2/m1 - g\nx7' = -x10*(x3-x1)/m2\nx8' = -x10*(x4-x2)/m2 - g",
          daeGPos: '0 = x1^2 + x2^2 - L1^2\n0 = (x3-x1)^2 + (x4-x2)^2 - L2^2',
          daeG: '0 = 2*(x5^2 + x6^2) + 2*x1*(-x9*x1/m1) + 2*x2*(-x9*x2/m1 - g)\n0 = 2*((x7-x5)^2 + (x8-x6)^2) + 2*(x3-x1)*(-x10*(x3-x1)/m2 - (-x9*x1/m1)) + 2*(x4-x2)*(-x10*(x4-x2)/m2 - g - (-x9*x2/m1 - g))',
          daeTol: '1e-8',
          daeNewtonIters: '25',
        },
        'Hybrid — Integrate-and-Fire Neuron (v, spike)': {
          category: 'hybrid',
          systemType: 'hybrid',
          dim: '2',
          projX: '1',
          projY: '2',
          projZ: '1',
          // Leaky integrate-and-fire (continuous ODE) + hybrid event/reset:
          // dv/dt = -(v - v_rest)/tau + I
          // spike decays between events
          eqs: "x1' = -(x1 - v_rest)/tau + I\nx2' = -x2/tauS",
          hybridEvent: 'x1 >= v_th',
          hybridReset: "x1 = v_reset\nx2 = spikeAmp",
          params: [
            'tau=10',
            'v_rest=-65',
            'v_reset=-70',
            'v_th=-50',
            'I=2',
            'spikeAmp=1',
            'tauS=5',
          ].join('\n'),
          init: '-65, 0',
          dt: '0.05',
          steps: '120000',
          transient: '0',
        },
        'Hybrid — Bouncing Ball 3D (Impact)': {
          // Free fall + elastic collision
          // x' = vx, y' = vy, z' = vz, vz' = -g
          // Reset: if z = 0 and vz < 0: vz := -c * vz
          category: 'hybrid',
          systemType: 'hybrid',
          dim: '6',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x4\nx2' = x5\nx3' = x6\nx4' = 0\nx5' = 0\nx6' = -g",
          hybridEvent: 'x3 <= 0 && x6 < 0',
          hybridReset: 'x3 = 0\nx6 = -c * x6',
          params: 'g=9.8\nc=0.8',
          init: '0, 0, 2, 1, 0.5, 0',
          dt: '0.01',
          steps: '2000',
          transient: '0',
        },
        'Hybrid — Pendulum + Switching Controller (3D)': {
          // θ'' = -(g/L)sinθ + u (switching control)
          // Switch: if |θ| >= θ₀ → apply control u, else → no control
          // 3D: x = sinθ, y = cosθ, z = θ'
          category: 'hybrid',
          systemType: 'hybrid',
          dim: '4',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x4*cos(x2)\nx2' = -x4*sin(x2)\nx3' = -(g/L)*sin(x2) + u_control\nx4' = 0",
          hybridEvent: 'abs(x2) >= theta0 && x4 == 0 || abs(x2) < theta0 && x4 == 1',
          hybridReset: 'x4 = (abs(x2) >= theta0) ? 1 : 0',
          params: 'g=9.8\nL=1\nu_control=2\ntheta0=0.5',
          init: '0, 1.2, 0, 0',
          dt: '0.01',
          steps: '2000',
          transient: '0',
        },
        'Hybrid — Robot Navigation with Collision': {
          // x' = v cosθ, y' = v sinθ, θ' = ω
          // Reset: if collision: θ := θ + π/2
          // 3D: z = time or speed
          category: 'hybrid',
          systemType: 'hybrid',
          dim: '4',
          projX: '1',
          projY: '2',
          projZ: '4',
          eqs: "x1' = v*cos(x3)\nx2' = v*sin(x3)\nx3' = omega\nx4' = 1",
          hybridEvent: 'x1 <= -2 || x1 >= 2 || x2 <= -2 || x2 >= 2',
          hybridReset: 'x3 = x3 + pi/2',
          params: 'v=1\nomega=0.1',
          init: '0, 0, 0, 0',
          dt: '0.001',
          steps: '2000',
          transient: '0',
        },
        'Hybrid — Piecewise Linear Chaotic Attractor': {
          // Switch between linear modes based on x1
          // Mode encoded in x4: 0 = mode 1, 1 = mode 2
          category: 'hybrid',
          systemType: 'hybrid',
          dim: '4',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = (x4 == 0) ? (a1*x1 + a2*x2 + a3*x3) : (b1*x1 + b2*x2 + b3*x3)\nx2' = (x4 == 0) ? (a4*x1 + a5*x2 + a6*x3) : (b4*x1 + b5*x2 + b6*x3)\nx3' = (x4 == 0) ? (a7*x1 + a8*x2 + a9*x3) : (b7*x1 + b8*x2 + b9*x3)\nx4' = 0",
          hybridEvent: 'x1 > c && x4 == 0 || x1 <= c && x4 == 1',
          hybridReset: 'x4 = (x1 > c) ? 1 : 0',
          params: 'a1=0.5\na2=-0.3\na3=0.2\na4=0.1\na5=0.4\na6=-0.1\na7=-0.2\na8=0.1\na9=0.3\nb1=-0.3\nb2=0.2\nb3=0.1\nb4=0.2\nb5=-0.4\nb6=0.3\nb7=0.1\nb8=-0.2\nb9=-0.3\nc=0',
          init: '0.1, 0.1, 0.1, 0',
          dt: '0.01',
          steps: '2000',
          transient: '0',
        },
        'Hybrid — Hopf Oscillator with Reset': {
          // r' = μr(1−r²), θ' = ω
          // Reset: if θ >= 2π → θ := θ - 2π
          // 3D: x = r cosθ, y = r sinθ, z = θ
          // Note: r = sqrt(x1^2 + x2^2), theta = atan2(x2, x1)
          category: 'hybrid',
          systemType: 'hybrid',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = mu*x1*(1 - (x1*x1 + x2*x2)) - omega*x2\nx2' = mu*x2*(1 - (x1*x1 + x2*x2)) + omega*x1\nx3' = omega",
          hybridEvent: 'x3 >= 2*pi',
          hybridReset: 'x3 = x3 - 2*pi',
          params: 'mu=1\nomega=1',
          init: '0.5, 0, 0',
          dt: '0.01',
          steps: '2000',
          transient: '0',
        },
        'Hybrid — Predator–Prey with Harvest Events': {
          // x' = ax − bxy, y' = −cy + dxy
          // Reset: if x > Xmax: x := αx
          // 3D: z = time
          category: 'hybrid',
          systemType: 'hybrid',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = a*x1 - b*x1*x2\nx2' = -c*x2 + d*x1*x2\nx3' = 1",
          hybridEvent: 'x1 > Xmax',
          hybridReset: 'x1 = alpha*x1',
          params: 'a=1\nb=0.1\nc=0.5\nd=0.02\nXmax=10\nalpha=0.5',
          init: '5, 3, 0',
          dt: '0.01',
          steps: '20000',
          transient: '0',
        },
        'Hybrid — Chua Circuit (Nonlinear switching)': {
          // Switch: if |x| < 1 → mode 1, else → mode 2
          // x' = α(y − x − m(x)), y' = x − y + z, z' = −βy
          // Mode encoded in x4: 0 = |x| < 1, 1 = |x| >= 1
          // m(x) = (x4 == 0) ? (m1*x1) : (m0*x1 + 0.5*(m0-m1)*(abs(x1+1) - abs(x1-1)))
          category: 'hybrid',
          systemType: 'hybrid',
          dim: '4',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = alpha*(x2 - x1 - ((x4 == 0) ? (m1*x1) : (m0*x1 + 0.5*(m0-m1)*(abs(x1+1) - abs(x1-1)))))\nx2' = x1 - x2 + x3\nx3' = -beta*x2\nx4' = 0",
          hybridEvent: 'abs(x1) >= 1 && x4 == 0 || abs(x1) < 1 && x4 == 1',
          hybridReset: 'x4 = (abs(x1) < 1) ? 0 : 1',
          params: 'alpha=15.6\nbeta=28\nm0=-1.143\nm1=-0.714',
          init: '0.1, 0, 0, 0',
          dt: '0.004',
          steps: '26000',
          transient: '0',
        },
        'Hybrid — Rigid Body with Contact Events': {
          // ω' = I⁻¹(τ − ω×Iω)
          // Reset when collision: ω := R ω or reduce energy
          category: 'hybrid',
          systemType: 'hybrid',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = (tau_x - (x2*I3*x3 - x3*I2*x2))/I1\nx2' = (tau_y - (x3*I1*x1 - x1*I3*x3))/I2\nx3' = (tau_z - (x1*I2*x2 - x2*I1*x1))/I3",
          hybridEvent: 'x1*x1 + x2*x2 + x3*x3 > E_max',
          hybridReset: 'x1 = c_reduce*x1\nx2 = c_reduce*x2\nx3 = c_reduce*x3',
          params: 'I1=1\nI2=0.8\nI3=0.6\ntau_x=0.1\ntau_y=0.05\ntau_z=0.08\nE_max=5\nc_reduce=0.9',
          init: '0.5, 0.3, 0.2',
          dt: '0.01',
          steps: '10000',
          transient: '0',
        },
        'Hybrid — Gradient Flow + Switching Potential': {
          // x' = −∇Uᵩ(x)
          // Switch potential when x reaches boundary: ϕ cycles 1→2→3→1
          // ϕ encoded in x4: 1, 2, or 3
          category: 'hybrid',
          systemType: 'hybrid',
          dim: '4',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = (x4 == 1) ? -2*(x1*x1 + x2*x2 + x3*x3 - 1)*x1 : ((x4 == 2) ? -2*(x1-1) : -2*x1)\nx2' = (x4 == 1) ? -2*(x1*x1 + x2*x2 + x3*x3 - 1)*x2 : ((x4 == 2) ? -2*x2 : -2*(x2-1))\nx3' = (x4 == 1) ? -2*(x1*x1 + x2*x2 + x3*x3 - 1)*x3 : ((x4 == 2) ? -2*x3 : -2*x3)\nx4' = 0",
          hybridEvent: 'x1*x1 + x2*x2 + x3*x3 > 2.5',
          hybridReset: 'x4 = (x4 >= 3) ? 1 : (x4 + 1)',
          params: '',
          init: '0.5, 0.5, 0.5, 1',
          dt: '0.01',
          steps: '2000',
          transient: '0',
        },
        'Hamilton — simple pendulum (q,p)': {
          category: 'hamilton',
          systemType: 'ode',
          dim: '2',
          projX: '1',
          projY: '2',
          projZ: '1',
          // H(q,p)=p^2/2 + (1-cos(q)) => q'=p, p'=-sin(q)
          eqs: "x1' = x2\nx2' = -sin(x1)",
          params: '',
          init: '1.2, 0.0',
          dt: '0.01',
          steps: '11000',
          transient: '2000',
        },
        'Lagrange — Constrained Particle on Sphere (Geodesic on S²)': {
          // L = ½m(ẋ²+ẏ²+ż²) - mgz, constraint: x²+y²+z² = R²
          // Using spherical coordinates: x = R sinθ cosφ, y = R sinθ sinφ, z = R cosθ
          category: 'hamilton',
          systemType: 'ode',
          dim: '4',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x3\nx2' = x4\nx3' = sin(x1)*cos(x1)*x4*x4 - (g/R)*sin(x1)\nx4' = -2*cos(x1)/sin(x1)*x3*x4",
          params: 'g=9.8\nR=1',
          init: 'pi/3, 0, 0, 1',
          dt: '0.01',
          steps: '10000',
          transient: '0',
        },
        'Lagrange — Double Spherical Pendulum (3D)': {
          // Two pendulums in 3D, L = T - V
          // Simplified: two coupled spherical coordinates
          category: 'hamilton',
          systemType: 'ode',
          dim: '6',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x4\nx2' = x5\nx3' = x6\nx4' = sin(x1)*cos(x1)*x5*x5 - (g/L1)*sin(x1) - (m2/m1)*sin(x1-x2)\nx5' = sin(x2)*cos(x2)*x6*x6 - (g/L2)*sin(x2) - (m1/m2)*sin(x2-x1)\nx6' = -2*cos(x2)/sin(x2)*x5*x6",
          params: 'g=9.8\nL1=1\nL2=1\nm1=1\nm2=1',
          init: 'pi/3, pi/4, 0, 0, 0, 0.5',
          dt: '0.01',
          steps: '10000',
          transient: '0',
        },
        'Lagrange — Rigid Body Free Rotation (SO(3))': {
          // L = ½ωᵀIω, Euler equations
          category: 'hamilton',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = (I2 - I3)/I1 * x2 * x3\nx2' = (I3 - I1)/I2 * x3 * x1\nx3' = (I1 - I2)/I3 * x1 * x2",
          params: 'I1=2\nI2=1.5\nI3=1',
          init: '0.5, 0.3, 0.2',
          dt: '0.01',
          steps: '5000',
          transient: '0',
        },
        'Lagrange — Lagrange Top (Spinning Top)': {
          // L = ½(I₁(θ̇²+φ̇²sin²θ) + I₃(ψ̇+φ̇cosθ)²) - Mgl cosθ
          category: 'hamilton',
          systemType: 'ode',
          dim: '6',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x4\nx2' = x5\nx3' = x6\nx4' = sin(x1)*cos(x1)*x5*x5 + (I3/I1)*sin(x1)*x5*x6 - (M*g*l/I1)*sin(x1)\nx5' = -2*cos(x1)/sin(x1)*x4*x5 - (I3/I1)*cos(x1)/sin(x1)*x4*x6\nx6' = (I1 - I3)/I3 * sin(x1)*x4*x5",
          params: 'I1=1\nI3=0.5\nM=1\ng=9.8\nl=0.5',
          init: 'pi/4, 0, 0, 0, 2, 5',
          dt: '0.01',
          steps: '5000',
          transient: '0',
        },
        'Lagrange — Sphere Rolling Without Slipping': {
          // T = ½mv² + ½ωᵀIω, constraint: v = R(ω × n)
          // Simplified: rolling on plane z=0, using constraint to reduce dimensions
          category: 'hamilton',
          systemType: 'ode',
          dim: '5',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x3\nx2' = x4\nx3' = R*x5*x4\nx4' = -R*x5*x3\nx5' = 0",
          params: 'R=1',
          init: '0, 0, 1, 0, 1',
          dt: '0.01',
          steps: '5000',
          transient: '0',
        },
        'Lagrange — 3D Spring–Mass Network': {
          // L = Σ ½mᵢṙᵢ² - Σ ½kᵢⱼ(|rᵢ-rⱼ|-lᵢⱼ)²
          // Simplified: single mass with spring to origin
          category: 'hamilton',
          systemType: 'ode',
          dim: '6',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x4\nx2' = x5\nx3' = x6\nx4' = -k/m*x1\nx5' = -k/m*x2\nx6' = -k/m*x3",
          params: 'k=1\nm=1',
          init: '1, 0, 0, 0, 0, 0',
          dt: '0.01',
          steps: '5000',
          transient: '0',
        },
        'Lagrange — Kepler Problem (3D)': {
          // L = ½mṙ² + GMm/|r|
          category: 'hamilton',
          systemType: 'ode',
          dim: '6',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x4\nx2' = x5\nx3' = x6\nx4' = -GM*x1/(x1*x1 + x2*x2 + x3*x3)^(3/2)\nx5' = -GM*x2/(x1*x1 + x2*x2 + x3*x3)^(3/2)\nx6' = -GM*x3/(x1*x1 + x2*x2 + x3*x3)^(3/2)",
          params: 'GM=1',
          init: '1, 0, 0, 0, 0.8, 0',
          dt: '0.01',
          steps: '5000',
          transient: '0',
        },
        'Lagrange — Magnetic Lorentz Dynamics': {
          // L = ½mṙ² + qṙ·A(r)
          // A = (0, 0, Bx) for uniform B field
          category: 'hamilton',
          systemType: 'ode',
          dim: '6',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x4\nx2' = x5\nx3' = x6\nx4' = q*B/m * x5\nx5' = -q*B/m * x4\nx6' = 0",
          params: 'q=1\nB=1\nm=1',
          init: '0, 0, 0, 1, 0, 0.5',
          dt: '0.01',
          steps: '20000',
          transient: '0',
        },
        'Lagrange — Geodesics on Torus (3D)': {
          // L = ½gᵢⱼq̇ⁱq̇ʲ on torus surface
          // Torus: (R + r cos u) cos v, (R + r cos u) sin v, r sin u
          category: 'hamilton',
          systemType: 'ode',
          dim: '4',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x3\nx2' = x4\nx3' = sin(x1)*cos(x1)*x4*x4/(R + r*cos(x1))\nx4' = -2*r*sin(x1)/(R + r*cos(x1)) * x3*x4",
          params: 'R=2\nr=0.5',
          init: '0, 0, 0.5, 1',
          dt: '0.01',
          steps: '20000',
          transient: '0',
        },
        'Lagrange — Nonlinear Elastic Rod (Cosserat)': {
          // L = T - V, with bending + twisting energy
          // Simplified: 3D rod with curvature
          category: 'hamilton',
          systemType: 'ode',
          dim: '6',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x4\nx2' = x5\nx3' = x6\nx4' = -k_bend/m * x1 - k_twist/m * (x1 - x2)\nx5' = -k_bend/m * x2 - k_twist/m * (x2 - x1)\nx6' = -k_bend/m * x3",
          params: 'k_bend=1\nk_twist=0.5\nm=1',
          init: '0.1, 0, 0, 0, 0, 0',
          dt: '0.01',
          steps: '20000',
          transient: '0',
        },
        'Gradient flow — Rosenbrock (2D)': {
          category: 'optimization',
          systemType: 'ode',
          dim: '2',
          projX: '1',
          projY: '2',
          projZ: '1',
          // f(x,y)=(1-x)^2 + 100(y-x^2)^2 ; x'=-df/dx, y'=-df/dy
          eqs: "x1' = 2*(1-x1) + 400*x1*(x2 - x1^2)\nx2' = -200*(x2 - x1^2)",
          params: '',
          init: '-1.2, 1.0',
          dt: '0.001',
          steps: '20000',
          transient: '0',
        },
        'Gradient Flow — Parabolic Well 3D': {
          // V(x,y,z) = ½(x²+y²+z²)
          // ẋ = -x, ẏ = -y, ż = -z
          category: 'optimization',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = -x1\nx2' = -x2\nx3' = -x3",
          params: '',
          init: '1, 1, 1',
          dt: '0.01',
          steps: '2000',
          transient: '0',
        },
        'Gradient Flow — Double Well Potential 3D': {
          // V(x,y,z) = ¼(x²+y²+z²-1)²
          // ẋ = -(x²+y²+z²-1)x
          category: 'optimization',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = -(x1*x1 + x2*x2 + x3*x3 - 1)*x1\nx2' = -(x1*x1 + x2*x2 + x3*x3 - 1)*x2\nx3' = -(x1*x1 + x2*x2 + x3*x3 - 1)*x3",
          params: '',
          init: '0.5, 0.5, 0.5',
          dt: '0.01',
          steps: '2000',
          transient: '0',
        },
        'Gradient Flow — Mexican Hat / Higgs Potential 3D': {
          // V = ¼(r²-1)² + az², r² = x²+y²
          // Gradient: ẋ = -(r²-1)x, ẏ = -(r²-1)y, ż = -2az
          category: 'optimization',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = -(x1*x1 + x2*x2 - 1)*x1\nx2' = -(x1*x1 + x2*x2 - 1)*x2\nx3' = -2*a*x3",
          params: 'a=0.5',
          init: '0.8, 0, 0.5',
          dt: '0.01',
          steps: '2000',
          transient: '0',
        },
        'Gradient Flow — Rosenbrock 3D': {
          // V(x,y,z) = (1-x)² + 100(y-x²)² + 100(z-y²)²
          // Gradient: ẋ = -∇V
          // ∂V/∂x = -2(1-x) - 400x(y-x²)
          // ∂V/∂y = -200(y-x²) - 400y(z-y²)
          // ∂V/∂z = -200(z-y²)
          category: 'optimization',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = 2*(1-x1) + 400*x1*(x2 - x1*x1)\nx2' = 200*(x2 - x1*x1) + 400*x2*(x3 - x2*x2)\nx3' = 200*(x3 - x2*x2)",
          params: '',
          init: '-1.2, 1.0, 1.0',
          dt: '0.001',
          steps: '2000',
          transient: '0',
        },
        'Gradient Flow — 3D Quadratic + Saddle Mix': {
          // V = x²+y²-z²
          // ẋ = -2x, ẏ = -2y, ż = 2z
          category: 'optimization',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = -2*x1\nx2' = -2*x2\nx3' = 2*x3",
          params: '',
          init: '0.5, 0.5, 0.5',
          dt: '0.01',
          steps: '2000',
          transient: '0',
        },
        'Gradient Flow — Torus Surface (Geodesic damping)': {
          // V(θ,φ) = cosθ + cosφ on torus
          // Torus: (R + r cos u) cos v, (R + r cos u) sin v, r sin u
          // Gradient flow: ẋ = -∇V with damping
          // x1=θ, x2=φ, x3=θ', x4=φ'
          category: 'optimization',
          systemType: 'ode',
          dim: '4',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x3\nx2' = x4\nx3' = sin(x1)/(R + r*cos(x1)) - 0.1*x3\nx4' = sin(x2)/(R + r*cos(x1)) - 0.1*x4",
          params: 'R=2\nr=0.5',
          init: 'pi/4, pi/4, 0, 0',
          dt: '0.01',
          steps: '20000',
          transient: '0',
        },
        'Gradient Flow — Morse Potential 3D': {
          // V = e^(-2r) - 2e^(-r), r = sqrt(x²+y²+z²)
          category: 'optimization',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "r = sqrt(x1*x1 + x2*x2 + x3*x3)\nx1' = -x1/r * (2*exp(-2*r) - 2*exp(-r))\nx2' = -x2/r * (2*exp(-2*r) - 2*exp(-r))\nx3' = -x3/r * (2*exp(-2*r) - 2*exp(-r))",
          params: '',
          init: '1, 0, 0',
          dt: '0.01',
          steps: '20000',
          transient: '0',
        },
        'Gradient Flow — Neural Network Loss Surface 3D': {
          // V(x,y,z) = log(1 + e^(x+y+z))
          category: 'optimization',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = -exp(x1+x2+x3)/(1 + exp(x1+x2+x3))\nx2' = -exp(x1+x2+x3)/(1 + exp(x1+x2+x3))\nx3' = -exp(x1+x2+x3)/(1 + exp(x1+x2+x3))",
          params: '',
          init: '1, 1, 1',
          dt: '0.01',
          steps: '20000',
          transient: '0',
        },
        'Gradient Flow — Gaussian Mixture 3D': {
          // V = -ln(Σᵢ wᵢ e^(-|x-μᵢ|²))
          // Simplified: 2 Gaussians
          // Gradient: ẋ = -∇V = 2*Σᵢ wᵢ*exp(-|x-μᵢ|²)*(x-μᵢ) / (Σᵢ wᵢ*exp(-|x-μᵢ|²) + eps)
          // Using simplified form to avoid division by zero
          category: 'optimization',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = -2*(w1*exp(-((x1-mu1x)^2 + (x2-mu1y)^2 + (x3-mu1z)^2))*(x1-mu1x) + w2*exp(-((x1-mu2x)^2 + (x2-mu2y)^2 + (x3-mu2z)^2))*(x1-mu2x))/(w1*exp(-((x1-mu1x)^2 + (x2-mu1y)^2 + (x3-mu1z)^2)) + w2*exp(-((x1-mu2x)^2 + (x2-mu2y)^2 + (x3-mu2z)^2)) + 1e-10)\nx2' = -2*(w1*exp(-((x1-mu1x)^2 + (x2-mu1y)^2 + (x3-mu1z)^2))*(x2-mu1y) + w2*exp(-((x1-mu2x)^2 + (x2-mu2y)^2 + (x3-mu2z)^2))*(x2-mu2y))/(w1*exp(-((x1-mu1x)^2 + (x2-mu1y)^2 + (x3-mu1z)^2)) + w2*exp(-((x1-mu2x)^2 + (x2-mu2y)^2 + (x3-mu2z)^2)) + 1e-10)\nx3' = -2*(w1*exp(-((x1-mu1x)^2 + (x2-mu1y)^2 + (x3-mu1z)^2))*(x3-mu1z) + w2*exp(-((x1-mu2x)^2 + (x2-mu2y)^2 + (x3-mu2z)^2))*(x3-mu2z))/(w1*exp(-((x1-mu1x)^2 + (x2-mu1y)^2 + (x3-mu1z)^2)) + w2*exp(-((x1-mu2x)^2 + (x2-mu2y)^2 + (x3-mu2z)^2)) + 1e-10)",
          params: 'w1=0.5\nw2=0.5\nmu1x=1\nmu1y=0\nmu1z=0\nmu2x=-1\nmu2y=0\nmu2z=0',
          init: '0.5, 0, 0',
          dt: '0.01',
          steps: '2000',
          transient: '0',
        },
        'Gradient Flow — Allen-Cahn (Discretized 3D)': {
          // u̇ = Δu - f(u), f(u) = u - u³
          // Simplified: 3D field reduced to single point
          category: 'optimization',
          systemType: 'ode',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = -alpha*(x1 - x2) - (x1 - x1*x1*x1)\nx2' = -alpha*(2*x2 - x1 - x3) - (x2 - x2*x2*x2)\nx3' = -alpha*(x3 - x2) - (x3 - x3*x3*x3)",
          params: 'alpha=0.1',
          init: '0.5, -0.5, 0.5',
          dt: '0.01',
          steps: '2000',
          transient: '0',
        },
        'Markov — 3-state distribution (map)': {
          category: 'markov',
          systemType: 'map',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          // x_{n+1} = P x_n (column-vector convention)
          eqs: "x1 = 0.90*x1 + 0.10*x2 + 0.05*x3\nx2 = 0.07*x1 + 0.80*x2 + 0.15*x3\nx3 = 0.03*x1 + 0.10*x2 + 0.80*x3",
          params: '',
          init: '1, 0, 0',
          dt: '1',
          steps: '2000',
          transient: '0',
        },
        'Markov — Brownian Motion 3D (Wiener Process)': {
          // dX_t^(i) = σ dW_t^(i), independent components
          // Pure Brownian motion: drift = 0, only diffusion
          category: 'markov',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '0',
          dy: '0',
          dz: '0',
          params: '',
          init: '0.1, 0.1, 0.1',
          dt: '0.01',
          sigma: '0.5',
          steps: '2000',
          transient: '0',
        },
        'Markov — Ornstein–Uhlenbeck 3D (mean-reverting)': {
          // dX_t = -γ X_t dt + σ dW_t
          category: 'markov',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '-gamma*x',
          dy: '-gamma*y',
          dz: '-gamma*z',
          params: 'gamma=0.5',
          init: '1, 1, 1',
          dt: '0.01',
          sigma: '0.4',
          steps: '2000',
          transient: '0',
        },
        'Markov — 3D Random Walk on Lattice': {
          // X_{n+1} = X_n + ξ_n, where ξ_n is ±1 on each axis
          // Simplified: deterministic symmetric walk
          category: 'markov',
          systemType: 'map',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1 = x1 + 0.1*(x1 - x2)\nx2 = x2 + 0.1*(x2 - x3)\nx3 = x3 + 0.1*(x3 - x1)",
          params: '',
          init: '1, 0.5, 0.2',
          dt: '1',
          steps: '2000',
          transient: '0',
        },
        'Markov — Jump Process on Graph 3D': {
          // State transitions via transition matrix P
          // Simplified: 3-state system with transitions
          category: 'markov',
          systemType: 'map',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1 = 0.7*x1 + 0.2*x2 + 0.1*x3\nx2 = 0.15*x1 + 0.6*x2 + 0.25*x3\nx3 = 0.15*x1 + 0.2*x2 + 0.65*x3",
          params: '',
          init: '1, 0, 0',
          dt: '1',
          steps: '2000',
          transient: '0',
        },
        'Markov — Diffusion on Sphere (Spherical Brownian)': {
          // dX_t = P_{X_t} ∘ dW_t, constrained to S²
          category: 'markov',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '-(x*x + y*y + z*z - 1)*x',
          dy: '-(x*x + y*y + z*z - 1)*y',
          dz: '-(x*x + y*y + z*z - 1)*z',
          params: '',
          init: '1, 0, 0',
          dt: '0.01',
          sigma: '0.2',
          steps: '2000',
          transient: '0',
        },
        'Markov — Langevin Dynamics 3D (underdamped)': {
          // dX_t = V_t dt, dV_t = -γ V_t dt + σ dW_t
          category: 'markov',
          systemType: 'sde',
          dim: '6',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1' = x4\nx2' = x5\nx3' = x6\nx4' = -gamma*x4\nx5' = -gamma*x5\nx6' = -gamma*x6",
          dx: 'x4',
          dy: 'x5',
          dz: 'x6',
          params: 'gamma=0.5',
          init: '0, 0, 0, 1, 0, 0',
          dt: '0.01',
          sigma: '0.3',
          steps: '2000',
          transient: '0',
        },
        'Markov — Metropolis–Hastings Chain 3D': {
          // x' = x + ε, accept with α = min(1, π(x')/π(x))
          // Simplified: random walk with small steps
          category: 'markov',
          systemType: 'map',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1 = x1 + epsilon*(x2 - x1)\nx2 = x2 + epsilon*(x3 - x2)\nx3 = x3 + epsilon*(x1 - x3)",
          params: 'epsilon=0.1',
          init: '1, 0.5, 0.2',
          dt: '1',
          steps: '200',
          transient: '0',
        },
        'Markov — Hidden Markov Model 3D': {
          // Hidden state Z_t, observed position X_t ~ N(μ_{Z_t}, Σ)
          // Simplified: 3-state HMM with 3D observations
          category: 'markov',
          systemType: 'map',
          dim: '4',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1 = 0.7*x1 + 0.2*mu1x + 0.1*mu2x\nx2 = 0.7*x2 + 0.2*mu1y + 0.1*mu2y\nx3 = 0.7*x3 + 0.2*mu1z + 0.1*mu2z\nx4 = x4 + 0.01",
          params: 'mu1x=1\nmu1y=0\nmu1z=0\nmu2x=0\nmu2y=1\nmu2z=0',
          init: '0, 0, 0, 0',
          dt: '1',
          steps: '2000',
          transient: '0',
        },
        'Markov — Continuous-time Jump in 3D Regions': {
          // Each region is a state, exponential waiting times
          // Simplified: discrete approximation with periodic jumps
          category: 'markov',
          systemType: 'map',
          dim: '4',
          projX: '1',
          projY: '2',
          projZ: '3',
          eqs: "x1 = x1 + (x4 > lambda) ? 0.1*(x2 - x1) : 0\nx2 = x2 + (x4 > lambda) ? 0.1*(x3 - x2) : 0\nx3 = x3 + (x4 > lambda) ? 0.1*(x1 - x3) : 0\nx4 = (x4 > lambda) ? 0 : (x4 + 0.1)",
          params: 'lambda=5',
          init: '1, 0.5, 0.2, 0',
          dt: '0.1',
          steps: '200',
          transient: '0',
        },
        'Markov — Stochastic Gradient Flow 3D': {
          // dX_t = -∇V(X_t) dt + σ dW_t
          category: 'markov',
          systemType: 'sde',
          dim: '3',
          projX: '1',
          projY: '2',
          projZ: '3',
          dx: '-(x*x + y*y + z*z - 1)*x',
          dy: '-(x*x + y*y + z*z - 1)*y',
          dz: '-(x*x + y*y + z*z - 1)*z',
          params: '',
          init: '0.5, 0.5, 0.5',
          dt: '0.01',
          sigma: '0.25',
          steps: '2000',
          transient: '0',
        },
        'Custom': {
          dx: 'sigma*(y-x)',
          dy: 'x*(rho-z)-y',
          dz: 'x*y-beta*z',
          params: 'sigma=10\nrho=28\nbeta=8/3',
          init: '0.1, 0.1, 0.1',
          dt: '0.005',
          systemType: 'ode',
          sigma: '0',
          steps: '200000',
          transient: '2000',
        },
      };

      // ---- Saved presets (localStorage) ----
      const CUSTOM_PRESET_KEY = 'Custom';
      const SAVED_PREFIX = 'Saved: ';
      const SAVED_PRESETS_KEY = 'ode_saved_presets_v1';
      const DEFAULT_PRESET_KEY = 'Lorenz (1963) — Edward Lorenz / “butterfly”';
      const DEFAULT_PRESET_BY_TYPE = {
        algebraic: 'Lissajous Knot (parametric)',
        ode_linear: 'Linear ODE — damped oscillator (2D)',
        ode_nonlinear: DEFAULT_PRESET_KEY,
        map: 'Henon map (Hénon 1976) — discrete-time',
        stochastic: 'Noisy Lorenz (SDE) — Lorenz + Gaussian noise',
        pde_linear: 'Heat (2D) — Gaussian blob',
        pde_nonlinear: 'Reaction–Diffusion (2D) — Fisher-KPP',
        dae: 'DAE — x\'=-x+y, 0=y-x^2',
        hybrid: 'Hybrid — Integrate-and-Fire Neuron (v, spike)',
        hamilton: 'Hamilton — simple pendulum (q,p)',
        optimization: 'Gradient flow — Rosenbrock (2D)',
        markov: 'Markov — 3-state distribution (map)',
      };

      function categoryToEngineType(category) {
        const c = String(category || '').trim();
        if (c === 'map') return 'map';
        if (c === 'stochastic') return 'sde';
        if (c === 'algebraic') return 'param'; // currently: explicit parametric curve sampling
        if (c === 'ode_linear' || c === 'ode_nonlinear') return 'ode';
        if (c === 'pde_linear') return 'pde';
        if (c === 'pde_nonlinear') return 'pde';
        if (c === 'dae') return 'dae';
        if (c === 'hybrid') return 'hybrid';
        if (c === 'hamilton') return 'ode';
        if (c === 'optimization') return 'ode';
        if (c === 'markov') return 'map';
        return null; // not implemented yet
      }

      function engineTypeToDefaultCategory(engineType) {
        const t = String(engineType || '').trim();
        if (t === 'map') return 'map';
        if (t === 'sde') return 'stochastic';
        if (t === 'param') return 'algebraic';
        if (t === 'pde') return 'pde_linear';
        if (t === 'dae') return 'dae';
        return 'ode_nonlinear';
      }

      function getPresetCategory(presetObj) {
        // Prefer explicit category; otherwise infer from legacy engine-type field
        const c = String(presetObj?.category || '').trim();
        if (c) return c;
        const t = String(presetObj?.systemType || '').trim();
        return engineTypeToDefaultCategory(t);
      }

      function safeJsonParse(s, fallback) {
        try { return JSON.parse(s); } catch (_) { return fallback; }
      }

      function loadSavedPresetsArray() {
        try {
          const raw = localStorage.getItem(SAVED_PRESETS_KEY);
          const arr = safeJsonParse(raw, []);
          return Array.isArray(arr) ? arr : [];
        } catch (_) {
          return [];
        }
      }

      function saveSavedPresetsArray(arr) {
        try { localStorage.setItem(SAVED_PRESETS_KEY, JSON.stringify(arr)); } catch (_) {}
      }

      function sanitizeSavedName(name) {
        const s = String(name || '').trim();
        // Keep it short and safe for <option> text/value.
        return s.replace(/\s+/g, ' ').slice(0, 80);
      }

      function buildSavedPresetMap() {
        const out = {};
        const saved = loadSavedPresetsArray();
        for (const item of saved) {
          if (!item || typeof item !== 'object') continue;
          const nm = sanitizeSavedName(item.name);
          if (!nm) continue;
          const key = SAVED_PREFIX + nm;
          const category = String(item.category ?? '');
          const systemType = String(item.systemType ?? '');
          out[key] = {
            category,
            dx: String(item.dx ?? ''),
            dy: String(item.dy ?? ''),
            dz: String(item.dz ?? ''),
            eqs: String(item.eqs ?? ''),
            params: String(item.params ?? ''),
            init: String(item.init ?? ''),
            dt: String(item.dt ?? ''),
            absTol: String(item.absTol ?? ''),
            relTol: String(item.relTol ?? ''),
            dtMin: String(item.dtMin ?? ''),
            dtMax: String(item.dtMax ?? ''),
            steps: String(item.steps ?? ''),
            systemType,
            sigma: String(item.sigma ?? ''),
            dim: String(item.dim ?? ''),
            projX: String(item.projX ?? ''),
            projY: String(item.projY ?? ''),
            projZ: String(item.projZ ?? ''),
            // PDE (linear)
            pdeType: String(item.pdeType ?? ''),
            pdeNx: String(item.pdeNx ?? ''),
            pdeNy: String(item.pdeNy ?? ''),
            pdeXMin: String(item.pdeXMin ?? ''),
            pdeXMax: String(item.pdeXMax ?? ''),
            pdeYMin: String(item.pdeYMin ?? ''),
            pdeYMax: String(item.pdeYMax ?? ''),
            pdeAlpha: String(item.pdeAlpha ?? ''),
            pdeBC: String(item.pdeBC ?? ''),
            pdeZScale: String(item.pdeZScale ?? ''),
            pdeU0: String(item.pdeU0 ?? ''),
            pdeSource: String(item.pdeSource ?? ''),
            pdeNonlinear: String(item.pdeNonlinear ?? ''),
            // DAE
            daeIndex: String(item.daeIndex ?? '1'),
            daeNx: String(item.daeNx ?? ''),
            daeF: String(item.daeF ?? ''),
            daeGPos: String(item.daeGPos ?? ''),
            daeG: String(item.daeG ?? ''),
            daeTol: String(item.daeTol ?? ''),
            daeNewtonIters: String(item.daeNewtonIters ?? ''),
            // Algebraic implicit
            algMode: String(item.algMode ?? ''),
            algF: String(item.algF ?? ''),
            algIso: String(item.algIso ?? ''),
            algRes: String(item.algRes ?? ''),
            algXMin: String(item.algXMin ?? ''),
            algXMax: String(item.algXMax ?? ''),
            algYMin: String(item.algYMin ?? ''),
            algYMax: String(item.algYMax ?? ''),
            algZMin: String(item.algZMin ?? ''),
            algZMax: String(item.algZMax ?? ''),
            // Hybrid
            hybridEvent: String(item.hybridEvent ?? ''),
            hybridReset: String(item.hybridReset ?? ''),
          };
        }
        return out;
      }

      let presets = {};

      // ---- Remember solver per category (so ODE-linear vs ODE-nonlinear can differ) ----
      function getSolverPrefsFromCache(settingsCacheObj) {
        const m = settingsCacheObj && typeof settingsCacheObj === 'object' ? settingsCacheObj.solverPrefs : null;
        return (m && typeof m === 'object') ? m : {};
      }
      function saveSolverPrefForCategory(category, solverValue) {
        try {
          const settingsCacheObj = loadSettingsCache();
          const prev = getSolverPrefsFromCache(settingsCacheObj);
          const next = { ...prev, [String(category || '')]: String(solverValue || '') };
          saveSettingsCache({ solverPrefs: next });
        } catch (_) {}
      }
      function restoreSolverPrefForCategory(category) {
        try {
          if (!ui.solver) return;
          const cat = String(category || '');
          const settingsCacheObj = loadSettingsCache();
          const prefs = getSolverPrefsFromCache(settingsCacheObj);
          const want = String(prefs[cat] || '');
          if (!want) return;
          // Only apply if current preset does not explicitly specify a solver.
          const p = presets[ui.preset?.value || ''];
          if (p && p.solver) return;
          // Validate against available <option> values.
          if (Array.from(ui.solver.options).some(o => o.value === want)) ui.solver.value = want;
        } catch (_) {}
      }

      function normalizePreset(p) {
        // Remove run-cache fields from presets so they don't override user run settings.
        if (!p || typeof p !== 'object') return p;
        const out = { ...p };
        delete out.transient;
        delete out.ppf;
        return out;
      }

      function populatePresetDropdown(selectedKey) {
        const prev = selectedKey || ui.preset.value;
        const q = String(ui.presetSearch?.value || '').trim().toLowerCase();
        const wantCategory = String(ui.systemType?.value || 'ode_nonlinear');
        ui.preset.innerHTML = '';
        for (const name of Object.keys(presets)) {
          // Filter by current system type (keep Custom always available)
          if (name !== CUSTOM_PRESET_KEY) {
            const pc = getPresetCategory(presets[name]);
            if (pc !== wantCategory) continue;
          }
          if (q && !name.toLowerCase().includes(q)) continue;
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          ui.preset.appendChild(opt);
        }
        // Restore selection if still visible; otherwise pick the first visible option.
        const hasPrev = !!(prev && presets[prev] && Array.from(ui.preset.options).some(o => o.value === prev));
        if (hasPrev) ui.preset.value = prev;
        else {
          const def = DEFAULT_PRESET_BY_TYPE[wantCategory] || DEFAULT_PRESET_KEY;
          if (presets[def] && Array.from(ui.preset.options).some(o => o.value === def)) ui.preset.value = def;
          else ui.preset.value = ui.preset.options[0]?.value || '';
        }
      }

      function rebuildPresets(selectedKey) {
        const savedMap = buildSavedPresetMap();
        // Builtins first, then saved
        const merged = { ...builtinPresets, ...savedMap };
        // Normalize (strip transient/ppf) without editing the big builtinPresets literal.
        presets = {};
        for (const [k, v] of Object.entries(merged)) presets[k] = normalizePreset(v);
        populatePresetDropdown(selectedKey);
      }

      function setPreset(name) {
        const p = presets[name];
        if (!p) return;
        // Projection defaults: presets may set projX/Y/Z; otherwise auto-reset based on dim.
        const hasProj = (p.projX != null || p.projY != null || p.projZ != null);
        projAuto = !hasProj;
        if (p.projX != null && ui.projX) ui.projX.value = p.projX;
        if (p.projY != null && ui.projY) ui.projY.value = p.projY;
        if (p.projZ != null && ui.projZ) ui.projZ.value = p.projZ;
        if (p.eqs != null && ui.eqs) ui.eqs.value = p.eqs;
        ui.dx.value = String(p.dx ?? '');
        ui.dy.value = String(p.dy ?? '');
        ui.dz.value = String(p.dz ?? '');
        ui.params.value = String(p.params ?? '');
        ui.init.value = String(p.init ?? '');
        ui.dt.value = String(p.dt ?? '');
        if (p.absTol != null && ui.absTol) ui.absTol.value = p.absTol;
        if (p.relTol != null && ui.relTol) ui.relTol.value = p.relTol;
        if (p.dtMin != null && ui.dtMin) ui.dtMin.value = p.dtMin;
        if (p.dtMax != null && ui.dtMax) ui.dtMax.value = p.dtMax;
        ui.steps.value = String(p.steps ?? '');
        // IMPORTANT: "Custom" is a template and should not force-switch categories.
        // Otherwise, saving a custom preset under ODE–Linear can get mislabeled as ODE–Nonlinear.
        if (ui.systemType && name !== CUSTOM_PRESET_KEY) ui.systemType.value = getPresetCategory(p);
        if (p.sigma != null && ui.sigma) ui.sigma.value = p.sigma;
        // PDE (linear)
        if (p.pdeType != null && ui.pdeType) ui.pdeType.value = String(p.pdeType);
        if (p.pdeNx != null && ui.pdeNx) ui.pdeNx.value = String(p.pdeNx);
        if (p.pdeNy != null && ui.pdeNy) ui.pdeNy.value = String(p.pdeNy);
        if (p.pdeXMin != null && ui.pdeXMin) ui.pdeXMin.value = String(p.pdeXMin);
        if (p.pdeXMax != null && ui.pdeXMax) ui.pdeXMax.value = String(p.pdeXMax);
        if (p.pdeYMin != null && ui.pdeYMin) ui.pdeYMin.value = String(p.pdeYMin);
        if (p.pdeYMax != null && ui.pdeYMax) ui.pdeYMax.value = String(p.pdeYMax);
        if (p.pdeAlpha != null && ui.pdeAlpha) ui.pdeAlpha.value = String(p.pdeAlpha);
        if (p.pdeBC != null && ui.pdeBC) ui.pdeBC.value = String(p.pdeBC);
        if (p.pdeZScale != null && ui.pdeZScale) ui.pdeZScale.value = String(p.pdeZScale);
        if (p.pdeU0 != null && ui.pdeU0) ui.pdeU0.value = String(p.pdeU0);
        if (p.pdeSource != null && ui.pdeSource) ui.pdeSource.value = String(p.pdeSource);
        if (p.pdeNonlinear != null && ui.pdeNonlinear) ui.pdeNonlinear.value = String(p.pdeNonlinear);
        // DAE
        if (p.daeIndex != null && ui.daeIndex) ui.daeIndex.value = String(p.daeIndex ?? '1');
        if (p.daeNx != null && ui.daeNx) ui.daeNx.value = String(p.daeNx);
        if (p.daeF != null && ui.daeF) ui.daeF.value = String(p.daeF);
        if (p.daeGPos != null && ui.daeGPos) ui.daeGPos.value = String(p.daeGPos ?? '');
        if (p.daeG != null && ui.daeG) ui.daeG.value = String(p.daeG);
        if (p.daeTol != null && ui.daeTol) ui.daeTol.value = String(p.daeTol);
        if (p.daeNewtonIters != null && ui.daeNewtonIters) ui.daeNewtonIters.value = String(p.daeNewtonIters);
        if (ui.daeIndex) { updateDaeIndexHint(); updateDaeGLabel(); }
        // Hybrid
        if (p.hybridEvent != null && ui.hybridEvent) ui.hybridEvent.value = String(p.hybridEvent);
        if (p.hybridReset != null && ui.hybridReset) ui.hybridReset.value = String(p.hybridReset);
        // Algebraic implicit
        if (p.algMode != null && ui.algMode) ui.algMode.value = String(p.algMode);
        if (p.algF != null && ui.algF) ui.algF.value = String(p.algF);
        if (p.algIso != null && ui.algIso) ui.algIso.value = String(p.algIso);
        if (p.algRes != null && ui.algRes) ui.algRes.value = String(p.algRes);
        if (p.algXMin != null && ui.algXMin) ui.algXMin.value = String(p.algXMin);
        if (p.algXMax != null && ui.algXMax) ui.algXMax.value = String(p.algXMax);
        if (p.algYMin != null && ui.algYMin) ui.algYMin.value = String(p.algYMin);
        if (p.algYMax != null && ui.algYMax) ui.algYMax.value = String(p.algYMax);
        if (p.algZMin != null && ui.algZMin) ui.algZMin.value = String(p.algZMin);
        if (p.algZMax != null && ui.algZMax) ui.algZMax.value = String(p.algZMax);
        // If preset provides vector equations, prefer vector mode
        if (ui.eqMode) {
          const hasVec = !!(p.eqs && String(p.eqs).trim());
          ui.eqMode.value = hasVec ? 'vector' : 'simple';
        }
        syncEqModeUI();
        syncDimAuto();
        syncSystemTypeUI();
      }

      function updatePresetButtons() {
        const selected = ui.preset.value;
        const isCustom = selected === CUSTOM_PRESET_KEY;
        const isSaved = selected.startsWith(SAVED_PREFIX);
        ui.saveCustom.disabled = !isCustom;
        ui.deleteSaved.style.display = isSaved ? 'inline-block' : 'none';
      }

      function getCurrentCustomDraft() {
        const category = ui.systemType?.value ?? 'ode_nonlinear';
        return {
          category,
          systemType: categoryToEngineType(category) || 'ode',
          dim: ui.dim?.value ?? '3',
          projX: ui.projX?.value ?? '1',
          projY: ui.projY?.value ?? '2',
          projZ: ui.projZ?.value ?? '3',
          eqs: ui.eqs?.value ?? '',
          dx: ui.dx.value,
          dy: ui.dy.value,
          dz: ui.dz.value,
          params: ui.params.value,
          init: ui.init.value,
          dt: ui.dt.value,
          sigma: ui.sigma?.value ?? '0',
          absTol: ui.absTol?.value ?? '',
          relTol: ui.relTol?.value ?? '',
          dtMin: ui.dtMin?.value ?? '',
          dtMax: ui.dtMax?.value ?? '',
          steps: ui.steps.value,
          // PDE (linear)
          pdeType: ui.pdeType?.value ?? '',
          pdeNx: ui.pdeNx?.value ?? '',
          pdeNy: ui.pdeNy?.value ?? '',
          pdeXMin: ui.pdeXMin?.value ?? '',
          pdeXMax: ui.pdeXMax?.value ?? '',
          pdeYMin: ui.pdeYMin?.value ?? '',
          pdeYMax: ui.pdeYMax?.value ?? '',
          pdeAlpha: ui.pdeAlpha?.value ?? '',
          pdeBC: ui.pdeBC?.value ?? '',
          pdeZScale: ui.pdeZScale?.value ?? '',
          pdeU0: ui.pdeU0?.value ?? '',
          pdeSource: ui.pdeSource?.value ?? '',
          pdeNonlinear: ui.pdeNonlinear?.value ?? '',
          // DAE
          daeIndex: ui.daeIndex?.value ?? '1',
          daeNx: ui.daeNx?.value ?? '',
          daeF: ui.daeF?.value ?? '',
          daeGPos: ui.daeGPos?.value ?? '',
          daeG: ui.daeG?.value ?? '',
          daeTol: ui.daeTol?.value ?? '',
          daeNewtonIters: ui.daeNewtonIters?.value ?? '',
          // Algebraic implicit
          algMode: ui.algMode?.value ?? '',
          algF: ui.algF?.value ?? '',
          algIso: ui.algIso?.value ?? '',
          algRes: ui.algRes?.value ?? '',
          algXMin: ui.algXMin?.value ?? '',
          algXMax: ui.algXMax?.value ?? '',
          algYMin: ui.algYMin?.value ?? '',
          algYMax: ui.algYMax?.value ?? '',
          algZMin: ui.algZMin?.value ?? '',
          algZMax: ui.algZMax?.value ?? '',
          // Hybrid
          hybridEvent: ui.hybridEvent?.value ?? '',
          hybridReset: ui.hybridReset?.value ?? '',
        };
      }

      function saveCurrentCustomToLocalStorage() {
        if (ui.preset.value !== CUSTOM_PRESET_KEY) return;
        const rawName = prompt('Save Custom preset as name:', 'My Preset');
        const nm = sanitizeSavedName(rawName);
        if (!nm) return;

        const saved = loadSavedPresetsArray();
        const draft = getCurrentCustomDraft();
        const idx = saved.findIndex(p => p && typeof p === 'object' && sanitizeSavedName(p.name) === nm);
        const record = { name: nm, ...draft, updatedAt: new Date().toISOString() };
        if (idx >= 0) saved[idx] = record;
        else saved.push(record);
        saveSavedPresetsArray(saved);

        const key = SAVED_PREFIX + nm;
        rebuildPresets(key);
        setPreset(key);
        updatePresetButtons();
      }

      function deleteSelectedSavedPreset() {
        const selected = ui.preset.value;
        if (!selected.startsWith(SAVED_PREFIX)) return;
        const nm = selected.slice(SAVED_PREFIX.length);
        const ok = confirm(`Delete saved preset "${nm}"?`);
        if (!ok) return;
        const saved = loadSavedPresetsArray();
        const next = saved.filter(p => !(p && typeof p === 'object' && sanitizeSavedName(p.name) === nm));
        saveSavedPresetsArray(next);
        rebuildPresets(CUSTOM_PRESET_KEY);
        setPreset(CUSTOM_PRESET_KEY);
        updatePresetButtons();
      }

      // Populate preset dropdown (builtins + saved from localStorage)
      rebuildPresets(DEFAULT_PRESET_KEY);
      setPreset(ui.preset.value);
      updatePresetButtons();

      // ---- Algebraic: auto-switch preset when algMode changes (remember last per mode) ----
      const ALG_LAST_PARAM_KEY = 'sim_alg_last_preset_param';
      const ALG_LAST_IMPLICIT_KEY = 'sim_alg_last_preset_implicit';
      function getAlgMode() {
        return String(ui.algMode?.value || 'parametric');
      }
      function getAlgLastKey(mode) {
        return (mode === 'implicit') ? ALG_LAST_IMPLICIT_KEY : ALG_LAST_PARAM_KEY;
      }
      function rememberAlgPreset(presetName) {
        try {
          const mode = getAlgMode();
          localStorage.setItem(getAlgLastKey(mode), String(presetName || ''));
        } catch (_) {}
      }
      function isAlgebraicPresetMatching(name, mode) {
        const p = presets[name];
        if (!p) return false;
        if (getPresetCategory(p) !== 'algebraic') return false;
        const pm = String(p.algMode || 'parametric');
        return pm === mode;
      }
      function pickAlgebraicPresetForMode(mode) {
        // 1) use last used for that mode, if still exists
        try {
          const last = localStorage.getItem(getAlgLastKey(mode));
          if (last && isAlgebraicPresetMatching(last, mode)) return last;
        } catch (_) {}
        // 2) fallbacks
        if (mode === 'implicit') {
          if (isAlgebraicPresetMatching('Sphere (implicit)', 'implicit')) return 'Sphere (implicit)';
          // any implicit algebraic preset
          for (const name of Object.keys(presets)) {
            if (isAlgebraicPresetMatching(name, 'implicit')) return name;
          }
        } else {
          if (isAlgebraicPresetMatching('Lissajous Knot (parametric)', 'parametric')) return 'Lissajous Knot (parametric)';
          for (const name of Object.keys(presets)) {
            if (isAlgebraicPresetMatching(name, 'parametric')) return name;
          }
        }
        return ui.preset.value;
      }

      ui.systemType?.addEventListener('change', () => {
        // Switching system type changes which presets are visible.
        populatePresetDropdown(ui.preset.value);
        // If switching to algebraic, keep per-mode last preset (parametric vs implicit).
        if (String(ui.systemType?.value || '') === 'algebraic') {
          const want = pickAlgebraicPresetForMode(getAlgMode());
          if (want && Array.from(ui.preset.options).some(o => o.value === want)) ui.preset.value = want;
        }
        setPreset(ui.preset.value);
        updatePresetButtons();
        syncSystemTypeUI();
      });

      let isLoadingInstanceSettings = false;
      ui.preset.addEventListener('change', () => {
        // Skip preset loading when we're loading instance settings (to avoid overwriting instance values)
        if (isLoadingInstanceSettings) return;
        setPreset(ui.preset.value);
        updatePresetButtons();
        // Remember last algebraic preset per mode
        if (String(ui.systemType?.value || '') === 'algebraic') rememberAlgPreset(ui.preset.value);
      });

      function updateDaeIndexHint() {
        if (!ui.daeIndexHint) return;
        const lang = getCurrentLang();
        const idx = parseInt(ui.daeIndex?.value ?? '1', 10) || 1;
        const hints = {
          vi: {
            1: 'Index-1: g phụ thuộc vào biến đại số y (g(x,y,t) = 0)',
            2: 'Index-2: g chỉ phụ thuộc x (g(x) = 0), cần vi phân 1 lần',
            3: 'Index-3: g chỉ phụ thuộc x (g(x) = 0), cần vi phân 2 lần',
          },
          en: {
            1: 'Index-1: g depends on algebraic variables y (g(x,y,t) = 0)',
            2: 'Index-2: g depends only on x (g(x) = 0), needs 1 differentiation',
            3: 'Index-3: g depends only on x (g(x) = 0), needs 2 differentiations',
          },
        };
        ui.daeIndexHint.textContent = hints[lang]?.[idx] || hints.en[1];
      }

      function updateDaeGLabel() {
        if (!ui.daeGLabel) return;
        const lang = getCurrentLang();
        const idx = parseInt(ui.daeIndex?.value ?? '1', 10) || 1;
        
        // Show/hide position constraint field for index-2/3
        if (ui.daeGPosRow) {
          ui.daeGPosRow.style.display = (idx >= 2) ? '' : 'none';
        }
        
        if (idx === 1) {
          if (ui.daeGLabel) {
            ui.daeGLabel.textContent = (lang === 'vi') 
              ? 'Ràng buộc đại số (Ny dòng): 0 = g(x,y,t)'
              : 'DAE algebraic constraints (Ny lines): 0 = g(x,y,t)';
          }
          if (ui.daeGHint) {
            ui.daeGHint.textContent = (lang === 'vi')
              ? 'g phụ thuộc vào biến đại số y'
              : 'g depends on algebraic variables y';
          }
        } else if (idx === 2) {
          if (ui.daeGLabel) {
            ui.daeGLabel.textContent = (lang === 'vi')
              ? 'Ràng buộc vận tốc dg/dt (Ny dòng): 0 = dg/dt'
              : 'Velocity constraint dg/dt (Ny lines): 0 = dg/dt';
          }
          if (ui.daeGHint) {
            ui.daeGHint.textContent = (lang === 'vi')
              ? 'QUAN TRỌNG: Nhập d²g/dt² (vi phân 2 lần) để có dạng index-1. Ví dụ: g=x1²+x2²-R² → d²g/dt²=2*(x1*x4\'+x2*x5\')+2*(x4²+x5²) với x\'=f(x,lambda)'
              : 'IMPORTANT: Enter d²g/dt² (twice-differentiated) for index-1 form. Example: g=x1²+x2²-R² → d²g/dt²=2*(x1*x4\'+x2*x5\')+2*(x4²+x5²) where x\'=f(x,lambda)';
          }
          if (ui.daeGPosLabel) {
            ui.daeGPosLabel.textContent = (lang === 'vi')
              ? 'Ràng buộc vị trí g(x) = 0 (Ny dòng, tùy chọn)'
              : 'Position constraint g(x) = 0 (Ny lines, optional)';
          }
        } else {
          if (ui.daeGLabel) {
            ui.daeGLabel.textContent = (lang === 'vi')
              ? 'Ràng buộc đã vi phân 2 lần d²g/dt² (Ny dòng): 0 = d²g/dt²'
              : 'Twice-differentiated constraint d²g/dt² (Ny lines): 0 = d²g/dt²';
          }
          if (ui.daeGHint) {
            ui.daeGHint.textContent = (lang === 'vi')
              ? 'QUAN TRỌNG: Nhập d²g/dt² (vi phân 2 lần) để có dạng index-1. Thay x\'\' và x\' bằng f(x,lambda) và f(x,y,t)'
              : 'IMPORTANT: Enter d²g/dt² (twice-differentiated) for index-1 form. Replace x\'\' and x\' with f(x,lambda) and f(x,y,t)';
          }
          if (ui.daeGPosLabel) {
            ui.daeGPosLabel.textContent = (lang === 'vi')
              ? 'Ràng buộc vị trí g(x) = 0 (Ny dòng, tùy chọn)'
              : 'Position constraint g(x) = 0 (Ny lines, optional)';
          }
        }
      }

      ui.daeIndex?.addEventListener('change', () => {
        updateDaeIndexHint();
        updateDaeGLabel();
      });

      ui.presetSearch?.addEventListener('input', () => {
        populatePresetDropdown(ui.preset.value);
        updatePresetButtons();
      });
      ui.saveCustom.addEventListener('click', () => saveCurrentCustomToLocalStorage());
      ui.deleteSaved.addEventListener('click', () => deleteSelectedSavedPreset());

      // ---- Parser ----
      function parseParams(text) {
        const out = {};
        const lines = String(text || '').split(/\r?\n/);
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i].trim();
          if (!line) continue;
          // Remove comments
          line = line.replace(/(#|\/\/).*$/, '').trim();
          if (!line) continue;
          const m = line.match(/^([A-Za-z_]\w*)\s*=\s*(.+)$/);
          if (!m) throw new Error(`Params line ${i + 1}: expected "name = value" but got "${lines[i]}"`);
          const key = m[1];
          const expr = m[2];
          const v = math.evaluate(expr, { ...out, pi: Math.PI, e: Math.E });
          if (typeof v !== 'number' || !Number.isFinite(v)) throw new Error(`Param "${key}" is not a finite number.`);
          out[key] = v;
        }
        return out;
      }

      function parseInit(text) {
        const parts = String(text || '').split(',').map(s => s.trim()).filter(Boolean);
        // N-dim: allow fewer values (pad 0) or more (truncate)
        const n = Math.max(1, parseIntStrict(ui.dim?.value ?? '3', 'Dimension N'));
        const out = new Float64Array(n);
        for (let i = 0; i < n; i++) {
          let v;
          if (i < parts.length) {
            const expr = parts[i];
            // Try to evaluate as expression (supports pi, e, etc.)
            try {
              v = math.evaluate(expr, { pi: Math.PI, e: Math.E });
            } catch (err) {
              // Fallback to Number() for backward compatibility
              v = Number(expr);
            }
          } else {
            v = 0;
          }
          if (typeof v !== 'number' || !Number.isFinite(v)) {
            throw new Error(`Initial value ${i + 1} is not a finite number (got: "${i < parts.length ? parts[i] : '0'}").`);
          }
          out[i] = v;
        }
        return out;
      }

      function parseInitForN(text, n) {
        const parts = String(text || '').split(',').map(s => s.trim()).filter(Boolean);
        const dim = Math.max(1, n | 0);
        const out = new Float64Array(dim);
        for (let i = 0; i < dim; i++) {
          let v;
          if (i < parts.length) {
            const expr = parts[i];
            // Try to evaluate as expression (supports pi, e, etc.)
            try {
              v = math.evaluate(expr, { pi: Math.PI, e: Math.E });
            } catch (err) {
              // Fallback to Number() for backward compatibility
              v = Number(expr);
            }
          } else {
            v = 0;
          }
          if (typeof v !== 'number' || !Number.isFinite(v)) {
            throw new Error(`Initial value ${i + 1} is not a finite number (got: "${i < parts.length ? parts[i] : '0'}").`);
          }
          out[i] = v;
        }
        return out;
      }

      function parseHybridResetRules(text, dim) {
        const lines = String(text || '').split(/\r?\n/).map(s => s.trim()).filter(Boolean);
        const targets = [];
        const exprs = [];
        for (let i = 0; i < lines.length; i++) {
          const raw = lines[i].replace(/(#|\/\/).*$/, '').trim();
          if (!raw) continue;
          const m = raw.match(/^([A-Za-z]\w*)\s*=\s*(.+)$/);
          if (!m) throw new Error(`Hybrid reset line ${i + 1}: expected "x1 = expr" but got "${lines[i]}"`);
          const lhs = m[1];
          const rhs = m[2];
          let idx = null;
          if (/^x\d+$/i.test(lhs)) {
            idx = parseInt(lhs.slice(1), 10) - 1;
          } else if (lhs.toLowerCase() === 'x') idx = 0;
          else if (lhs.toLowerCase() === 'y') idx = 1;
          else if (lhs.toLowerCase() === 'z') idx = 2;
          if (idx == null || !(idx >= 0 && idx < dim)) {
            throw new Error(`Hybrid reset line ${i + 1}: unknown target "${lhs}" (use x1..x${dim}).`);
          }
          targets.push(idx);
          // Compile with mathjs - it supports ternary operators and comparison operators
          try {
            exprs.push(math.compile(rhs));
          } catch (err) {
            throw new Error(`Hybrid reset line ${i + 1}: failed to compile expression "${rhs}": ${err.message}`);
          }
        }
        if (!targets.length) throw new Error('Hybrid reset rules must not be empty.');
        return { targets, exprs };
      }

      function compileHybridEventCondition(text) {
        let expr = String(text || '').trim();
        if (!expr) throw new Error('Event condition must not be empty.');
        
        // Try to compile as-is first (mathjs 11+ might support && and ||)
        try {
          return math.compile(expr);
        } catch (err) {
          // If compilation fails, add logical operator functions and transform
          try {
            // Add and/or functions to math if not already present
            if (typeof math.and === 'undefined' || typeof math.or === 'undefined') {
              math.import({
                'and': function(a, b) { 
                  // Convert to boolean: non-zero is true
                  const va = (typeof a === 'boolean' ? a : (typeof a === 'number' ? a !== 0 : !!a));
                  const vb = (typeof b === 'boolean' ? b : (typeof b === 'number' ? b !== 0 : !!b));
                  return va && vb;
                },
                'or': function(a, b) { 
                  const va = (typeof a === 'boolean' ? a : (typeof a === 'number' ? a !== 0 : !!a));
                  const vb = (typeof b === 'boolean' ? b : (typeof b === 'number' ? b !== 0 : !!b));
                  return va || vb;
                }
              }, { override: true });
            }
            
            // Transform && and || to function calls (handle precedence: && before ||)
            let transformed = expr;
            const orParts = transformed.split(/\s*\|\|\s*/);
            if (orParts.length > 1) {
              // Process each OR part separately for && operations
              const processedParts = orParts.map(part => part.replace(/\s*&&\s*/g, ' and '));
              transformed = processedParts.join(' or ');
            } else {
              transformed = transformed.replace(/\s*&&\s*/g, ' and ');
            }
            
            // Now compile the transformed expression
            return math.compile(transformed);
          } catch (err2) {
            // If transformation also fails, throw original error with helpful message
            throw new Error(`Hybrid event condition compilation failed: ${err.message}`);
          }
        }
      }

      function evalBoolExpr(compiledExpr, tValue, stateArr, dim) {
        fillScopeFromArray(tValue, stateArr, dim);
        const s = runtime.scope;
        let v;
        try { 
          v = compiledExpr.evaluate(s); 
        } catch (err) { 
          // Log error for debugging but return null to indicate failure
          console.warn('Hybrid event evaluation error:', err);
          return null; 
        }
        if (typeof v === 'boolean') return v;
        if (typeof v === 'number') return Number.isFinite(v) ? (v !== 0) : null;
        return null;
      }

      function evalVecAtState(out, tValue, stateArr, dim, compiled) {
        fillScopeFromArray(tValue, stateArr, dim);
        const exprs = compiled.compiled;
        for (let i = 0; i < dim; i++) {
          let v;
          try { v = exprs[i].evaluate(runtime.scope); } catch (_) { return false; }
          if (!isFiniteNumber(v)) return false;
          out[i] = v;
        }
        return true;
      }

      function ensureHybridScratch(dim) {
        const d = dim | 0;
        const hs = runtime.hybrid;
        if (hs._scratchDim === d && hs._scratch) return hs._scratch;
        const scratch = {
          stateA: new Float64Array(d),
          stateB: new Float64Array(d),
          stateLo: new Float64Array(d),
          k1: new Float64Array(d),
          k2: new Float64Array(d),
          k3: new Float64Array(d),
          k4: new Float64Array(d),
          tmp: new Float64Array(d),
        };
        hs._scratchDim = d;
        hs._scratch = scratch;
        return scratch;
      }

      function eulerStepInto(out, state0, t0, h, dim, compiled, scratch) {
        if (!evalVecAtState(scratch.k1, t0, state0, dim, compiled)) return false;
        for (let i = 0; i < dim; i++) out[i] = state0[i] + h * scratch.k1[i];
        return true;
      }

      function rk4StepInto(out, state0, t0, h, dim, compiled, scratch) {
        const k1l = scratch.k1, k2l = scratch.k2, k3l = scratch.k3, k4l = scratch.k4, tmp = scratch.tmp;
        if (!evalVecAtState(k1l, t0, state0, dim, compiled)) return false;
        for (let i = 0; i < dim; i++) tmp[i] = state0[i] + 0.5 * h * k1l[i];
        if (!evalVecAtState(k2l, t0 + 0.5 * h, tmp, dim, compiled)) return false;
        for (let i = 0; i < dim; i++) tmp[i] = state0[i] + 0.5 * h * k2l[i];
        if (!evalVecAtState(k3l, t0 + 0.5 * h, tmp, dim, compiled)) return false;
        for (let i = 0; i < dim; i++) tmp[i] = state0[i] + h * k3l[i];
        if (!evalVecAtState(k4l, t0 + h, tmp, dim, compiled)) return false;
        const h6 = h / 6;
        for (let i = 0; i < dim; i++) out[i] = state0[i] + h6 * (k1l[i] + 2 * k2l[i] + 2 * k3l[i] + k4l[i]);
        return true;
      }

      function integrateInto(out, state0, t0, h, dim, compiled, solver, scratch) {
        const s = String(solver || 'rk4');
        if (s === 'euler') return eulerStepInto(out, state0, t0, h, dim, compiled, scratch);
        return rk4StepInto(out, state0, t0, h, dim, compiled, scratch);
      }

      function applyHybridReset(stateArr, dim) {
        const targets = runtime.hybrid.resetTargets;
        const exprs = runtime.hybrid.resetExprs;
        if (!targets || !exprs) return false;
        fillScopeFromArray(runtime.t, stateArr, dim);
        for (let i = 0; i < targets.length; i++) {
          let v;
          try { 
            v = exprs[i].evaluate(runtime.scope); 
          } catch (err) { 
            // Log error for debugging but return false to indicate failure
            console.warn('Hybrid reset evaluation error:', err);
            return false; 
          }
          // Handle boolean results from ternary operators
          if (typeof v === 'boolean') v = v ? 1 : 0;
          if (!isFiniteNumber(v)) return false;
          stateArr[targets[i]] = v;
        }
        return true;
      }

      function parseIntStrict(text, label) {
        const v = Number(String(text || '').trim());
        if (!Number.isFinite(v)) throw new Error(`${label} is not a number.`);
        const n = Math.floor(v);
        return n;
      }

      function parseFloatStrict(text, label) {
        const v = Number(String(text || '').trim());
        if (!Number.isFinite(v)) throw new Error(`${label} is not a number.`);
        return v;
      }

      function parseFloatExpr(text, label, scope) {
        const s = String(text || '').trim();
        if (!s) throw new Error(`${label} is empty.`);
        try {
          const v = math.evaluate(s, { pi: Math.PI, e: Math.E, ...(scope || {}) });
          if (typeof v !== 'number' || !Number.isFinite(v)) throw new Error('not a finite number');
          return v;
        } catch (err) {
          throw new Error(`${label} is not a number.`);
        }
      }

      function compileSystemEquations() {
        const n = Math.max(1, parseIntStrict(ui.dim?.value ?? '3', 'Dimension N'));

        const stripPrefix = (line) => {
          let s = String(line || '').trim();
          s = s.replace(/(#|\/\/).*$/, '').trim();
          if (!s) return '';
          // If user writes "x1' = ..." or "dx/dt = ..." take RHS
          const eqIdx = s.indexOf('=');
          if (eqIdx >= 0) {
            // IMPORTANT: once we take RHS, do NOT strip leading variables (e.g., "x2")
            // otherwise lines like "x1' = x2" would become empty.
            s = s.slice(eqIdx + 1).trim();
            return s;
          }
          // Also remove leading "d.../dt" patterns if they didn't include '=' (e.g., "dx/dt sigma*(y-x)")
          // IMPORTANT: do NOT strip plain leading variables like "x*(...)".
          s = s.replace(/^d\s*(x\d+|x|y|z)\s*(\/dt)?\s*/i, '').trim();
          return s;
        };

        const eqMode = String(ui.eqMode?.value || 'simple');
        const vecText = (eqMode === 'vector') ? String(ui.eqs?.value || '').trim() : '';
        const compiled = [];

        if (vecText) {
          const lines = vecText.split(/\r?\n/).map(stripPrefix).filter(Boolean);
          if (lines.length < n) throw new Error(`Vector equations need at least ${n} non-empty lines.`);
          for (let i = 0; i < n; i++) compiled.push(math.compile(lines[i]));
          return { n, compiled };
        }

        // Backward-compat: use dx/dy/dz for N=3; for N>3 pad zeros.
        const dx = stripPrefix(ui.dx.value);
        const dy = (n >= 2) ? stripPrefix(ui.dy.value) : '0';
        const dz = (n >= 3) ? stripPrefix(ui.dz.value) : '0';
        if (!dx) throw new Error('dx must not be empty (or provide vector equations).');
        if (n >= 2 && !dy) throw new Error('dy must not be empty (or provide vector equations).');
        if (n >= 3 && !dz) throw new Error('dz must not be empty (or provide vector equations).');
        compiled.push(math.compile(dx), math.compile(dy), math.compile(dz));
        for (let i = 3; i < n; i++) compiled.push(math.compile('0'));
        return { n, compiled };
      }

      function compileDAE() {
        const stripPrefix = (line) => {
          let s = String(line || '').trim();
          s = s.replace(/(#|\/\/).*$/, '').trim();
          if (!s) return '';
          const eqIdx = s.indexOf('=');
          if (eqIdx >= 0) {
            s = s.slice(eqIdx + 1).trim();
            return s;
          }
          // remove leading "0" if user writes "0 g(...)" without '='
          s = s.replace(/^0\s+/, '').trim();
          return s;
        };

        const nx = Math.max(1, parseIntStrict(ui.daeNx?.value ?? '1', 'Nx'));
        const fLines = String(ui.daeF?.value || '').split(/\r?\n/).map(stripPrefix).filter(Boolean);
        if (fLines.length < nx) throw new Error(`DAE: need at least ${nx} non-empty differential lines.`);
        const f = [];
        for (let i = 0; i < nx; i++) f.push(math.compile(fLines[i]));

        const gLines = String(ui.daeG?.value || '').split(/\r?\n/).map(stripPrefix).filter(Boolean);
        const ny = gLines.length;
        if (ny < 1) throw new Error('DAE: need at least 1 algebraic constraint line.');
        const g = [];
        for (let i = 0; i < ny; i++) g.push(math.compile(gLines[i]));

        const dim = nx + ny;
        const tol = parseFloatStrict(ui.daeTol?.value ?? '1e-8', 'Newton tol');
        const maxIters = parseIntStrict(ui.daeNewtonIters?.value ?? '12', 'Newton max iters');
        if (!(tol > 0)) throw new Error('Newton tol must be > 0.');
        if (!(maxIters >= 1)) throw new Error('Newton max iters must be >= 1.');
        return { nx, ny, dim, f, g, tol, maxIters };
      }

      // ---- Multi-instance system ----
      // Instance structure: { id, name, color, visible, runtime, geometry, line, points, material }
      const instances = [];
      let activeInstanceId = null;
      let nextInstanceId = 1;

      function createInstanceGeometry(id, color) {
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.95 });
        const pointsMaterial = new THREE.PointsMaterial({ color: color, size: 0.01, sizeAttenuation: true });
        const line = new THREE.Line(geometry, material);
        const points = new THREE.Points(geometry, pointsMaterial);
        line.visible = true;
        points.visible = false;
        scene.add(line);
        scene.add(points);
        return { geometry, line, points, material, pointsMaterial };
      }

      function removeInstanceGeometry(inst) {
        if (inst.line) scene.remove(inst.line);
        if (inst.points) scene.remove(inst.points);
        if (inst.geometry) inst.geometry.dispose();
        if (inst.material) inst.material.dispose();
        if (inst.pointsMaterial) inst.pointsMaterial.dispose();
      }

      function getInstanceSettingsFromUI() {
        // Get all Model and Run settings from UI
        return {
          systemType: ui.systemType?.value ?? 'ode_nonlinear',
          preset: ui.preset?.value ?? '',
          dim: ui.dim?.value ?? '3',
          dimAuto: ui.dimAuto?.checked ?? true,
          projX: ui.projX?.value ?? '1',
          projY: ui.projY?.value ?? '2',
          projZ: ui.projZ?.value ?? '3',
          eqMode: ui.eqMode?.value ?? 'simple',
          eqs: ui.eqs?.value ?? '',
          dx: ui.dx?.value ?? '',
          dy: ui.dy?.value ?? '',
          dz: ui.dz?.value ?? '',
          params: ui.params?.value ?? '',
          init: ui.init?.value ?? '',
          dt: ui.dt?.value ?? '0.005',
          steps: ui.steps?.value ?? '200000',
          solver: ui.solver?.value ?? 'rk4',
          sigma: ui.sigma?.value ?? '0',
          absTol: ui.absTol?.value ?? '1e-6',
          relTol: ui.relTol?.value ?? '1e-3',
          dtMin: ui.dtMin?.value ?? '1e-6',
          dtMax: ui.dtMax?.value ?? '0.05',
          transient: ui.transient?.value ?? '2000',
          ppf: ui.ppf?.value ?? '1500',
          // PDE
          pdeType: ui.pdeType?.value ?? 'heat2d',
          pdeNx: ui.pdeNx?.value ?? '90',
          pdeNy: ui.pdeNy?.value ?? '90',
          pdeXMin: ui.pdeXMin?.value ?? '-1',
          pdeXMax: ui.pdeXMax?.value ?? '1',
          pdeYMin: ui.pdeYMin?.value ?? '-1',
          pdeYMax: ui.pdeYMax?.value ?? '1',
          pdeAlpha: ui.pdeAlpha?.value ?? '0.25',
          pdeBC: ui.pdeBC?.value ?? 'dirichlet0',
          pdeZScale: ui.pdeZScale?.value ?? '1.0',
          pdeU0: ui.pdeU0?.value ?? '',
          pdeSource: ui.pdeSource?.value ?? '',
          pdeNonlinear: ui.pdeNonlinear?.value ?? '',
          // DAE
          daeIndex: ui.daeIndex?.value ?? '1',
          daeNx: ui.daeNx?.value ?? '1',
          daeF: ui.daeF?.value ?? '',
          daeGPos: ui.daeGPos?.value ?? '',
          daeG: ui.daeG?.value ?? '',
          daeTol: ui.daeTol?.value ?? '1e-8',
          daeNewtonIters: ui.daeNewtonIters?.value ?? '12',
          // Hybrid
          hybridEvent: ui.hybridEvent?.value ?? '',
          hybridReset: ui.hybridReset?.value ?? '',
          // Algebraic
          algMode: ui.algMode?.value ?? 'parametric',
          algF: ui.algF?.value ?? '',
          algIso: ui.algIso?.value ?? '0',
          algRes: ui.algRes?.value ?? '40',
          algXMin: ui.algXMin?.value ?? '-1.5',
          algXMax: ui.algXMax?.value ?? '1.5',
          algYMin: ui.algYMin?.value ?? '-1.5',
          algYMax: ui.algYMax?.value ?? '1.5',
          algZMin: ui.algZMin?.value ?? '-1.5',
          algZMax: ui.algZMax?.value ?? '1.5',
        };
      }

      function loadInstanceSettingsToUI(settings) {
        if (!settings) return;
        isLoadingInstanceSettings = true; // Prevent preset change handler from running
        try {
          // Set systemType first (this will trigger preset dropdown rebuild)
          if (settings.systemType != null && ui.systemType) {
            ui.systemType.value = String(settings.systemType);
            // Trigger change to rebuild preset dropdown
            ui.systemType.dispatchEvent(new Event('change'));
          }
          // Load all instance-specific settings
          if (settings.dim != null && ui.dim) ui.dim.value = String(settings.dim);
        if (settings.dimAuto != null && ui.dimAuto) ui.dimAuto.checked = !!settings.dimAuto;
        if (settings.projX != null && ui.projX) ui.projX.value = String(settings.projX);
        if (settings.projY != null && ui.projY) ui.projY.value = String(settings.projY);
        if (settings.projZ != null && ui.projZ) ui.projZ.value = String(settings.projZ);
        if (settings.eqMode != null && ui.eqMode) ui.eqMode.value = String(settings.eqMode);
        if (settings.eqs != null && ui.eqs) ui.eqs.value = String(settings.eqs);
        if (settings.dx != null && ui.dx) ui.dx.value = String(settings.dx);
        if (settings.dy != null && ui.dy) ui.dy.value = String(settings.dy);
        if (settings.dz != null && ui.dz) ui.dz.value = String(settings.dz);
        if (settings.params != null && ui.params) ui.params.value = String(settings.params);
        if (settings.init != null && ui.init) ui.init.value = String(settings.init);
        if (settings.dt != null && ui.dt) ui.dt.value = String(settings.dt);
        if (settings.steps != null && ui.steps) ui.steps.value = String(settings.steps);
        if (settings.solver != null && ui.solver) ui.solver.value = String(settings.solver);
        if (settings.sigma != null && ui.sigma) ui.sigma.value = String(settings.sigma);
        if (settings.absTol != null && ui.absTol) ui.absTol.value = String(settings.absTol);
        if (settings.relTol != null && ui.relTol) ui.relTol.value = String(settings.relTol);
        if (settings.dtMin != null && ui.dtMin) ui.dtMin.value = String(settings.dtMin);
        if (settings.dtMax != null && ui.dtMax) ui.dtMax.value = String(settings.dtMax);
        if (settings.transient != null && ui.transient) ui.transient.value = String(settings.transient);
        if (settings.ppf != null && ui.ppf) ui.ppf.value = String(settings.ppf);
        // PDE
        if (settings.pdeType != null && ui.pdeType) ui.pdeType.value = String(settings.pdeType);
        if (settings.pdeNx != null && ui.pdeNx) ui.pdeNx.value = String(settings.pdeNx);
        if (settings.pdeNy != null && ui.pdeNy) ui.pdeNy.value = String(settings.pdeNy);
        if (settings.pdeXMin != null && ui.pdeXMin) ui.pdeXMin.value = String(settings.pdeXMin);
        if (settings.pdeXMax != null && ui.pdeXMax) ui.pdeXMax.value = String(settings.pdeXMax);
        if (settings.pdeYMin != null && ui.pdeYMin) ui.pdeYMin.value = String(settings.pdeYMin);
        if (settings.pdeYMax != null && ui.pdeYMax) ui.pdeYMax.value = String(settings.pdeYMax);
        if (settings.pdeAlpha != null && ui.pdeAlpha) ui.pdeAlpha.value = String(settings.pdeAlpha);
        if (settings.pdeBC != null && ui.pdeBC) ui.pdeBC.value = String(settings.pdeBC);
        if (settings.pdeZScale != null && ui.pdeZScale) ui.pdeZScale.value = String(settings.pdeZScale);
        if (settings.pdeU0 != null && ui.pdeU0) ui.pdeU0.value = String(settings.pdeU0);
        if (settings.pdeSource != null && ui.pdeSource) ui.pdeSource.value = String(settings.pdeSource);
        if (settings.pdeNonlinear != null && ui.pdeNonlinear) ui.pdeNonlinear.value = String(settings.pdeNonlinear);
        // DAE
        if (settings.daeIndex != null && ui.daeIndex) ui.daeIndex.value = String(settings.daeIndex);
        if (settings.daeNx != null && ui.daeNx) ui.daeNx.value = String(settings.daeNx);
        if (settings.daeF != null && ui.daeF) ui.daeF.value = String(settings.daeF);
        if (settings.daeGPos != null && ui.daeGPos) ui.daeGPos.value = String(settings.daeGPos);
        if (settings.daeG != null && ui.daeG) ui.daeG.value = String(settings.daeG);
        if (settings.daeTol != null && ui.daeTol) ui.daeTol.value = String(settings.daeTol);
        if (settings.daeNewtonIters != null && ui.daeNewtonIters) ui.daeNewtonIters.value = String(settings.daeNewtonIters);
        // Hybrid
        if (settings.hybridEvent != null && ui.hybridEvent) ui.hybridEvent.value = String(settings.hybridEvent);
        if (settings.hybridReset != null && ui.hybridReset) ui.hybridReset.value = String(settings.hybridReset);
        // Algebraic
        if (settings.algMode != null && ui.algMode) ui.algMode.value = String(settings.algMode);
        if (settings.algF != null && ui.algF) ui.algF.value = String(settings.algF);
        if (settings.algIso != null && ui.algIso) ui.algIso.value = String(settings.algIso);
        if (settings.algRes != null && ui.algRes) ui.algRes.value = String(settings.algRes);
        if (settings.algXMin != null && ui.algXMin) ui.algXMin.value = String(settings.algXMin);
        if (settings.algXMax != null && ui.algXMax) ui.algXMax.value = String(settings.algXMax);
        if (settings.algYMin != null && ui.algYMin) ui.algYMin.value = String(settings.algYMin);
        if (settings.algYMax != null && ui.algYMax) ui.algYMax.value = String(settings.algYMax);
          if (settings.algZMin != null && ui.algZMin) ui.algZMin.value = String(settings.algZMin);
          if (settings.algZMax != null && ui.algZMax) ui.algZMax.value = String(settings.algZMax);
          // Set preset value LAST (without triggering change event due to flag)
          if (settings.preset != null && ui.preset) {
            ui.preset.value = String(settings.preset);
          }
          // Trigger UI updates
          if (ui.daeIndex && typeof updateDaeIndexHint === 'function') {
            updateDaeIndexHint();
            if (typeof updateDaeGLabel === 'function') updateDaeGLabel();
          }
        } finally {
          isLoadingInstanceSettings = false; // Re-enable preset change handler
        }
      }

      function createInstance(name, color, settings) {
        const id = nextInstanceId++;
        const inst = {
          id,
          name: name || `Instance ${id}`,
          color: color || new THREE.Color().setHSL((id * 0.618) % 1, 0.8, 0.6),
          visible: true,
          runtime: null,
          render: createInstanceGeometry(id, color || new THREE.Color().setHSL((id * 0.618) % 1, 0.8, 0.6)),
          settings: settings || getInstanceSettingsFromUI(), // Store settings
        };
        instances.push(inst);
        return inst;
      }

      function removeInstance(id) {
        const idx = instances.findIndex(i => i.id === id);
        if (idx < 0) return;
        const inst = instances[idx];
        if (inst.runtime) {
          // Stop if running
          inst.runtime.running = false;
        }
        removeInstanceGeometry(inst.render);
        instances.splice(idx, 1);
        if (activeInstanceId === id) {
          activeInstanceId = instances.length > 0 ? instances[0].id : null;
          if (activeInstanceId != null) {
            const newActive = instances.find(i => i.id === activeInstanceId);
            if (newActive && newActive.settings) {
              loadInstanceSettingsToUI(newActive.settings);
            }
          }
        }
        updateInstancesUI();
      }

      function cloneRuntimeState(src) {
        // Deep clone runtime state
        const dst = {
          running: src.running,
          solver: src.solver,
          systemType: src.systemType,
          sigma: src.sigma,
          dim: src.dim,
          proj: [...src.proj],
          dt: src.dt,
          h: src.h,
          dtMin: src.dtMin,
          dtMax: src.dtMax,
          absTol: src.absTol,
          relTol: src.relTol,
          maxSteps: src.maxSteps,
          transientSteps: src.transientSteps,
          pointsPerFrame: src.pointsPerFrame,
          params: { ...src.params },
          compiled: src.compiled, // Shared reference (immutable after compile)
          t: src.t,
          stepIndex: src.stepIndex,
          state: new Float64Array(src.state),
          lastGood: new Float64Array(src.lastGood),
          skippedDerivs: src.skippedDerivs,
          rejectedSteps: src.rejectedSteps,
          capacity: 0,
          count: 0,
          positions: null,
          colors: null,
          scope: { ...src.scope },
          pde: {
            type: src.pde.type,
            nx: src.pde.nx,
            ny: src.pde.ny,
            xmin: src.pde.xmin,
            xmax: src.pde.xmax,
            ymin: src.pde.ymin,
            ymax: src.pde.ymax,
            dx: src.pde.dx,
            dy: src.pde.dy,
            alpha: src.pde.alpha,
            bc: src.pde.bc,
            zScale: src.pde.zScale,
            u0: src.pde.u0, // Shared
            source: src.pde.source, // Shared
            sourceIsZero: src.pde.sourceIsZero,
            nonlinear: src.pde.nonlinear, // Shared
            nonlinearIsZero: src.pde.nonlinearIsZero,
            u: src.pde.u ? new Float64Array(src.pde.u) : null,
            uNext: src.pde.uNext ? new Float64Array(src.pde.uNext) : null,
            uMin: src.pde.uMin,
            uMax: src.pde.uMax,
          },
          dae: {
            nx: src.dae.nx,
            ny: src.dae.ny,
            f: src.dae.f, // Shared
            g: src.dae.g, // Shared
            tol: src.dae.tol,
            maxIters: src.dae.maxIters,
          },
          hybrid: {
            cond: src.hybrid.cond, // Shared
            resetTargets: src.hybrid.resetTargets ? [...src.hybrid.resetTargets] : null,
            resetExprs: src.hybrid.resetExprs, // Shared
            maxEventsPerStep: src.hybrid.maxEventsPerStep,
          },
        };
        return dst;
      }

      function resetInstanceGeometry(inst, capacity) {
        if (!inst.render) return;
        inst.runtime.capacity = capacity;
        inst.runtime.count = 0;
        inst.runtime.positions = new Float32Array(capacity * 3);
        inst.runtime.colors = new Float32Array(capacity * 3);
        inst.render.geometry.setAttribute('position', new THREE.BufferAttribute(inst.runtime.positions, 3));
        inst.render.geometry.setAttribute('color', new THREE.BufferAttribute(inst.runtime.colors, 3));
        inst.render.geometry.setDrawRange(0, 0);
      }

      function appendPointFromInstanceState(inst) {
        const rt = inst.runtime;
        if (!rt) return false;
        const _projTmp = [0, 0, 0];
        const n = rt.dim;
        const px = rt.proj[0], py = rt.proj[1], pz = rt.proj[2];
        const s = rt.state;
        _projTmp[0] = s[Math.max(0, Math.min(n - 1, px))] ?? 0;
        _projTmp[1] = s[Math.max(0, Math.min(n - 1, py))] ?? 0;
        _projTmp[2] = s[Math.max(0, Math.min(n - 1, pz))] ?? 0;
        const x = _projTmp[0], y = _projTmp[1], z = _projTmp[2];
        if (!isFiniteNumber(x) || !isFiniteNumber(y) || !isFiniteNumber(z)) return false;
        const i = rt.count;
        if (i >= rt.capacity) return false;
        const p = i * 3;
        rt.positions[p + 0] = x;
        rt.positions[p + 1] = y;
        rt.positions[p + 2] = z;
        // Use instance color instead of gradient
        const c = inst.color;
        rt.colors[p + 0] = c.r;
        rt.colors[p + 1] = c.g;
        rt.colors[p + 2] = c.b;
        rt.count++;
        return true;
      }

      function setActiveInstance(id) {
        // Save current UI to previous active instance
        if (activeInstanceId != null) {
          const prevInst = instances.find(i => i.id === activeInstanceId);
          if (prevInst) {
            prevInst.settings = getInstanceSettingsFromUI();
          }
        }
        // Set new active instance
        activeInstanceId = id;
        // Load settings to UI
        const inst = instances.find(i => i.id === id);
        if (inst && inst.settings) {
          loadInstanceSettingsToUI(inst.settings);
        }
        updateInstancesUI();
      }

      function updateInstancesUI() {
        if (!ui.instancesList) return;
        const lang = getCurrentLang();
        const d = I18N[lang] || I18N.vi;
        const listEl = ui.instancesList;
        listEl.innerHTML = '';
        instances.forEach(inst => {
          const div = document.createElement('div');
          div.style.display = 'flex';
          div.style.alignItems = 'center';
          div.style.gap = '8px';
          div.style.marginBottom = '6px';
          div.style.padding = '6px';
          div.style.borderRadius = '6px';
          const isActive = activeInstanceId === inst.id;
          div.style.background = isActive ? 'rgba(100,150,255,0.2)' : 'rgba(255,255,255,0.05)';
          div.style.border = isActive ? '1px solid rgba(100,150,255,0.5)' : '1px solid transparent';
          div.style.cursor = 'pointer';
          div.onclick = () => setActiveInstance(inst.id);
          const colorBox = document.createElement('div');
          colorBox.style.width = '20px';
          colorBox.style.height = '20px';
          colorBox.style.borderRadius = '4px';
          colorBox.style.background = `rgb(${Math.round(inst.color.r * 255)}, ${Math.round(inst.color.g * 255)}, ${Math.round(inst.color.b * 255)})`;
          const nameSpan = document.createElement('span');
          nameSpan.textContent = inst.name;
          nameSpan.style.flex = '1';
          nameSpan.style.fontSize = '12px';
          const toggleBtn = document.createElement('button');
          toggleBtn.textContent = inst.visible ? '👁' : '🚫';
          toggleBtn.style.padding = '4px 8px';
          toggleBtn.style.fontSize = '11px';
          toggleBtn.title = d.toggleInstance;
          toggleBtn.onclick = (e) => {
            e.stopPropagation(); // Prevent triggering setActiveInstance
            inst.visible = !inst.visible;
            applyRenderMode(); // Apply render mode (which respects inst.visible)
            updateInstancesUI();
          };
          const removeBtn = document.createElement('button');
          removeBtn.textContent = '×';
          removeBtn.style.padding = '4px 8px';
          removeBtn.style.fontSize = '14px';
          removeBtn.title = d.removeInstance;
          removeBtn.onclick = () => removeInstance(inst.id);
          div.appendChild(colorBox);
          div.appendChild(nameSpan);
          div.appendChild(toggleBtn);
          div.appendChild(removeBtn);
          listEl.appendChild(div);
        });
        // Ensure all instances have correct visibility based on render mode
        applyRenderMode();
      }


      // ---- Renderer (dynamic BufferGeometry) ----
      // Legacy single-instance objects (will be replaced by instance system)
      const pathGeometry = new THREE.BufferGeometry();
      const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.95 });
      const pointsMaterial = new THREE.PointsMaterial({ size: 0.01, vertexColors: true, sizeAttenuation: true });
      const pathLine = new THREE.Line(pathGeometry, lineMaterial);
      const pathPoints = new THREE.Points(pathGeometry, pointsMaterial);
      pathLine.visible = true;
      pathPoints.visible = false;
      scene.add(pathLine);
      scene.add(pathPoints);

      // ---- PDE surface (u(x,y) height field) ----
      const pdeSurface = {
        mesh: null,
        geometry: null,
        positions: null,
        colors: null,
        nx: 0,
        ny: 0,
      };

      // ---- Implicit surface (F(x,y,z)=iso) ----
      const implicitSurface = {
        mesh: null,
        geometry: null,
        points: null,
        pointsMaterial: null,
      };

      // ---- Runtime state ----
      let runtime = {
        running: false,
        solver: 'rk4',
        systemType: 'ode', // 'ode' | 'map' | 'sde' | 'param' | 'pde'
        sigma: 0,
        dim: 3,
        proj: [0, 1, 2], // 0-based indices into state
        dt: 0.005, // fixed-step dt OR adaptive initial step size (h0)
        h: 0.005,  // current adaptive step size
        dtMin: 1e-6,
        dtMax: 0.05,
        absTol: 1e-6,
        relTol: 1e-3,
        maxSteps: 200000,
        transientSteps: 2000,
        pointsPerFrame: 1500,
        params: {},
        compiled: null, // { n, compiled: math.CompiledExpression[] }
        t: 0,
        stepIndex: 0,
        state: new Float64Array(3),
        lastGood: new Float64Array(3),
        skippedDerivs: 0,
        rejectedSteps: 0,
        // geometry buffers:
        capacity: 0,
        count: 0,
        positions: null,
        colors: null,
        scope: { 
          x: 0, y: 0, z: 0, t: 0, pi: Math.PI, e: Math.E,
          // MathJS functions
          abs: Math.abs, sin: Math.sin, cos: Math.cos, tan: Math.tan,
          asin: Math.asin, acos: Math.acos, atan: Math.atan, atan2: Math.atan2,
          sinh: Math.sinh, cosh: Math.cosh, tanh: Math.tanh,
          exp: Math.exp, log: Math.log, log10: Math.log10, log2: Math.log2,
          sqrt: Math.sqrt, cbrt: Math.cbrt, pow: Math.pow,
          floor: Math.floor, ceil: Math.ceil, round: Math.round,
          min: Math.min, max: Math.max, sign: Math.sign,
          // MathJS comparison functions
          equal: (a, b) => a == b,
          unequal: (a, b) => a != b,
        },
        // PDE runtime (only when systemType==='pde')
        pde: {
          type: 'heat2d',
          nx: 0,
          ny: 0,
          xmin: -1,
          xmax: 1,
          ymin: -1,
          ymax: 1,
          dx: 0,
          dy: 0,
          alpha: 0.25,
          bc: 'dirichlet0',
          zScale: 1,
          u: null,
          uNext: null,
          u0: null,
          source: null,
          sourceIsZero: true,
          nonlinear: null,
          nonlinearIsZero: true,
          uMin: 0,
          uMax: 0,
        },
        // DAE runtime (only when systemType==='dae')
        dae: {
          nx: 0,
          ny: 0,
          f: null, // math.CompiledExpression[]
          g: null, // math.CompiledExpression[]
          tol: 1e-8,
          maxIters: 12,
        },
        hybrid: {
          cond: null,              // math.CompiledExpression
          resetTargets: null,      // number[]
          resetExprs: null,        // math.CompiledExpression[]
          maxEventsPerStep: 6,
        },
      };
      renderObjectsReady = true;

      function hslToRgb(h, s, l) {
        // h in [0,1]
        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          };
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return [r, g, b];
      }

      function colorForFraction(f) {
        // Early = yellow (~55deg), late = red (~0deg)
        const h = (55 * (1 - f)) / 360;
        const [r, g, b] = hslToRgb(h, 1, 0.55);
        return [r, g, b];
      }

      function resetPathGeometry(capacity) {
        runtime.capacity = capacity;
        runtime.count = 0;
        runtime.positions = new Float32Array(capacity * 3);
        runtime.colors = new Float32Array(capacity * 3);
        pathGeometry.setAttribute('position', new THREE.BufferAttribute(runtime.positions, 3));
        pathGeometry.setAttribute('color', new THREE.BufferAttribute(runtime.colors, 3));
        pathGeometry.setDrawRange(0, 0);
        // Bounding volumes will be computed after we have valid points.
      }

      function disposePdeSurface() {
        if (pdeSurface.mesh) scene.remove(pdeSurface.mesh);
        if (pdeSurface.geometry) pdeSurface.geometry.dispose();
        if (pdeSurface.mesh && pdeSurface.mesh.material) {
          // material can be an array, but we only use a single material here
          pdeSurface.mesh.material.dispose?.();
        }
        pdeSurface.mesh = null;
        pdeSurface.geometry = null;
        pdeSurface.positions = null;
        pdeSurface.colors = null;
        pdeSurface.nx = 0;
        pdeSurface.ny = 0;
      }

      function disposeImplicitSurface() {
        if (implicitSurface.mesh) scene.remove(implicitSurface.mesh);
        if (implicitSurface.points) scene.remove(implicitSurface.points);
        if (implicitSurface.geometry) implicitSurface.geometry.dispose();
        if (implicitSurface.mesh && implicitSurface.mesh.material) {
          implicitSurface.mesh.material.dispose?.();
        }
        if (implicitSurface.pointsMaterial) implicitSurface.pointsMaterial.dispose?.();
        implicitSurface.mesh = null;
        implicitSurface.geometry = null;
        implicitSurface.points = null;
        implicitSurface.pointsMaterial = null;
      }

      function ensurePdeSurfaceGeometry(nx, ny, xmin, xmax, ymin, ymax) {
        const wantNx = Math.max(2, nx | 0);
        const wantNy = Math.max(2, ny | 0);
        if (pdeSurface.geometry && pdeSurface.nx === wantNx && pdeSurface.ny === wantNy) {
          return;
        }
        disposePdeSurface();

        const nVerts = wantNx * wantNy;
        const positions = new Float32Array(nVerts * 3);
        const colors = new Float32Array(nVerts * 3);

        const xSpan = (xmax - xmin);
        const ySpan = (ymax - ymin);
        for (let j = 0; j < wantNy; j++) {
          const y = ymin + (wantNy === 1 ? 0 : (j / (wantNy - 1)) * ySpan);
          for (let i = 0; i < wantNx; i++) {
            const x = xmin + (wantNx === 1 ? 0 : (i / (wantNx - 1)) * xSpan);
            const idx = i + wantNx * j;
            const p = idx * 3;
            positions[p + 0] = x;
            positions[p + 1] = y;
            positions[p + 2] = 0;
            colors[p + 0] = 0.2;
            colors[p + 1] = 0.4;
            colors[p + 2] = 1.0;
          }
        }

        const nTris = (wantNx - 1) * (wantNy - 1) * 2;
        const indices = new Uint16Array(nTris * 3);
        let w = 0;
        for (let j = 0; j < wantNy - 1; j++) {
          for (let i = 0; i < wantNx - 1; i++) {
            const a = i + wantNx * j;
            const b = (i + 1) + wantNx * j;
            const c = i + wantNx * (j + 1);
            const d = (i + 1) + wantNx * (j + 1);
            // two triangles: a-c-b and b-c-d (consistent winding)
            indices[w++] = a; indices[w++] = c; indices[w++] = b;
            indices[w++] = b; indices[w++] = c; indices[w++] = d;
          }
        }

        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geom.setIndex(new THREE.BufferAttribute(indices, 1));
        geom.computeBoundingSphere();

        const mat = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.DoubleSide, transparent: true, opacity: 0.98 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.visible = false;
        scene.add(mesh);

        pdeSurface.mesh = mesh;
        pdeSurface.geometry = geom;
        pdeSurface.positions = positions;
        pdeSurface.colors = colors;
        pdeSurface.nx = wantNx;
        pdeSurface.ny = wantNy;
      }

      function updatePdeSurfaceFromField(nx, ny, u, zScale) {
        if (!pdeSurface.geometry || !pdeSurface.positions || !pdeSurface.colors) return;
        if (!u) return;
        if (pdeSurface.nx !== nx || pdeSurface.ny !== ny) return;

        // min/max for color mapping
        let uMin = Infinity;
        let uMax = -Infinity;
        const n = nx * ny;
        for (let k = 0; k < n; k++) {
          const v = u[k];
          if (v < uMin) uMin = v;
          if (v > uMax) uMax = v;
        }
        if (!Number.isFinite(uMin) || !Number.isFinite(uMax)) { uMin = 0; uMax = 1; }
        const span = (uMax - uMin) || 1;

        for (let k = 0; k < n; k++) {
          const v = u[k];
          const p = k * 3;
          pdeSurface.positions[p + 2] = (Number.isFinite(v) ? v : 0) * zScale;
          const f = Math.max(0, Math.min(1, (v - uMin) / span));
          // blue (240deg) -> red (0deg)
          const h = (240 * (1 - f)) / 360;
          const [r, g, b] = hslToRgb(h, 1, 0.55);
          pdeSurface.colors[p + 0] = r;
          pdeSurface.colors[p + 1] = g;
          pdeSurface.colors[p + 2] = b;
        }

        runtime.pde.uMin = uMin;
        runtime.pde.uMax = uMax;

        pdeSurface.geometry.attributes.position.needsUpdate = true;
        pdeSurface.geometry.attributes.color.needsUpdate = true;
        pdeSurface.geometry.computeBoundingSphere();
      }

      function buildImplicitSurfaceGeometry(exprText, isoValue, bounds, resN, params) {
        const N = Math.max(10, Math.min(140, Math.floor(resN || 40)));
        const xmin = bounds.xmin, xmax = bounds.xmax;
        const ymin = bounds.ymin, ymax = bounds.ymax;
        const zmin = bounds.zmin, zmax = bounds.zmax;
        const f = math.compile(exprText);
        const scope = { ...(params || {}), pi: Math.PI, e: Math.E, t: 0, x: 0, y: 0, z: 0 };

        const dx = (xmax - xmin) / (N - 1);
        const dy = (ymax - ymin) / (N - 1);
        const dz = (zmax - zmin) / (N - 1);

        // Cache scalar field values
        const values = new Float32Array(N * N * N);
        let idx = 0;
        for (let k = 0; k < N; k++) {
          const z = zmin + k * dz;
          scope.z = z;
          for (let j = 0; j < N; j++) {
            const y = ymin + j * dy;
            scope.y = y;
            for (let i = 0; i < N; i++) {
              const x = xmin + i * dx;
              scope.x = x;
              let v = f.evaluate(scope);
              v = (typeof v === 'number' && Number.isFinite(v)) ? v : NaN;
              values[idx++] = v;
            }
          }
        }

        const tetraList = [
          [0, 5, 1, 6],
          [0, 1, 2, 6],
          [0, 2, 3, 6],
          [0, 3, 7, 6],
          [0, 7, 4, 6],
          [0, 4, 5, 6],
        ];
        // cube corner offsets: 0..7
        const cx = [0, 1, 1, 0, 0, 1, 1, 0];
        const cy = [0, 0, 1, 1, 0, 0, 1, 1];
        const cz = [0, 0, 0, 0, 1, 1, 1, 1];

        function vIndex(i, j, k) { return i + N * (j + N * k); }
        function lerpPoint(p1, p2, v1, v2) {
          const t = (isoValue - v1) / (v2 - v1);
          return [
            p1[0] + t * (p2[0] - p1[0]),
            p1[1] + t * (p2[1] - p1[1]),
            p1[2] + t * (p2[2] - p1[2]),
          ];
        }

        // marching tetrahedra edge connections for a tetra (6 edges)
        const tetEdges = [
          [0, 1], [1, 2], [2, 0],
          [0, 3], [1, 3], [2, 3],
        ];

        const positions = [];

        function emitTri(a, b, c) {
          positions.push(a[0], a[1], a[2], b[0], b[1], b[2], c[0], c[1], c[2]);
        }

        for (let k = 0; k < N - 1; k++) {
          for (let j = 0; j < N - 1; j++) {
            for (let i = 0; i < N - 1; i++) {
              // cube corner positions/values
              const p = new Array(8);
              const val = new Array(8);
              for (let c = 0; c < 8; c++) {
                const xi = i + cx[c], yj = j + cy[c], zk = k + cz[c];
                const x = xmin + xi * dx;
                const y = ymin + yj * dy;
                const z = zmin + zk * dz;
                p[c] = [x, y, z];
                val[c] = values[vIndex(xi, yj, zk)];
              }

              // process 6 tetrahedra
              for (const tIdx of tetraList) {
                const tp = [p[tIdx[0]], p[tIdx[1]], p[tIdx[2]], p[tIdx[3]]];
                const tv = [val[tIdx[0]], val[tIdx[1]], val[tIdx[2]], val[tIdx[3]]];
                if (!tv.every(Number.isFinite)) continue;

                const inside = tv.map(v => v <= isoValue);
                const nInside = inside.filter(Boolean).length;
                if (nInside === 0 || nInside === 4) continue;

                // Collect intersection points on edges that cross the iso
                const ip = [];
                for (const [a, b] of tetEdges) {
                  if (inside[a] === inside[b]) continue;
                  ip.push(lerpPoint(tp[a], tp[b], tv[a], tv[b]));
                }

                if (ip.length === 3) {
                  emitTri(ip[0], ip[1], ip[2]);
                } else if (ip.length === 4) {
                  // split quad into 2 tris
                  emitTri(ip[0], ip[1], ip[2]);
                  emitTri(ip[0], ip[2], ip[3]);
                }
              }
            }
          }
        }

        const geom = new THREE.BufferGeometry();
        const posArr = new Float32Array(positions);
        geom.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        geom.computeVertexNormals();
        geom.computeBoundingSphere();
        return geom;
      }

      function buildImplicitSurfaceFromUI() {
        const mode = String(ui.algMode?.value || 'parametric');
        if (mode !== 'implicit') return;
        const fText = String(ui.algF?.value || '').trim();
        if (!fText) throw new Error('Algebraic: F(x,y,z) must not be empty.');
        const iso = parseFloatExpr(ui.algIso?.value ?? '0', 'iso');
        const N = parseIntStrict(ui.algRes?.value ?? '40', 'resolution (N)');
        const xmin = parseFloatExpr(ui.algXMin?.value ?? '-1', 'x min');
        const xmax = parseFloatExpr(ui.algXMax?.value ?? '1', 'x max');
        const ymin = parseFloatExpr(ui.algYMin?.value ?? '-1', 'y min');
        const ymax = parseFloatExpr(ui.algYMax?.value ?? '1', 'y max');
        const zmin = parseFloatExpr(ui.algZMin?.value ?? '-1', 'z min');
        const zmax = parseFloatExpr(ui.algZMax?.value ?? '1', 'z max');
        if (!(xmax > xmin) || !(ymax > ymin) || !(zmax > zmin)) throw new Error('Algebraic bounds must satisfy max > min.');

        const params = parseParams(ui.params.value);
        const geom = buildImplicitSurfaceGeometry(
          fText,
          iso,
          { xmin, xmax, ymin, ymax, zmin, zmax },
          N,
          params
        );

        disposeImplicitSurface();
        const mat = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide, transparent: true, opacity: 0.95 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.visible = true;
        scene.add(mesh);
        // Points view (for render mode = Points)
        const pm = new THREE.PointsMaterial({
          color: 0xffffff,
          size: pointsMaterial.size ?? 0.01,
          sizeAttenuation: true,
          transparent: true,
          opacity: 0.95,
        });
        const pts = new THREE.Points(geom, pm);
        pts.visible = false;
        scene.add(pts);
        implicitSurface.mesh = mesh;
        implicitSurface.geometry = geom;
        implicitSurface.points = pts;
        implicitSurface.pointsMaterial = pm;

        runtime.systemType = 'implicit';
        runtime.running = false;
        runtime.compiled = null;
        runtime.params = params;
        // hide path buffers
        applyRenderMode();
      }

      function resetView() {
        camera.position.set(2.8, 1.9, 3.2);
        controls.target.set(0, 0, 0);
        if (!pointerLocked) controls.update();
        else updateFpTarget();
      }

      function setRunning(r) {
        uiIsRunning = !!r;
        runtime.running = r;
        const d = I18N[getCurrentLang()] || I18N.vi;
        ui.pause.textContent = runtime.running ? d.pause : d.resume;
      }

      function isFiniteNumber(v) {
        return typeof v === 'number' && Number.isFinite(v);
      }

      function isFiniteVec(v) {
        for (let i = 0; i < v.length; i++) if (!isFiniteNumber(v[i])) return false;
        return true;
      }

      function clampIndex1Based(raw, n, fallback1Based) {
        const k = Math.floor(Number(raw));
        if (!Number.isFinite(k)) return fallback1Based;
        const c = Math.max(1, Math.min(n, k));
        return c;
      }

      function getProjectedXYZ(out3) {
        const n = runtime.dim;
        const px = runtime.proj[0], py = runtime.proj[1], pz = runtime.proj[2];
        const s = runtime.state;
        out3[0] = s[Math.max(0, Math.min(n - 1, px))] ?? 0;
        out3[1] = s[Math.max(0, Math.min(n - 1, py))] ?? 0;
        out3[2] = s[Math.max(0, Math.min(n - 1, pz))] ?? 0;
      }

      // ---- Solver ----
      function fillScopeFromState(tValue) {
        const s = runtime.scope;
        s.t = tValue;
        // inject params into scope (flat)
        for (const [k, v] of Object.entries(runtime.params)) s[k] = v;
        const st = runtime.state;
        const n = runtime.dim;
        // x1..xN
        for (let i = 0; i < n; i++) s['x' + (i + 1)] = st[i];
        // legacy aliases
        s.x = n >= 1 ? st[0] : 0;
        s.y = n >= 2 ? st[1] : 0;
        s.z = n >= 3 ? st[2] : 0;
      }

      function fillScopeFromArray(tValue, arr, dim) {
        const s = runtime.scope;
        s.t = tValue;
        for (const [k, v] of Object.entries(runtime.params)) s[k] = v;
        const n = dim | 0;
        for (let i = 0; i < n; i++) s['x' + (i + 1)] = arr[i] ?? 0;
        s.x = n >= 1 ? (arr[0] ?? 0) : 0;
        s.y = n >= 2 ? (arr[1] ?? 0) : 0;
        s.z = n >= 3 ? (arr[2] ?? 0) : 0;
        // Ensure math functions are available (they might be overwritten)
        if (!s.abs) s.abs = Math.abs;
        if (!s.sin) s.sin = Math.sin;
        if (!s.cos) s.cos = Math.cos;
        if (!s.sqrt) s.sqrt = Math.sqrt;
        if (!s.equal) s.equal = (a, b) => a == b;
      }

      function evalVec(out, tValue) {
        if (!runtime.compiled) return false;
        fillScopeFromState(tValue);
        const exprs = runtime.compiled.compiled;
        const n = runtime.dim;
        for (let i = 0; i < n; i++) {
          let v;
          try {
            v = exprs[i].evaluate(runtime.scope);
          } catch (_) {
            runtime.skippedDerivs++;
            return false;
          }
          if (!isFiniteNumber(v)) {
            runtime.skippedDerivs++;
            return false;
          }
          out[i] = v;
        }
        return true;
      }

      // ---- Adaptive embedded Runge–Kutta steppers ----
      const AdaptiveMethods = {
        // Dormand–Prince 5(4)
        dp45: {
          order: 5,
          c: [0, 1/5, 3/10, 4/5, 8/9, 1, 1],
          a: [
            [],
            [1/5],
            [3/40, 9/40],
            [44/45, -56/15, 32/9],
            [19372/6561, -25360/2187, 64448/6561, -212/729],
            [9017/3168, -355/33, 46732/5247, 49/176, -5103/18656],
            [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84],
          ],
          bHigh: [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84, 0],
          bLow:  [5179/57600, 0, 7571/16695, 393/640, -92097/339200, 187/2100, 1/40],
        },
        // Fehlberg 5(4) (RKF45)
        rkf45: {
          order: 5,
          c: [0, 1/4, 3/8, 12/13, 1, 1/2],
          a: [
            [],
            [1/4],
            [3/32, 9/32],
            [1932/2197, -7200/2197, 7296/2197],
            [439/216, -8, 3680/513, -845/4104],
            [-8/27, 2, -3544/2565, 1859/4104, -11/40],
          ],
          bHigh: [16/135, 0, 6656/12825, 28561/56430, -9/50, 2/55],
          bLow:  [25/216, 0, 1408/2565, 2197/4104, -1/5, 0],
        },
        // Bogacki–Shampine 3(2) (RK23)
        bs23: {
          order: 3,
          c: [0, 1/2, 3/4, 1],
          a: [
            [],
            [1/2],
            [0, 3/4],
            [2/9, 1/3, 4/9],
          ],
          bHigh: [2/9, 1/3, 4/9, 0],
          bLow:  [7/24, 1/4, 1/3, 1/8],
        },
        // Cash–Karp 5(4)
        ck45: {
          order: 5,
          c: [0, 1/5, 3/10, 3/5, 1, 7/8],
          a: [
            [],
            [1/5],
            [3/40, 9/40],
            [3/10, -9/10, 6/5],
            [-11/54, 5/2, -70/27, 35/27],
            [1631/55296, 175/512, 575/13824, 44275/110592, 253/4096],
          ],
          bHigh: [37/378, 0, 250/621, 125/594, 0, 512/1771],
          bLow:  [2825/27648, 0, 18575/48384, 13525/55296, 277/14336, 1/4],
        }
      };

      let kStage = [];
      let yTmp = new Float64Array(3);
      let yHigh = new Float64Array(3);
      let yLow = new Float64Array(3);
      let errVec = new Float64Array(3);

      function isAdaptiveSolver(name) {
        return name === 'dp45' || name === 'rkf45' || name === 'bs23' || name === 'ck45';
      }

      function normErrRMSVec(err, scale) {
        let sum = 0;
        const n = err.length;
        for (let i = 0; i < n; i++) {
          const r = err[i] / scale[i];
          sum += r * r;
        }
        return Math.sqrt(sum / Math.max(1, n));
      }

      function stepAdaptiveOnce(methodKey) {
        const method = AdaptiveMethods[methodKey];
        if (!method) return false;

        // If state is non-finite, recover (silent)
        if (!isFiniteVec(runtime.state)) runtime.state.set(runtime.lastGood);

        const safety = 0.9;
        const minFactor = 0.2;
        const maxFactor = 5.0;
        const maxTries = 12;

        let h = Math.max(runtime.dtMin, Math.min(runtime.dtMax, runtime.h || runtime.dt));
        if (!(h > 0)) h = runtime.dt;

        for (let attempt = 0; attempt < maxTries; attempt++) {
          // Stage 0
          const ok0 = evalVec(kStage[0], runtime.t);
          if (!ok0) {
            runtime.rejectedSteps++;
            h = Math.max(runtime.dtMin, h * 0.5);
            if (h <= runtime.dtMin) break;
            continue;
          }

          const sCount = method.c.length;
          let ok = true;
          for (let i = 1; i < sCount; i++) {
            const ai = method.a[i];
            yTmp.set(runtime.state);
            for (let j = 0; j < ai.length; j++) {
              const aij = ai[j];
              const kj = kStage[j];
              for (let d = 0; d < runtime.dim; d++) yTmp[d] += h * aij * kj[d];
            }
            const ti = runtime.t + method.c[i] * h;
            const prev = runtime.state;
            runtime.state = yTmp;
            const okStage = evalVec(kStage[i], ti);
            runtime.state = prev;
            if (!okStage) {
              ok = false;
              break;
            }
          }

          if (!ok) {
            runtime.rejectedSteps++;
            h = Math.max(runtime.dtMin, h * 0.5);
            if (h <= runtime.dtMin) break;
            continue;
          }

          // Combine high/low
          yHigh.set(runtime.state);
          yLow.set(runtime.state);

          for (let i = 0; i < sCount; i++) {
            const bh = method.bHigh[i] || 0;
            const bl = method.bLow[i] || 0;
            const ki = kStage[i];
            for (let d = 0; d < runtime.dim; d++) {
              yHigh[d] += h * bh * ki[d];
              yLow[d]  += h * bl * ki[d];
            }
          }

          for (let d = 0; d < runtime.dim; d++) errVec[d] = yHigh[d] - yLow[d];
          // reuse yTmp as scale buffer
          for (let d = 0; d < runtime.dim; d++) {
            yTmp[d] = runtime.absTol + runtime.relTol * Math.max(Math.abs(runtime.state[d]), Math.abs(yHigh[d]));
          }
          const err = normErrRMSVec(errVec, yTmp);

          if (!Number.isFinite(err)) {
            runtime.rejectedSteps++;
            h = Math.max(runtime.dtMin, h * 0.5);
            if (h <= runtime.dtMin) break;
            continue;
          }

          // Propose new step
          const p = method.order;
          const exp = 1 / (p + 1);
          const factor = err === 0 ? maxFactor : Math.min(maxFactor, Math.max(minFactor, safety * Math.pow(1 / err, exp)));
          const hNew = Math.max(runtime.dtMin, Math.min(runtime.dtMax, h * factor));

          if (err <= 1) {
            // Accept
            runtime.t += h;
            runtime.state.set(yHigh);
            if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
            runtime.h = hNew;
            return true;
          } else {
            // Reject
            runtime.rejectedSteps++;
            h = hNew;
            runtime.h = h;
            continue;
          }
        }

        // If we reach here, we couldn't get a valid step. "Ignore infinite": advance time minimally.
        runtime.skippedDerivs++;
        const adv = Math.max(runtime.dtMin, 1e-9);
        runtime.t += adv;
        runtime.h = Math.max(runtime.dtMin, Math.min(runtime.dtMax, runtime.h || runtime.dt));
        return false;
      }

      let k1 = new Float64Array(3), k2 = new Float64Array(3), k3 = new Float64Array(3), k4 = new Float64Array(3);
      function stepEuler() {
        const dt = runtime.dt;
        if (!isFiniteVec(runtime.state)) runtime.state.set(runtime.lastGood);
        const ok = evalVec(k1, runtime.t);
        if (!ok) {
          runtime.t += dt;
          return;
        }
        for (let d = 0; d < runtime.dim; d++) runtime.state[d] += dt * k1[d];
        if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
        runtime.t += dt;
      }

      // ---- Map (discrete-time) ----
      function stepMap() {
        // Use t as iteration index for convenience
        const t = runtime.t;
        if (!evalVec(k1, t)) { runtime.t += 1; return; }
        runtime.state.set(k1);
        if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
        runtime.t += 1;
      }

      // ---- SDE (Euler–Maruyama, additive noise) ----
      let _randSpare = null;
      function randn() {
        if (_randSpare != null) {
          const v = _randSpare;
          _randSpare = null;
          return v;
        }
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const mag = Math.sqrt(-2.0 * Math.log(u));
        const z0 = mag * Math.cos(2.0 * Math.PI * v);
        const z1 = mag * Math.sin(2.0 * Math.PI * v);
        _randSpare = z1;
        return z0;
      }

      function stepSDEEulerMaruyama() {
        const dt = runtime.dt;
        const sigma = Math.max(0, Number(runtime.sigma) || 0);
        if (!evalVec(k1, runtime.t)) {
          runtime.t += dt;
          return;
        }
        const sdt = Math.sqrt(Math.max(0, dt));
        for (let d = 0; d < runtime.dim; d++) runtime.state[d] += dt * k1[d] + sigma * sdt * randn();
        if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
        runtime.t += dt;
      }

      // ---- Parametric equation (sample curve) ----
      function stepParametric() {
        const dt = runtime.dt;
        // Evaluate x_i(t) and set state directly
        if (!evalVec(k1, runtime.t)) {
          runtime.t += dt;
          return;
        }
        runtime.state.set(k1);
        if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
        runtime.t += dt;
      }

      function stepRK4() {
        const dt = runtime.dt;
        if (!isFiniteVec(runtime.state)) runtime.state.set(runtime.lastGood);
        const y0 = yTmp;
        y0.set(runtime.state);
        if (!evalVec(k1, runtime.t)) { runtime.t += dt; return; }
        for (let d = 0; d < runtime.dim; d++) runtime.state[d] = y0[d] + 0.5 * dt * k1[d];
        if (!evalVec(k2, runtime.t + 0.5 * dt)) { runtime.t += dt; runtime.state.set(y0); return; }
        for (let d = 0; d < runtime.dim; d++) runtime.state[d] = y0[d] + 0.5 * dt * k2[d];
        if (!evalVec(k3, runtime.t + 0.5 * dt)) { runtime.t += dt; runtime.state.set(y0); return; }
        for (let d = 0; d < runtime.dim; d++) runtime.state[d] = y0[d] + dt * k3[d];
        if (!evalVec(k4, runtime.t + dt)) { runtime.t += dt; runtime.state.set(y0); return; }
        for (let d = 0; d < runtime.dim; d++) {
          runtime.state[d] = y0[d] + (dt / 6) * (k1[d] + 2 * k2[d] + 2 * k3[d] + k4[d]);
        }
        if (isFiniteVec(runtime.state)) runtime.lastGood.set(runtime.state);
        runtime.t += dt;
      }

      const _projTmp = [0, 0, 0];
      function appendPointFromState() {
        getProjectedXYZ(_projTmp);
        const x = _projTmp[0], y = _projTmp[1], z = _projTmp[2];
        if (!isFiniteNumber(x) || !isFiniteNumber(y) || !isFiniteNumber(z)) return false;
        const i = runtime.count;
        if (i >= runtime.capacity) return false;
        const p = i * 3;
        runtime.positions[p + 0] = x;
        runtime.positions[p + 1] = y;
        runtime.positions[p + 2] = z;
        const f = runtime.capacity <= 1 ? 1 : (i / (runtime.capacity - 1));
        const [r, g, b] = colorForFraction(f);
        runtime.colors[p + 0] = r;
        runtime.colors[p + 1] = g;
        runtime.colors[p + 2] = b;
        runtime.count++;
        return true;
      }

      function streamSolveChunkForInstance(inst) {
        // Run solver for a specific instance by temporarily swapping runtime
        if (!inst.runtime || !inst.runtime.running || !inst.visible) return;
        const savedRuntime = runtime;
        runtime = inst.runtime; // Swap
        
        try {
          if (runtime.systemType === 'pde') {
            // PDE not supported for instances (use global runtime)
            runtime = savedRuntime;
            return;
          }
          if (runtime.systemType === 'dae') {
            const nx = runtime.dae.nx | 0;
            const ny = runtime.dae.ny | 0;
            const dim = nx + ny;
            if (!(nx >= 1) || !(ny >= 1) || runtime.dim !== dim) {
              runtime = savedRuntime;
              return;
            }
            const f = runtime.dae.f;
            const g = runtime.dae.g;
            if (!f || !g) {
              runtime = savedRuntime;
              return;
            }

            const dt = runtime.dt;
            const perFrame = Math.max(1, runtime.pointsPerFrame | 0);
            const maxSteps = runtime.maxSteps;
            const transient = runtime.transientSteps;

            const fVec = new Float64Array(nx);
            const next = new Float64Array(dim);

            let wrote = 0;
            for (let n = 0; n < perFrame; n++) {
              if (runtime.stepIndex >= maxSteps) {
                runtime.running = false;
                break;
              }

              next.set(runtime.state);
              if (!daeEvalF(fVec, runtime.t, next, dim, f)) {
                runtime.running = false;
                break;
              }
              for (let i = 0; i < nx; i++) next[i] = next[i] + dt * fVec[i];

              const proj = daeProjectY(next, dim, nx, ny, runtime.t + dt, g, runtime.dae.tol, runtime.dae.maxIters);
              if (!proj.ok) {
                runtime.running = false;
                break;
              }

              runtime.state.set(next);
              runtime.lastGood.set(next);
              runtime.t += dt;
              runtime.stepIndex++;

              if (runtime.stepIndex <= transient) continue;
              if (!appendPointFromInstanceState(inst)) continue;
              wrote++;
            }

            if (wrote > 0 && inst.render) {
              inst.render.geometry.setDrawRange(0, runtime.count);
              inst.render.geometry.attributes.position.needsUpdate = true;
              inst.render.geometry.attributes.color.needsUpdate = true;
              inst.render.geometry.computeBoundingSphere();
            }
            runtime = savedRuntime;
            return;
          }
          if (runtime.systemType === 'hybrid') {
            // Hybrid solver for instances
            if (!runtime.compiled || !runtime.hybrid.cond) {
              runtime = savedRuntime;
              return;
            }
            const max = runtime.maxSteps;
            const transient = runtime.transientSteps;
            const perFrame = Math.max(1, runtime.pointsPerFrame | 0);

            let wrote = 0;
            for (let n = 0; n < perFrame; n++) {
              if (runtime.stepIndex >= max) {
                runtime.running = false;
                break;
              }
              const ok = stepHybridOnce();
              runtime.stepIndex++;
              if (!ok) {
                runtime.running = false;
                break;
              }
              if (runtime.stepIndex <= transient) continue;
              if (!appendPointFromInstanceState(inst)) continue;
              wrote++;
            }

            if (wrote > 0 && inst.render) {
              inst.render.geometry.setDrawRange(0, runtime.count);
              inst.render.geometry.attributes.position.needsUpdate = true;
              inst.render.geometry.attributes.color.needsUpdate = true;
              inst.render.geometry.computeBoundingSphere();
            }
            runtime = savedRuntime;
            return;
          }
          if (!runtime.compiled) {
            runtime = savedRuntime;
            return;
          }

        const stepFn = (runtime.systemType === 'map')
          ? stepMap
          : (runtime.systemType === 'sde')
            ? stepSDEEulerMaruyama
            : (runtime.systemType === 'param')
              ? stepParametric
              : ((runtime.solver === 'euler') ? stepEuler
                : isAdaptiveSolver(runtime.solver) ? () => stepAdaptiveOnce(runtime.solver)
                : stepRK4);
        const max = runtime.maxSteps;
        const transient = runtime.transientSteps;
        const perFrame = Math.max(1, runtime.pointsPerFrame | 0);

        let wrote = 0;
        for (let n = 0; n < perFrame; n++) {
          if (runtime.stepIndex >= max) {
              runtime.running = false;
            break;
          }

          stepFn();
          runtime.stepIndex++;

          if (runtime.stepIndex <= transient) continue;
            if (!appendPointFromInstanceState(inst)) continue;
            wrote++;
          }

          if (wrote > 0 && inst.render) {
            inst.render.geometry.setDrawRange(0, runtime.count);
            inst.render.geometry.attributes.position.needsUpdate = true;
            inst.render.geometry.attributes.color.needsUpdate = true;
            inst.render.geometry.computeBoundingSphere();
          }
        } finally {
          runtime = savedRuntime; // Restore
        }
      }

      function streamSolveChunk() {
        // Run global runtime (backward compatibility)
        if (runtime.running) {
          if (runtime.systemType === 'pde') {
            streamSolveChunkPde();
          } else if (runtime.systemType === 'dae') {
            streamSolveChunkDAE();
          } else if (runtime.systemType === 'hybrid') {
            streamSolveChunkHybrid();
          } else if (runtime.compiled) {
            const stepFn = (runtime.systemType === 'map')
              ? stepMap
              : (runtime.systemType === 'sde')
                ? stepSDEEulerMaruyama
                : (runtime.systemType === 'param')
                  ? stepParametric
                  : ((runtime.solver === 'euler') ? stepEuler
                    : isAdaptiveSolver(runtime.solver) ? () => stepAdaptiveOnce(runtime.solver)
                    : stepRK4);
            const max = runtime.maxSteps;
            const transient = runtime.transientSteps;
            const perFrame = Math.max(1, runtime.pointsPerFrame | 0);

            let wrote = 0;
            for (let n = 0; n < perFrame; n++) {
              if (runtime.stepIndex >= max) {
                setRunning(false);
                break;
              }

              stepFn();
              runtime.stepIndex++;

              if (runtime.stepIndex <= transient) continue;
              if (!appendPointFromState()) continue;
          wrote++;
        }

        if (wrote > 0) {
          pathGeometry.setDrawRange(0, runtime.count);
          pathGeometry.attributes.position.needsUpdate = true;
          pathGeometry.attributes.color.needsUpdate = true;
          pathGeometry.computeBoundingSphere();
            }
          }
        }

        // Run all instances
        for (let i = 0; i < instances.length; i++) {
          streamSolveChunkForInstance(instances[i]);
        }
      }

      function resetSimulation() {
        showError('');
        setRunning(false);
        runtime.compiled = null;
        runtime.params = {};
        runtime.t = 0;
        runtime.stepIndex = 0;
        runtime.state = new Float64Array(runtime.dim);
        runtime.lastGood = new Float64Array(runtime.dim);
        runtime.skippedDerivs = 0;
        runtime.rejectedSteps = 0;
        runtime.systemType = 'ode';
        runtime.sigma = 0;
        resetPathGeometry(1);
        // PDE reset
        runtime.pde.u = null;
        runtime.pde.uNext = null;
        runtime.pde.u0 = null;
        runtime.pde.source = null;
        runtime.pde.sourceIsZero = true;
        runtime.pde.nonlinear = null;
        runtime.pde.nonlinearIsZero = true;
        // DAE reset
        runtime.dae.nx = 0;
        runtime.dae.ny = 0;
        runtime.dae.f = null;
        runtime.dae.g = null;
        // Hybrid reset
        runtime.hybrid.cond = null;
        runtime.hybrid.resetTargets = null;
        runtime.hybrid.resetExprs = null;
        // Algebraic implicit reset
        disposeImplicitSurface();
        if (pdeSurface.mesh) pdeSurface.mesh.visible = false;
        applyRenderMode();
      }

      function compilePdeLinearSettings() {
        const type = String(ui.pdeType?.value || 'heat2d');
        if (type !== 'heat2d') throw new Error(`Unsupported PDE type: ${type}`);

        const nx = parseIntStrict(ui.pdeNx?.value ?? '60', 'Nx');
        const ny = parseIntStrict(ui.pdeNy?.value ?? '60', 'Ny');
        if (nx < 2) throw new Error('Nx must be >= 2.');
        if (ny < 2) throw new Error('Ny must be >= 2.');

        const xmin = parseFloatExpr(ui.pdeXMin?.value ?? '-1', 'x min');
        const xmax = parseFloatExpr(ui.pdeXMax?.value ?? '1', 'x max');
        const ymin = parseFloatExpr(ui.pdeYMin?.value ?? '-1', 'y min');
        const ymax = parseFloatExpr(ui.pdeYMax?.value ?? '1', 'y max');
        if (!(xmax > xmin)) throw new Error('Require x max > x min.');
        if (!(ymax > ymin)) throw new Error('Require y max > y min.');

        const alpha = parseFloatExpr(ui.pdeAlpha?.value ?? '0.25', 'alpha');
        if (!(alpha >= 0)) throw new Error('alpha must be >= 0.');

        const bc = String(ui.pdeBC?.value || 'dirichlet0');
        if (!['dirichlet0', 'neumann0', 'periodic'].includes(bc)) throw new Error(`Unknown boundary: ${bc}`);

        const zScale = parseFloatExpr(ui.pdeZScale?.value ?? '1', 'Z scale');
        if (!Number.isFinite(zScale)) throw new Error('Z scale must be a finite number.');

        const u0Text = String(ui.pdeU0?.value || '').trim();
        if (!u0Text) throw new Error('Initial condition u0 must not be empty.');
        const srcTextRaw = String(ui.pdeSource?.value || '').trim();
        const srcText = srcTextRaw ? srcTextRaw : '0';
        const sourceIsZero = !srcTextRaw || srcTextRaw === '0' || srcTextRaw === '0.0';

        const u0 = math.compile(u0Text);
        const source = math.compile(srcText);

        // Nonlinear PDE: optional reaction term N(u,x,y,t)
        const category = String(ui.systemType?.value || 'pde_linear');
        const isNonlinear = category === 'pde_nonlinear';
        const nlTextRaw = String(ui.pdeNonlinear?.value || '').trim();
        const nlText = nlTextRaw ? nlTextRaw : '0';
        const nonlinearIsZero = !isNonlinear || !nlTextRaw || nlTextRaw === '0' || nlTextRaw === '0.0';
        const nonlinear = math.compile(nlText);

        return {
          type, nx, ny, xmin, xmax, ymin, ymax, alpha, bc, zScale,
          u0, source, sourceIsZero,
          isNonlinear, nonlinear, nonlinearIsZero
        };
      }

      function initPdeField() {
        const cfg = compilePdeLinearSettings();
        const params = parseParams(ui.params.value);
        const dt = parseFloatStrict(ui.dt.value, 'dt');
        const steps = parseIntStrict(ui.steps.value, 'steps');
        const ppf = parseIntStrict(ui.ppf.value, 'Iters/frame');

        if (!(dt > 0)) throw new Error('dt must be > 0.');
        if (!(steps > 0)) throw new Error('steps must be > 0.');
        if (!(ppf > 0)) throw new Error('Iters/frame must be > 0.');

        const dx = (cfg.xmax - cfg.xmin) / (cfg.nx - 1);
        const dy = (cfg.ymax - cfg.ymin) / (cfg.ny - 1);

        // Explicit FTCS stability (2D heat): alpha*dt*(1/dx^2 + 1/dy^2) <= 1/2
        // If alpha==0 (pure reaction), skip diffusion CFL.
        if (cfg.alpha > 0) {
          const dtMax = 0.5 / (cfg.alpha * (1 / (dx * dx) + 1 / (dy * dy)));
          if (dt > dtMax) {
            throw new Error(`Stability violated for explicit heat solver.\nSuggested dt <= ${dtMax.toExponential(3)} (current dt=${dt.toExponential(3)}).`);
          }
        }

        ensurePdeSurfaceGeometry(cfg.nx, cfg.ny, cfg.xmin, cfg.xmax, cfg.ymin, cfg.ymax);
        if (pdeSurface.mesh) pdeSurface.mesh.visible = true;

        // Configure runtime
        runtime.systemType = 'pde';
        runtime.compiled = null;
        runtime.params = params;
        runtime.dt = dt;
        runtime.maxSteps = steps;
        runtime.pointsPerFrame = Math.max(1, ppf | 0); // reuse as iterations/frame
        runtime.t = 0;
        runtime.stepIndex = 0;
        runtime.skippedDerivs = 0;
        runtime.rejectedSteps = 0;

        // Update scope with params once
        for (const [k, v] of Object.entries(params)) runtime.scope[k] = v;

        // Setup PDE runtime + field arrays
        runtime.pde.type = cfg.type;
        runtime.pde.nx = cfg.nx;
        runtime.pde.ny = cfg.ny;
        runtime.pde.xmin = cfg.xmin;
        runtime.pde.xmax = cfg.xmax;
        runtime.pde.ymin = cfg.ymin;
        runtime.pde.ymax = cfg.ymax;
        runtime.pde.dx = dx;
        runtime.pde.dy = dy;
        runtime.pde.alpha = cfg.alpha;
        runtime.pde.bc = cfg.bc;
        runtime.pde.zScale = cfg.zScale;
        runtime.pde.u0 = cfg.u0;
        runtime.pde.source = cfg.source;
        runtime.pde.sourceIsZero = cfg.sourceIsZero;
        runtime.pde.nonlinear = cfg.nonlinear;
        runtime.pde.nonlinearIsZero = cfg.nonlinearIsZero;
        runtime.pde.u = new Float64Array(cfg.nx * cfg.ny);
        runtime.pde.uNext = new Float64Array(cfg.nx * cfg.ny);

        const s = runtime.scope;
        s.t = 0;
        s.z = 0;
        s.u = 0;
        for (let j = 0; j < cfg.ny; j++) {
          const y = cfg.ymin + j * dy;
          for (let i = 0; i < cfg.nx; i++) {
            const x = cfg.xmin + i * dx;
            const idx = i + cfg.nx * j;
            s.x = x;
            s.y = y;
            const v = cfg.u0.evaluate(s);
            runtime.pde.u[idx] = (typeof v === 'number' && Number.isFinite(v)) ? v : 0;
          }
        }

        applyRenderMode();

        // Render initial field
        updatePdeSurfaceFromField(cfg.nx, cfg.ny, runtime.pde.u, runtime.pde.zScale);
      }

      function wrapIndex(i, n) {
        const m = i % n;
        return (m < 0) ? (m + n) : m;
      }
      function reflectIndex(i, n) {
        if (i < 0) return -i;
        if (i > n - 1) return 2 * (n - 1) - i;
        return i;
      }

      function pdeSample(u, i, j, nx, ny, bc) {
        if (bc === 'periodic') {
          const ii = wrapIndex(i, nx);
          const jj = wrapIndex(j, ny);
          return u[ii + nx * jj];
        }
        if (bc === 'neumann0') {
          const ii = reflectIndex(i, nx);
          const jj = reflectIndex(j, ny);
          return u[ii + nx * jj];
        }
        // Dirichlet0
        if (i < 0 || i >= nx || j < 0 || j >= ny) return 0;
        return u[i + nx * j];
      }

      function stepPdeHeatOnce() {
        const p = runtime.pde;
        const nx = p.nx;
        const ny = p.ny;
        const u = p.u;
        const un = p.uNext;
        if (!u || !un) return;

        const dt = runtime.dt;
        const alpha = p.alpha;
        const invDx2 = 1 / (p.dx * p.dx);
        const invDy2 = 1 / (p.dy * p.dy);
        const bc = p.bc;
        const s = runtime.scope;
        s.t = runtime.t;
        s.z = 0;

        for (let j = 0; j < ny; j++) {
          const y = p.ymin + j * p.dy;
          for (let i = 0; i < nx; i++) {
            const x = p.xmin + i * p.dx;
            const idx = i + nx * j;
            const c = u[idx];
            const ux = (pdeSample(u, i + 1, j, nx, ny, bc) - 2 * c + pdeSample(u, i - 1, j, nx, ny, bc)) * invDx2;
            const uy = (pdeSample(u, i, j + 1, nx, ny, bc) - 2 * c + pdeSample(u, i, j - 1, nx, ny, bc)) * invDy2;
            let src = 0;
            if (!p.sourceIsZero && p.source) {
              s.x = x; s.y = y;
              const vv = p.source.evaluate(s);
              src = (typeof vv === 'number' && Number.isFinite(vv)) ? vv : 0;
            }
            let nl = 0;
            if (!p.nonlinearIsZero && p.nonlinear) {
              s.x = x; s.y = y; s.u = c;
              const vv = p.nonlinear.evaluate(s);
              nl = (typeof vv === 'number' && Number.isFinite(vv)) ? vv : 0;
            }
            const next = c + dt * (alpha * (ux + uy) + src + nl);
            un[idx] = Number.isFinite(next) ? next : 0;
          }
        }

        if (bc === 'dirichlet0') {
          // enforce boundary u=0
          for (let i = 0; i < nx; i++) {
            un[i + nx * 0] = 0;
            un[i + nx * (ny - 1)] = 0;
          }
          for (let j = 0; j < ny; j++) {
            un[0 + nx * j] = 0;
            un[(nx - 1) + nx * j] = 0;
          }
        }

        // swap buffers
        p.u = un;
        p.uNext = u;
      }

      function streamSolveChunkPde() {
        if (!runtime.running) return;
        if (runtime.systemType !== 'pde') return;
        if (!runtime.pde.u) return;

        // enforce visibility
        applyRenderMode();

        const perFrame = Math.max(1, runtime.pointsPerFrame | 0);
        for (let n = 0; n < perFrame; n++) {
          if (runtime.stepIndex >= runtime.maxSteps) {
            setRunning(false);
            break;
          }
          stepPdeHeatOnce();
          runtime.t += runtime.dt;
          runtime.stepIndex++;
        }
        updatePdeSurfaceFromField(runtime.pde.nx, runtime.pde.ny, runtime.pde.u, runtime.pde.zScale);
      }

      function solveLinearSystemInPlace(A, b, n) {
        // Gaussian elimination with partial pivoting.
        // A: Float64Array length n*n, row-major. b: Float64Array length n.
        const N = n | 0;
        for (let k = 0; k < N; k++) {
          // pivot
          let pivotRow = k;
          let pivotVal = Math.abs(A[k * N + k]);
          for (let i = k + 1; i < N; i++) {
            const v = Math.abs(A[i * N + k]);
            if (v > pivotVal) { pivotVal = v; pivotRow = i; }
          }
          if (!(pivotVal > 0) || !Number.isFinite(pivotVal)) return false;
          if (pivotRow !== k) {
            // swap rows in A and b
            for (let j = k; j < N; j++) {
              const tmp = A[k * N + j];
              A[k * N + j] = A[pivotRow * N + j];
              A[pivotRow * N + j] = tmp;
            }
            const tb = b[k]; b[k] = b[pivotRow]; b[pivotRow] = tb;
          }
          const Akk = A[k * N + k];
          // eliminate
          for (let i = k + 1; i < N; i++) {
            const factor = A[i * N + k] / Akk;
            if (!Number.isFinite(factor)) return false;
            A[i * N + k] = 0;
            for (let j = k + 1; j < N; j++) {
              A[i * N + j] -= factor * A[k * N + j];
            }
            b[i] -= factor * b[k];
          }
        }
        // back substitution
        for (let i = N - 1; i >= 0; i--) {
          let sum = b[i];
          for (let j = i + 1; j < N; j++) sum -= A[i * N + j] * b[j];
          const Aii = A[i * N + i];
          if (!(Math.abs(Aii) > 0) || !Number.isFinite(Aii)) return false;
          b[i] = sum / Aii;
          if (!Number.isFinite(b[i])) return false;
        }
        return true;
      }

      function daeEvalG(out, tValue, stateArr, dim, gCompiled) {
        fillScopeFromArray(tValue, stateArr, dim);
        const s = runtime.scope;
        for (let i = 0; i < out.length; i++) {
          const v = gCompiled[i].evaluate(s);
          out[i] = (typeof v === 'number' && Number.isFinite(v)) ? v : NaN;
        }
        return out.every(Number.isFinite);
      }

      function daeEvalF(out, tValue, stateArr, dim, fCompiled) {
        fillScopeFromArray(tValue, stateArr, dim);
        const s = runtime.scope;
        for (let i = 0; i < out.length; i++) {
          const v = fCompiled[i].evaluate(s);
          out[i] = (typeof v === 'number' && Number.isFinite(v)) ? v : NaN;
        }
        return out.every(Number.isFinite);
      }

      function daeProjectY(stateArr, dim, nx, ny, tValue, gCompiled, tol, maxIters) {
        // Newton solve for y (last ny vars) with x fixed.
        const g = new Float64Array(ny);
        const gPert = new Float64Array(ny);
        const J = new Float64Array(ny * ny);
        const delta = new Float64Array(ny);

        for (let iter = 0; iter < maxIters; iter++) {
          if (!daeEvalG(g, tValue, stateArr, dim, gCompiled)) return { ok: false, iter, reason: 'g eval non-finite' };
          let maxAbs = 0;
          for (let i = 0; i < ny; i++) maxAbs = Math.max(maxAbs, Math.abs(g[i]));
          if (maxAbs <= tol) return { ok: true, iter };

          // numerical Jacobian wrt y
          for (let j = 0; j < ny; j++) {
            const idx = nx + j;
            const y0 = stateArr[idx];
            const eps = 1e-6 * (1 + Math.abs(y0));
            stateArr[idx] = y0 + eps;
            daeEvalG(gPert, tValue, stateArr, dim, gCompiled);
            stateArr[idx] = y0;
            for (let i = 0; i < ny; i++) {
              J[i * ny + j] = (gPert[i] - g[i]) / eps;
            }
          }

          // Solve J * delta = -g
          for (let i = 0; i < ny; i++) delta[i] = -g[i];
          const A = new Float64Array(J); // copy
          const okSolve = solveLinearSystemInPlace(A, delta, ny);
          if (!okSolve) return { ok: false, iter, reason: 'singular Jacobian' };

          // update y
          for (let j = 0; j < ny; j++) {
            const idx = nx + j;
            stateArr[idx] += delta[j];
          }
        }
        return { ok: false, iter: maxIters, reason: 'max iters' };
      }

      function streamSolveChunkDAE() {
        if (!runtime.running) return;
        const nx = runtime.dae.nx | 0;
        const ny = runtime.dae.ny | 0;
        const dim = nx + ny;
        if (!(nx >= 1) || !(ny >= 1) || runtime.dim !== dim) return;
        const f = runtime.dae.f;
        const g = runtime.dae.g;
        if (!f || !g) return;

        const dt = runtime.dt;
        const perFrame = Math.max(1, runtime.pointsPerFrame | 0);
        const maxSteps = runtime.maxSteps;
        const transient = runtime.transientSteps;

        const fVec = new Float64Array(nx);
        const next = new Float64Array(dim);

        let wrote = 0;
        for (let n = 0; n < perFrame; n++) {
          if (runtime.stepIndex >= maxSteps) { setRunning(false); break; }

          next.set(runtime.state);
          if (!daeEvalF(fVec, runtime.t, next, dim, f)) {
            setRunning(false);
            showError('DAE error: non-finite f(x,y,t).');
            break;
          }
          // Euler step on x
          for (let i = 0; i < nx; i++) next[i] = next[i] + dt * fVec[i];

          // Project y via constraints at t+dt
          const proj = daeProjectY(next, dim, nx, ny, runtime.t + dt, g, runtime.dae.tol, runtime.dae.maxIters);
          if (!proj.ok) {
            setRunning(false);
            showError(`DAE Newton failed (${proj.reason}) at step ${runtime.stepIndex}.\nTry: smaller dt, better initial guess, or simpler constraints.`);
            break;
          }

          runtime.state.set(next);
          runtime.lastGood.set(next);
          runtime.t += dt;
          runtime.stepIndex++;

          if (runtime.stepIndex <= transient) continue;
          if (!appendPointFromState()) continue;
          wrote++;
        }

        if (wrote > 0) {
          pathGeometry.setDrawRange(0, runtime.count);
          pathGeometry.attributes.position.needsUpdate = true;
          pathGeometry.attributes.color.needsUpdate = true;
          pathGeometry.computeBoundingSphere();
        }
      }

      function stepHybridOnce() {
        const dim = runtime.dim;
        const compiled = runtime.compiled;
        const cond = runtime.hybrid.cond;
        if (!compiled || !cond) return false;
        const maxEvents = runtime.hybrid.maxEventsPerStep | 0;
        const scratch = ensureHybridScratch(dim);

        let remaining = runtime.dt;
        let events = 0;
        // Use scratch buffers for sub-stepping (no allocations)
        scratch.stateA.set(runtime.state);
        let state = scratch.stateA;
        let t0 = runtime.t;

        // If we start already in triggered region, reset immediately (no time consumed)
        for (let guard = 0; guard < 3; guard++) {
          const c0 = evalBoolExpr(cond, t0, state, dim);
          if (c0 == null) return false;
          if (!c0) break;
          if (!applyHybridReset(state, dim)) return false;
        }

        while (remaining > 0) {
          if (events > maxEvents) return false;
          const cStart = evalBoolExpr(cond, t0, state, dim);
          if (cStart == null) return false;
          if (cStart) {
            // shouldn't happen often due to guard above, but handle safely
            if (!applyHybridReset(state, dim)) return false;
            events++;
            continue;
          }

          if (!integrateInto(scratch.stateB, state, t0, remaining, dim, compiled, runtime.solver, scratch)) return false;
          const cEnd = evalBoolExpr(cond, t0 + remaining, scratch.stateB, dim);
          if (cEnd == null) return false;
          if (!cEnd) {
            // no event in this remainder
            // swap A/B
            const tmpS = state;
            state = scratch.stateB;
            scratch.stateB = tmpS;
            t0 = t0 + remaining;
            remaining = 0;
            break;
          }

          // Event crossing: find time within (0, remaining] via bisection
          let lo = 0;
          let hi = remaining;
          scratch.stateLo.set(state);
          for (let it = 0; it < 28; it++) {
            const mid = 0.5 * (lo + hi);
            if (!integrateInto(scratch.stateB, state, t0, mid, dim, compiled, runtime.solver, scratch)) return false;
            const cMid = evalBoolExpr(cond, t0 + mid, scratch.stateB, dim);
            if (cMid == null) return false;
            if (cMid) {
              hi = mid;
            } else {
              lo = mid;
              scratch.stateLo.set(scratch.stateB);
            }
            if (hi - lo < Math.max(1e-6, 1e-3 * remaining)) break;
          }

          // Advance to event time ~hi
          if (!integrateInto(scratch.stateB, state, t0, hi, dim, compiled, runtime.solver, scratch)) return false;
          t0 = t0 + hi;
          remaining = remaining - hi;
          // swap
          const tmpS2 = state;
          state = scratch.stateB;
          scratch.stateB = tmpS2;

          // Apply reset instantly at event time
          runtime.t = t0; // for scope evaluation inside reset
          if (!applyHybridReset(state, dim)) return false;
          events++;
        }

        runtime.state.set(state);
        runtime.lastGood.set(state);
        runtime.t = t0;
        return true;
      }

      function streamSolveChunkHybrid() {
        if (!runtime.running) return;
        if (!runtime.compiled || !runtime.hybrid.cond) return;
        const max = runtime.maxSteps;
        const transient = runtime.transientSteps;
        const perFrame = Math.max(1, runtime.pointsPerFrame | 0);

        let wrote = 0;
        for (let n = 0; n < perFrame; n++) {
          if (runtime.stepIndex >= max) { setRunning(false); break; }
          const ok = stepHybridOnce();
          runtime.stepIndex++;
          if (!ok) {
            setRunning(false);
            showError('Hybrid error: event/reset evaluation failed. Check condition/reset expressions and dt.');
            break;
          }
          if (runtime.stepIndex <= transient) continue;
          if (!appendPointFromState()) continue;
          wrote++;
        }

        if (wrote > 0) {
          pathGeometry.setDrawRange(0, runtime.count);
          pathGeometry.attributes.position.needsUpdate = true;
          pathGeometry.attributes.color.needsUpdate = true;
          pathGeometry.computeBoundingSphere();
        }
      }

      function startSimulation(skipSaveSettings = false) {
        try {
          showError('');
          
          // If no instances exist, create one automatically
          if (instances.length === 0) {
            const settings = getInstanceSettingsFromUI();
            const newInst = createInstance(null, null, settings);
            setActiveInstance(newInst.id);
          }
          
          // Save current UI settings to active instance (if any) - skip in sync mode
          if (!skipSaveSettings) {
            if (activeInstanceId != null) {
              const activeInst = instances.find(i => i.id === activeInstanceId);
              if (activeInst) {
                activeInst.settings = getInstanceSettingsFromUI();
              }
            } else {
              // No active instance: create new one from current UI settings
              const settings = getInstanceSettingsFromUI();
              const newInst = createInstance(null, null, settings);
              setActiveInstance(newInst.id);
              // Note: setActiveInstance() already loads settings to UI, but since we just created
              // the instance with the current UI settings, they're already in sync
            }
          }
          
          // If we previously built an implicit surface, dispose it when starting other modes.
          if (runtime.systemType === 'implicit') {
            disposeImplicitSurface();
            runtime.systemType = 'param';
            applyRenderMode();
          }
          const category = String(ui.systemType?.value || 'ode_nonlinear');
          const systemType = categoryToEngineType(category);
          if (!systemType) throw new Error(`This category is not implemented yet: ${category}`);
          if (category === 'algebraic' && String(ui.algMode?.value || 'parametric') === 'implicit') {
            buildImplicitSurfaceFromUI();
            showNotice('Built implicit surface mesh.');
            setRunning(false);
            return;
          }
          if (systemType === 'pde') {
            initPdeField();
            setRunning(true);
            return;
          }
          if (systemType === 'hybrid') {
            syncDimAuto();
            const compiled = compileSystemEquations();
            const params = parseParams(ui.params.value);
            const initState = parseInit(ui.init.value);
            const dt = parseFloatStrict(ui.dt.value, 'dt');
            const steps = parseIntStrict(ui.steps.value, 'steps');
            const transient = parseIntStrict(ui.transient.value, 'transient');
            const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');
            if (!(dt > 0)) throw new Error('dt must be > 0.');
            if (!(steps > 10)) throw new Error('steps must be > 10.');
            if (!(transient >= 0)) throw new Error('transient must be >= 0.');
            if (transient >= steps) throw new Error('transient must be < steps.');
            if (!(ppf > 0)) throw new Error('Points/frame must be > 0.');

            const condText = String(ui.hybridEvent?.value || '').trim();
            if (!condText) throw new Error('Hybrid: event condition must not be empty.');
            const cond = compileHybridEventCondition(condText);
            const rr = parseHybridResetRules(ui.hybridReset?.value || '', compiled.n);

            runtime.systemType = 'hybrid';
            runtime.compiled = compiled;
            runtime.params = params;
            runtime.dim = compiled.n;
            runtime.dt = dt;
            runtime.maxSteps = steps;
            runtime.transientSteps = transient;
            runtime.pointsPerFrame = Math.max(1, ppf);
            runtime.t = 0;
            runtime.stepIndex = 0;
            runtime.skippedDerivs = 0;
            runtime.rejectedSteps = 0;
            runtime.state = initState;
            runtime.lastGood = new Float64Array(runtime.dim);
            runtime.lastGood.set(initState);

            runtime.hybrid.cond = cond;
            runtime.hybrid.resetTargets = rr.targets;
            runtime.hybrid.resetExprs = rr.exprs;

            // Hybrid supports fixed-step only
            runtime.solver = (String(ui.solver?.value || 'rk4') === 'euler') ? 'euler' : 'rk4';

            const px = clampIndex1Based(ui.projX?.value ?? '1', runtime.dim, 1) - 1;
            const py = clampIndex1Based(ui.projY?.value ?? '2', runtime.dim, Math.min(2, runtime.dim)) - 1;
            const pz = clampIndex1Based(ui.projZ?.value ?? '3', runtime.dim, Math.min(3, runtime.dim)) - 1;
            runtime.proj = [px, py, pz];

            resetPathGeometry(Math.max(1, steps - transient));
            appendPointFromState();
            pathGeometry.setDrawRange(0, runtime.count);
            pathGeometry.attributes.position.needsUpdate = true;
            pathGeometry.attributes.color.needsUpdate = true;
            pathGeometry.computeBoundingSphere();

            applyRenderMode();
            setRunning(true);
            // Runtime is created, now create instance runtime from it
            if (activeInstanceId != null) {
              const activeInst = instances.find(i => i.id === activeInstanceId);
              if (activeInst) {
                activeInst.runtime = cloneRuntimeState(runtime);
                const capacity = Math.max(1, runtime.maxSteps - runtime.transientSteps);
                resetInstanceGeometry(activeInst, capacity);
                appendPointFromInstanceState(activeInst);
                activeInst.runtime.running = true;
              }
            }
            return;
          }
          if (systemType === 'dae') {
            const cfg = compileDAE();
            const params = parseParams(ui.params.value);
            const dt = parseFloatStrict(ui.dt.value, 'dt');
            const steps = parseIntStrict(ui.steps.value, 'steps');
            const transient = parseIntStrict(ui.transient.value, 'transient');
            const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');
            if (!(dt > 0)) throw new Error('dt must be > 0.');
            if (!(steps > 10)) throw new Error('steps must be > 10.');
            if (!(transient >= 0)) throw new Error('transient must be >= 0.');
            if (transient >= steps) throw new Error('transient must be < steps.');
            if (!(ppf > 0)) throw new Error('Points/frame must be > 0.');

            runtime.systemType = 'dae';
            runtime.compiled = null;
            runtime.params = params;
            runtime.dim = cfg.dim;
            runtime.dt = dt;
            runtime.maxSteps = steps;
            runtime.transientSteps = transient;
            runtime.pointsPerFrame = Math.max(1, ppf | 0);
            runtime.solver = 'euler';
            runtime.t = 0;
            runtime.stepIndex = 0;
            runtime.skippedDerivs = 0;
            runtime.rejectedSteps = 0;

            runtime.dae.nx = cfg.nx;
            runtime.dae.ny = cfg.ny;
            runtime.dae.f = cfg.f;
            runtime.dae.g = cfg.g;
            runtime.dae.tol = cfg.tol;
            runtime.dae.maxIters = cfg.maxIters;

            const initState = parseInitForN(ui.init.value, cfg.dim);
            runtime.state = initState;
            runtime.lastGood = new Float64Array(cfg.dim);
            runtime.lastGood.set(initState);

            // Ensure initial constraints satisfied (project y at t=0)
            const proj0 = daeProjectY(runtime.state, cfg.dim, cfg.nx, cfg.ny, 0, cfg.g, cfg.tol, cfg.maxIters);
            if (!proj0.ok) throw new Error('DAE init: constraints could not be satisfied (Newton failed).');
            runtime.lastGood.set(runtime.state);

            // Projection indices
            const px = clampIndex1Based(ui.projX?.value ?? '1', runtime.dim, 1) - 1;
            const py = clampIndex1Based(ui.projY?.value ?? '2', runtime.dim, Math.min(2, runtime.dim)) - 1;
            const pz = clampIndex1Based(ui.projZ?.value ?? '3', runtime.dim, Math.min(3, runtime.dim)) - 1;
            runtime.proj = [px, py, pz];

            resetPathGeometry(Math.max(1, steps - transient));
            appendPointFromState();
            pathGeometry.setDrawRange(0, runtime.count);
            pathGeometry.attributes.position.needsUpdate = true;
            pathGeometry.attributes.color.needsUpdate = true;
            pathGeometry.computeBoundingSphere();

            applyRenderMode();
            setRunning(true);
            // Runtime is created, now create instance runtime from it
            if (activeInstanceId != null) {
              const activeInst = instances.find(i => i.id === activeInstanceId);
              if (activeInst) {
                activeInst.runtime = cloneRuntimeState(runtime);
                const capacity = Math.max(1, runtime.maxSteps - runtime.transientSteps);
                resetInstanceGeometry(activeInst, capacity);
                appendPointFromInstanceState(activeInst);
                activeInst.runtime.running = true;
              }
            }
            return;
          }

          syncDimAuto();

          const compiled = compileSystemEquations();
          const params = parseParams(ui.params.value);
          const initState = parseInit(ui.init.value);
          const dt = parseFloatStrict(ui.dt.value, 'dt');
          const sigma = parseFloatStrict(ui.sigma?.value ?? '0', 'sigma');
          const absTol = parseFloatStrict(ui.absTol?.value ?? '1e-6', 'absTol');
          const relTol = parseFloatStrict(ui.relTol?.value ?? '1e-3', 'relTol');
          const dtMin = parseFloatStrict(ui.dtMin?.value ?? '1e-6', 'dtMin');
          const dtMax = parseFloatStrict(ui.dtMax?.value ?? '0.05', 'dtMax');
          const steps = parseIntStrict(ui.steps.value, 'steps');
          const transient = parseIntStrict(ui.transient.value, 'transient');
          const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');

          if (!(dt > 0)) throw new Error('dt must be > 0.');
          if (!(absTol > 0)) throw new Error('absTol must be > 0.');
          if (!(relTol > 0)) throw new Error('relTol must be > 0.');
          if (!(dtMin > 0)) throw new Error('dtMin must be > 0.');
          if (!(dtMax > 0)) throw new Error('dtMax must be > 0.');
          if (dtMin > dtMax) throw new Error('dtMin must be <= dtMax.');
          if (!(steps > 10)) throw new Error('steps must be > 10.');
          if (!(transient >= 0)) throw new Error('transient must be >= 0.');
          if (transient >= steps) throw new Error('transient must be < steps.');

          runtime.compiled = compiled;
          runtime.params = params;
          runtime.dim = compiled.n;
          // allocate dimension-dependent buffers
          k1 = new Float64Array(runtime.dim);
          k2 = new Float64Array(runtime.dim);
          k3 = new Float64Array(runtime.dim);
          k4 = new Float64Array(runtime.dim);
          yTmp = new Float64Array(runtime.dim);
          yHigh = new Float64Array(runtime.dim);
          yLow = new Float64Array(runtime.dim);
          errVec = new Float64Array(runtime.dim);
          kStage = Array.from({ length: 7 }, () => new Float64Array(runtime.dim));

          const px = clampIndex1Based(ui.projX?.value ?? '1', runtime.dim, 1) - 1;
          const py = clampIndex1Based(ui.projY?.value ?? '2', runtime.dim, Math.min(2, runtime.dim)) - 1;
          const pz = clampIndex1Based(ui.projZ?.value ?? '3', runtime.dim, Math.min(3, runtime.dim)) - 1;
          runtime.proj = [px, py, pz];

          runtime.dt = dt;
          runtime.h = Math.max(dtMin, Math.min(dtMax, dt));
          runtime.absTol = absTol;
          runtime.relTol = relTol;
          runtime.dtMin = dtMin;
          runtime.dtMax = dtMax;
          runtime.systemType = systemType;
          runtime.sigma = sigma;
          runtime.maxSteps = steps;
          runtime.transientSteps = transient;
          runtime.pointsPerFrame = Math.max(1, ppf);
          runtime.solver = String(ui.solver.value || 'rk4');
          runtime.t = 0;
          runtime.stepIndex = 0;
          runtime.skippedDerivs = 0;
          runtime.rejectedSteps = 0;
          runtime.state = initState;
          runtime.lastGood = new Float64Array(runtime.dim);
          runtime.lastGood.set(initState);

          // Pre-allocate only for the kept points (after transient)
          resetPathGeometry(Math.max(1, steps - transient));
          appendPointFromState();
          pathGeometry.setDrawRange(0, runtime.count);
          pathGeometry.attributes.position.needsUpdate = true;
          pathGeometry.attributes.color.needsUpdate = true;
          pathGeometry.computeBoundingSphere();

          applyRenderMode();
          setRunning(true);
          // Runtime is created, now create instance runtime from it
          if (activeInstanceId != null) {
            const activeInst = instances.find(i => i.id === activeInstanceId);
            if (activeInst) {
              activeInst.runtime = cloneRuntimeState(runtime);
              const capacity = Math.max(1, runtime.maxSteps - runtime.transientSteps);
              resetInstanceGeometry(activeInst, capacity);
              appendPointFromInstanceState(activeInst);
              activeInst.runtime.running = true;
            }
          }
        } catch (err) {
          showError(`Start error:\n${String(err && err.message ? err.message : err)}`);
          setRunning(false);
        }
      }

      function validateSimulation() {
        try {
          showError('');
          const category = String(ui.systemType?.value || 'ode_nonlinear');
          const systemType = categoryToEngineType(category);
          if (!systemType) throw new Error(`This category is not implemented yet: ${category}`);

          if (category === 'algebraic' && String(ui.algMode?.value || 'parametric') === 'implicit') {
            const fText = String(ui.algF?.value || '').trim();
            if (!fText) throw new Error('Algebraic: F(x,y,z) must not be empty.');
            const iso = parseFloatExpr(ui.algIso?.value ?? '0', 'iso');
            const xmin = parseFloatExpr(ui.algXMin?.value ?? '-1', 'x min');
            const xmax = parseFloatExpr(ui.algXMax?.value ?? '1', 'x max');
            const ymin = parseFloatExpr(ui.algYMin?.value ?? '-1', 'y min');
            const ymax = parseFloatExpr(ui.algYMax?.value ?? '1', 'y max');
            const zmin = parseFloatExpr(ui.algZMin?.value ?? '-1', 'z min');
            const zmax = parseFloatExpr(ui.algZMax?.value ?? '1', 'z max');
            if (!(xmax > xmin) || !(ymax > ymin) || !(zmax > zmin)) throw new Error('Algebraic bounds must satisfy max > min.');
            // quick eval sanity
            const params = parseParams(ui.params.value);
            const f = math.compile(fText);
            const scope = { ...(params || {}), pi: Math.PI, e: Math.E, t: 0, x: xmin, y: ymin, z: zmin };
            const v = f.evaluate(scope);
            if (typeof v !== 'number' || !Number.isFinite(v)) throw new Error('F(x,y,z) did not evaluate to a finite number (check params).');
            showNotice('OK: algebraic implicit surface compiled successfully.');
            return;
          }

          if (systemType === 'pde') {
            // basic PDE validation
            parseParams(ui.params.value);
            const dt = parseFloatStrict(ui.dt.value, 'dt');
            const steps = parseIntStrict(ui.steps.value, 'steps');
            const ppf = parseIntStrict(ui.ppf.value, 'Iters/frame');
            if (!(dt > 0)) throw new Error('dt must be > 0.');
            if (!(steps > 0)) throw new Error('steps must be > 0.');
            if (!(ppf > 0)) throw new Error('Iters/frame must be > 0.');
            // stability check
            const cfg = compilePdeLinearSettings();
            const dx = (cfg.xmax - cfg.xmin) / (cfg.nx - 1);
            const dy = (cfg.ymax - cfg.ymin) / (cfg.ny - 1);
            if (cfg.alpha > 0) {
              const dtMax = 0.5 / (cfg.alpha * (1 / (dx * dx) + 1 / (dy * dy)));
              if (dt > dtMax) throw new Error(`Stability violated. Suggested dt <= ${dtMax.toExponential(3)}.`);
            }
            showNotice('OK: PDE inputs compiled successfully.');
            return;
          }
          if (systemType === 'hybrid') {
            syncDimAuto();
            compileSystemEquations();
            parseParams(ui.params.value);
            parseInit(ui.init.value);
            const dt = parseFloatStrict(ui.dt.value, 'dt');
            const steps = parseIntStrict(ui.steps.value, 'steps');
            const transient = parseIntStrict(ui.transient.value, 'transient');
            const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');
            if (!(dt > 0)) throw new Error('dt must be > 0.');
            if (!(steps > 10)) throw new Error('steps must be > 10.');
            if (!(transient >= 0)) throw new Error('transient must be >= 0.');
            if (transient >= steps) throw new Error('transient must be < steps.');
            if (!(ppf > 0)) throw new Error('Points/frame must be > 0.');
            const condText = String(ui.hybridEvent?.value || '').trim();
            if (!condText) throw new Error('Hybrid: event condition must not be empty.');
            compileHybridEventCondition(condText);
            parseHybridResetRules(ui.hybridReset?.value || '', parseIntStrict(ui.dim?.value ?? '2', 'Dimension N'));
            showNotice('OK: Hybrid inputs compiled successfully.');
            return;
          }
          if (systemType === 'dae') {
            const cfg = compileDAE();
            parseParams(ui.params.value);
            const dt = parseFloatStrict(ui.dt.value, 'dt');
            const steps = parseIntStrict(ui.steps.value, 'steps');
            const transient = parseIntStrict(ui.transient.value, 'transient');
            const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');
            if (!(dt > 0)) throw new Error('dt must be > 0.');
            if (!(steps > 10)) throw new Error('steps must be > 10.');
            if (!(transient >= 0)) throw new Error('transient must be >= 0.');
            if (transient >= steps) throw new Error('transient must be < steps.');
            if (!(ppf > 0)) throw new Error('Points/frame must be > 0.');
            // init vector length
            parseInitForN(ui.init.value, cfg.dim);
            showNotice('OK: DAE inputs compiled successfully.');
            return;
          }

          syncDimAuto();

          const compiled = compileSystemEquations();
          parseParams(ui.params.value);
          parseInit(ui.init.value);

          const dt = parseFloatStrict(ui.dt.value, 'dt');
          const steps = parseIntStrict(ui.steps.value, 'steps/iterations');
          const transient = parseIntStrict(ui.transient.value, 'transient');
          const ppf = parseIntStrict(ui.ppf.value, 'Points/frame');

          if (!(steps > 10)) throw new Error('steps/iterations must be > 10.');
          if (!(transient >= 0)) throw new Error('transient must be >= 0.');
          if (transient >= steps) throw new Error('transient must be < steps/iterations.');
          if (!(ppf > 0)) throw new Error('Points/frame must be > 0.');

          if (systemType !== 'map') {
            if (!(dt > 0)) throw new Error('dt must be > 0.');
          }

          if (systemType === 'ode' && isAdaptiveSolver(String(ui.solver?.value || 'rk4'))) {
            const absTol = parseFloatStrict(ui.absTol?.value ?? '1e-6', 'absTol');
            const relTol = parseFloatStrict(ui.relTol?.value ?? '1e-3', 'relTol');
            const dtMin = parseFloatStrict(ui.dtMin?.value ?? '1e-6', 'dtMin');
            const dtMax = parseFloatStrict(ui.dtMax?.value ?? '0.05', 'dtMax');
            if (!(absTol > 0)) throw new Error('absTol must be > 0.');
            if (!(relTol > 0)) throw new Error('relTol must be > 0.');
            if (!(dtMin > 0)) throw new Error('dtMin must be > 0.');
            if (!(dtMax > 0)) throw new Error('dtMax must be > 0.');
            if (dtMin > dtMax) throw new Error('dtMin must be <= dtMax.');
          }

          // Projection indices sanity
          const n = compiled.n;
          clampIndex1Based(ui.projX?.value ?? '1', n, 1);
          clampIndex1Based(ui.projY?.value ?? '2', n, Math.min(2, n));
          clampIndex1Based(ui.projZ?.value ?? '3', n, Math.min(3, n));

          showNotice('OK: inputs compiled successfully.');
        } catch (err) {
          showError(`Validate error:\n${String(err && err.message ? err.message : err)}`);
        }
      }

      // ---- Helper functions for syncing all instances ----
      function startAllInstances() {
        // Start each instance with its own settings (don't change any parameters)
        const savedActiveId = activeInstanceId;
        const savedUI = getInstanceSettingsFromUI(); // Save current UI state
        
        // First, save current UI to active instance if any (to preserve any changes made before starting)
        if (activeInstanceId != null) {
          const activeInst = instances.find(i => i.id === activeInstanceId);
          if (activeInst) {
            activeInst.settings = getInstanceSettingsFromUI();
          }
        }
        
        for (const inst of instances) {
          activeInstanceId = inst.id;
          // Load the instance's own settings to UI (create a copy to avoid reference issues)
          if (inst.settings) {
            // Create a shallow copy of settings object to avoid reference sharing
            const instSettings = { ...inst.settings };
            loadInstanceSettingsToUI(instSettings);
          } else {
            // If instance has no settings, use current UI (shouldn't happen, but handle gracefully)
            loadInstanceSettingsToUI(getInstanceSettingsFromUI());
          }
          try {
            startSimulation(true); // Skip saving settings - use instance's own settings
          } catch (err) {
            console.warn(`Failed to start instance ${inst.id}:`, err);
          }
        }
        // Restore active instance UI and activeInstanceId
        activeInstanceId = savedActiveId;
        if (activeInstanceId != null) {
          const activeInst = instances.find(i => i.id === activeInstanceId);
          if (activeInst && activeInst.settings) {
            loadInstanceSettingsToUI(activeInst.settings);
          }
        } else {
          // Restore saved UI if no active instance
          loadInstanceSettingsToUI(savedUI);
        }
      }

      function validateAllInstances() {
        // Validate each instance with its own settings (don't change any parameters)
        const savedActiveId = activeInstanceId;
        const savedUI = getInstanceSettingsFromUI(); // Save current UI state
        let allValid = true;
        for (const inst of instances) {
          activeInstanceId = inst.id;
          loadInstanceSettingsToUI(inst.settings);
          try {
            validateSimulation();
          } catch (err) {
            console.warn(`Instance ${inst.id} validation failed:`, err);
            allValid = false;
          }
        }
        // Restore active instance UI and activeInstanceId
        activeInstanceId = savedActiveId;
        if (activeInstanceId != null) {
          const activeInst = instances.find(i => i.id === activeInstanceId);
          if (activeInst && activeInst.settings) {
            loadInstanceSettingsToUI(activeInst.settings);
          }
        } else {
          // Restore saved UI if no active instance
          loadInstanceSettingsToUI(savedUI);
        }
        if (allValid) {
          showNotice('OK: All instances validated successfully.');
        }
      }

      function pauseAllInstances() {
        // Pause all instances
        for (const inst of instances) {
          if (inst.runtime) {
            inst.runtime.running = false;
          }
        }
        setRunning(false); // Update button text
      }

      function resumeAllInstances() {
        // Resume all instances (just set running to true, don't restart)
        for (const inst of instances) {
          if (inst.runtime) {
            inst.runtime.running = true;
          }
        }
        setRunning(true); // Update button text
      }

      function resetAllInstances() {
        // Reset all instances
        for (const inst of instances) {
          if (inst.runtime) {
            inst.runtime.running = false;
            inst.runtime.count = 0;
            if (inst.render) {
              inst.render.geometry.setDrawRange(0, 0);
            }
            inst.runtime = null;
          }
        }
        resetSimulation();
      }

      // ---- Buttons ----
      ui.start.addEventListener('click', () => {
        const syncAll = ui.syncInstances?.checked || false;
        if (syncAll && instances.length > 0) {
          startAllInstances();
        } else {
          // Start simulation for active instance (or create new if none)
          startSimulation();
        }
      });
      ui.validate?.addEventListener('click', () => {
        const syncAll = ui.syncInstances?.checked || false;
        if (syncAll && instances.length > 0) {
          validateAllInstances();
        } else {
          // Validate active instance settings (save current UI first)
          if (activeInstanceId != null) {
            const activeInst = instances.find(i => i.id === activeInstanceId);
            if (activeInst) {
              activeInst.settings = getInstanceSettingsFromUI();
              loadInstanceSettingsToUI(activeInst.settings);
            }
          }
          validateSimulation();
        }
      });
      ui.pause.addEventListener('click', () => {
        const syncAll = ui.syncInstances?.checked || false;
        if (syncAll && instances.length > 0) {
          // Toggle pause/resume for all instances
          const anyRunning = instances.some(inst => inst.runtime && inst.runtime.running) || runtime.running;
          if (anyRunning) {
            pauseAllInstances();
          } else {
            resumeAllInstances();
          }
        } else {
          // Pause/resume active instance
          if (activeInstanceId != null) {
            const activeInst = instances.find(i => i.id === activeInstanceId);
            if (activeInst && activeInst.runtime) {
              if (activeInst.runtime.running) {
                // Pause
                activeInst.runtime.running = false;
                setRunning(false);
              } else {
                // Resume: just set running to true, don't restart
                activeInst.runtime.running = true;
                setRunning(true);
              }
            } else if (runtime.running) {
              // Pause
              setRunning(false);
            } else {
              // Resume: just set running to true, don't restart
              setRunning(true);
            }
          } else {
            if (runtime.running) {
              // Pause
              setRunning(false);
            } else {
              // Resume: just set running to true, don't restart
              setRunning(true);
            }
          }
        }
      });
      ui.reset.addEventListener('click', () => {
        const syncAll = ui.syncInstances?.checked || false;
        if (syncAll && instances.length > 0) {
          resetAllInstances();
        } else {
          // Reset active instance runtime (but keep settings)
          if (activeInstanceId != null) {
            const activeInst = instances.find(i => i.id === activeInstanceId);
            if (activeInst && activeInst.runtime) {
              activeInst.runtime.running = false;
              activeInst.runtime.count = 0;
              if (activeInst.render) {
                activeInst.render.geometry.setDrawRange(0, 0);
              }
              activeInst.runtime = null;
            }
          }
          resetSimulation();
        }
      });
      if (ui.addInstance) {
        ui.addInstance.addEventListener('click', () => {
          // Save current UI to active instance, then create new instance
          if (activeInstanceId != null) {
            const activeInst = instances.find(i => i.id === activeInstanceId);
            if (activeInst) {
              activeInst.settings = getInstanceSettingsFromUI();
            }
          }
          const settings = getInstanceSettingsFromUI();
          const newInst = createInstance(null, null, settings);
          setActiveInstance(newInst.id);
        });
      }

      // ---- Wizards ----
      function splitCells(line) {
        return String(line || '').trim().split(/[,\s]+/).filter(Boolean);
      }

      // Wizards panel removed

      // ---- Settings panel wiring (no dat.gui) ----
      const settingsCache = loadSettingsCache();

      // language
      if (settings.langSelect) settings.langSelect.value = getCurrentLang();
      settings.langSelect?.addEventListener('change', () => setCurrentLang(String(settings.langSelect.value || 'vi')));

      // axes
      axes.visible = (settingsCache.axesVisible == null) ? true : !!settingsCache.axesVisible;
      if (settings.axesSelect) settings.axesSelect.value = axes.visible ? '1' : '0';
      settings.axesSelect?.addEventListener('change', () => {
        axes.visible = String(settings.axesSelect.value) === '1';
        saveSettingsCache({ axesVisible: axes.visible });
      });

      // render mode
      // Use var to avoid TDZ issues: applyRenderMode() can be called before this block runs.
      var currentMode = (settingsCache.renderMode === 'Points' || settingsCache.renderMode === 'Line') ? settingsCache.renderMode : 'Points';
      function applyRenderMode() {
        if (!renderObjectsReady) return;
        const isPoints = String(currentMode || 'Line') === 'Points';
        const isPde = runtime.systemType === 'pde';
        const isImplicit = runtime.systemType === 'implicit';
        const hasInstances = instances.length > 0;
        // PDE/Implicit use their own meshes; ignore path render modes
        // Hide legacy pathLine/pathPoints when instances exist
        pathPoints.visible = !(isPde || isImplicit) && isPoints && !hasInstances;
        pathLine.visible = !(isPde || isImplicit) && !isPoints && !hasInstances;
        if (pdeSurface.mesh) pdeSurface.mesh.visible = isPde;
        if (implicitSurface.mesh) implicitSurface.mesh.visible = isImplicit && !isPoints;
        if (implicitSurface.points) implicitSurface.points.visible = isImplicit && isPoints;
        // Apply render mode to all instances
        for (const inst of instances) {
          if (inst.render) {
            // Instances don't support PDE/Implicit, so just toggle line/points
            inst.render.line.visible = inst.visible && !isPoints;
            inst.render.points.visible = inst.visible && isPoints;
          }
        }
      }
      if (settings.modeSelect) settings.modeSelect.value = currentMode;
      settings.modeSelect?.addEventListener('change', () => {
        currentMode = String(settings.modeSelect.value || 'Line');
        saveSettingsCache({ renderMode: currentMode });
        applyRenderMode();
      });
      applyRenderMode();

      // point size
      function clampPointSize(v) {
        return Math.max(0.001, Math.min(0.08, Number(v) || 0.01));
      }
      function setPointSize(v) {
        const s = clampPointSize(v);
        pointsMaterial.size = s;
        pointsMaterial.needsUpdate = true;
        if (implicitSurface.pointsMaterial) {
          implicitSurface.pointsMaterial.size = s;
          implicitSurface.pointsMaterial.needsUpdate = true;
        }
        if (settings.pointSize) settings.pointSize.value = String(s);
        if (settings.pointSizeNum) settings.pointSizeNum.value = String(s);
      }
      setPointSize((settingsCache.pointSize != null) ? settingsCache.pointSize : (pointsMaterial.size ?? 0.01));
      settings.pointSize?.addEventListener('input', () => {
        setPointSize(settings.pointSize.value);
        saveSettingsCache({ pointSize: clampPointSize(settings.pointSize.value) });
      });
      settings.pointSizeNum?.addEventListener('input', () => {
        setPointSize(settings.pointSizeNum.value);
        saveSettingsCache({ pointSize: clampPointSize(settings.pointSizeNum.value) });
      });

      // camera move speed (keyboard)
      function clampCamSpeed(v) {
        return Math.max(0.2, Math.min(3.5, Number(v) || 1.0));
      }
      function setCamSpeed(v) {
        const s = clampCamSpeed(v);
        cameraMoveSpeed = s;
        if (settings.camSpeed) settings.camSpeed.value = String(s);
        if (settings.camSpeedNum) settings.camSpeedNum.value = String(s);
      }
      setCamSpeed((settingsCache.cameraSpeed != null) ? settingsCache.cameraSpeed : 1.0);
      settings.camSpeed?.addEventListener('input', () => {
        setCamSpeed(settings.camSpeed.value);
        saveSettingsCache({ cameraSpeed: clampCamSpeed(settings.camSpeed.value) });
      });
      settings.camSpeedNum?.addEventListener('input', () => {
        setCamSpeed(settings.camSpeedNum.value);
        saveSettingsCache({ cameraSpeed: clampCamSpeed(settings.camSpeedNum.value) });
      });

      // mouse lock + sensitivity
      setPointerLockEnabled(settingsCache.mouseLock != null ? !!settingsCache.mouseLock : false);
      setMouseSensitivity((settingsCache.mouseSensitivity != null) ? settingsCache.mouseSensitivity : 1.0);
      settings.mouseSense?.addEventListener('input', () => setMouseSensitivity(settings.mouseSense.value));
      settings.mouseSenseNum?.addEventListener('input', () => setMouseSensitivity(settings.mouseSenseNum.value));

      // reset view
      settings.resetView?.addEventListener('click', () => resetView());

      // ---- Animation loop ----
      // Lag / freeze watchdog: if frames are consistently too slow, auto-stop and show suggestions.
      let _tickPrevMs = getNowMs();
      let _lagConsecutive = 0;
      const LAG_FRAME_MS = 450;     // frame gap threshold
      const LAG_SOLVE_MS = 180;     // solver time threshold inside tick
      const LAG_CONSEC_LIMIT = 3;   // sustained slow frames before stopping

      function buildLagSuggestions() {
        const category = String(ui.systemType?.value || '');
        const isPde = category === 'pde_linear' || category === 'pde_nonlinear' || runtime.systemType === 'pde';
        const lines = [];
        if (isPde) {
          lines.push('- Reduce **Nx/Ny** (grid size)');
          lines.push('- Reduce **Iters/frame**');
          lines.push('- Reduce **steps**');
        } else {
          lines.push('- Reduce **Points/frame**');
          lines.push('- Reduce **steps**');
        }
        lines.push('- Close other heavy tabs/apps; try refreshing the page');
        return lines.join('\n');
      }

      function tick() {
        const nowMs = getNowMs();
        const frameGap = nowMs - _tickPrevMs;
        _tickPrevMs = nowMs;

        // keyboard movement (game-like hold keys)
        const nowMoveMs = nowMs;
        const dtMoveSec = Math.min(0.05, Math.max(0, (nowMoveMs - _movePrevMs) / 1000));
        _movePrevMs = nowMoveMs;

        // Web-FPS: apply mouse-look once per frame (before movement)
        if (pointerLocked) applyFpMouseLookFrame(frameGap);
        applyKeyboardMove(dtMoveSec);

        // OrbitControls.update() can fight FPS quaternion while pointer-locked (causes snapping).
        if (!pointerLocked) controls.update();

        const solveStart = getNowMs();
        streamSolveChunk();
        const solveEnd = getNowMs();
        const solveMs = solveEnd - solveStart;

        // Detect sustained lag; stop simulation to avoid "frozen" feeling.
        // While user is actively controlling the camera, rendering cost can spike (frameGap),
        // but that shouldn't auto-stop the simulation. Solver lag (solveMs) still counts.
        const userInteracting = pointerLocked || anyMoveKeyDown();
        const tooSlowSolve = (solveMs > LAG_SOLVE_MS);
        const tooSlowFrame = (frameGap > LAG_FRAME_MS);
        const tooSlow = tooSlowSolve || (tooSlowFrame && !userInteracting);
        if (runtime.running && tooSlow) _lagConsecutive++;
        else _lagConsecutive = 0;

        if (runtime.running && _lagConsecutive >= LAG_CONSEC_LIMIT) {
          setRunning(false);
          _lagConsecutive = 0;
          showError(
            `Performance warning (auto-stopped):\n` +
            `This device is struggling to keep up.\n` +
            `frameGap=${frameGap.toFixed(0)}ms, solve=${solveMs.toFixed(0)}ms\n\n` +
            `Suggestions:\n${buildLagSuggestions()}`
          );
        }

        if (ui.stats) {
          if (runtime.systemType === 'pde') {
            const p = runtime.pde;
            ui.stats.innerHTML =
              `mode=<code>pde</code> ` +
              `t=<code>${runtime.t.toFixed(4)}</code> ` +
              `step=<code>${runtime.stepIndex}</code>/<code>${runtime.maxSteps}</code> ` +
              `grid=<code>${p.nx}×${p.ny}</code> ` +
              `range=<code>[${Number(p.uMin).toExponential(2)}, ${Number(p.uMax).toExponential(2)}]</code> ` +
              `iters/frame=<code>${runtime.pointsPerFrame | 0}</code> ` +
              `solve=<code>${solveMs.toFixed(0)}ms</code>`;
          } else {
          const hInfo = isAdaptiveSolver(runtime.solver) ? ` h=<code>${runtime.h.toExponential(2)}</code> rej=<code>${runtime.rejectedSteps}</code>` : '';
          const modeInfo = ` mode=<code>${runtime.systemType}</code>` + (runtime.systemType === 'sde' ? ` sigma=<code>${Number(runtime.sigma).toExponential(2)}</code>` : '');
          ui.stats.innerHTML =
            `t=<code>${runtime.t.toFixed(4)}</code> ` +
            `step=<code>${runtime.stepIndex}</code> ` +
            `points=<code>${runtime.count}</code> ` +
            `skippedDerivs=<code>${runtime.skippedDerivs}</code>` +
            hInfo +
              modeInfo +
              ` solve=<code>${solveMs.toFixed(0)}ms</code>`;
          }
        }
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }

      function syncSystemTypeUI() {
        const category = String(ui.systemType?.value || 'ode_nonlinear');
        const st = categoryToEngineType(category) || 'ode';
        // Restore remembered solver for this category when appropriate.
        restoreSolverPrefForCategory(category);
        // Map: hide dt + ODE solver/adaptive; SDE: show dt + sigma, hide ODE solver/adaptive.
        // Param: show dt + hide ODE solver/adaptive/sigma.
        if (ui.dtBox) ui.dtBox.style.display = (st === 'map') ? 'none' : 'block';
        const showSolver = (st === 'ode' || st === 'hybrid' || st === 'dae');
        if (ui.odeRow) ui.odeRow.style.display = showSolver ? 'grid' : 'none';
        if (ui.sdeRow) ui.sdeRow.style.display = (st === 'sde') ? 'grid' : 'none';
        const lang = getCurrentLang();
        const d = I18N[lang] || I18N.vi;
        if (ui.stepsLabel) ui.stepsLabel.textContent = (st === 'map') ? d.iterations : (st === 'param') ? d.samples : d.steps;
        if (ui.dtLabel) ui.dtLabel.textContent = (st === 'sde') ? d.dtSde : (st === 'param') ? d.dtParam : d.dt;

        // PDE mode: show PDE inputs and hide ODE/vector-state controls
        const isPde = st === 'pde';
        if (ui.pdeSection) ui.pdeSection.style.display = isPde ? 'block' : 'none';
        if (ui.pdeBox) ui.pdeBox.style.display = isPde ? 'block' : 'none';
        const isPdeNonlinear = category === 'pde_nonlinear';
        if (ui.pdeNonlinearRow) ui.pdeNonlinearRow.style.display = (isPde && isPdeNonlinear) ? 'block' : 'none';
        const isDae = st === 'dae';
        if (ui.daeSection) ui.daeSection.style.display = isDae ? 'block' : 'none';
        if (ui.daeBox) ui.daeBox.style.display = isDae ? 'block' : 'none';

        const isHybrid = st === 'hybrid';
        if (ui.hybridSection) ui.hybridSection.style.display = isHybrid ? 'block' : 'none';
        if (ui.hybridBox) ui.hybridBox.style.display = isHybrid ? 'block' : 'none';

        const isAlg = category === 'algebraic';
        if (ui.algSection) ui.algSection.style.display = isAlg ? 'block' : 'none';
        if (ui.algBox) ui.algBox.style.display = isAlg ? 'block' : 'none';
        const algMode = String(ui.algMode?.value || 'parametric');
        const isAlgImplicit = isAlg && algMode === 'implicit';
        if (ui.algImplicitRow) ui.algImplicitRow.style.display = isAlgImplicit ? 'block' : 'none';
        updateRenderModeOptionLabels(getCurrentLang());
        if (ui.dimProjRow) ui.dimProjRow.style.display = isPde ? 'none' : 'grid';
        if (ui.eqModeRow) ui.eqModeRow.style.display = (isPde || isDae || isAlgImplicit) ? 'none' : 'block';
        const vecRow = ui.eqs ? ui.eqs.closest('.row') : null;
        if (ui.simpleEqs) ui.simpleEqs.style.display = (isPde || isDae || isAlgImplicit) ? 'none' : ui.simpleEqs.style.display;
        if (vecRow) vecRow.style.display = (isPde || isDae || isAlgImplicit) ? 'none' : vecRow.style.display;
        if (ui.initRow) ui.initRow.style.display = (isPde || isAlgImplicit) ? 'none' : 'grid';
        if (!isPde && !isDae && !isAlgImplicit) syncEqModeUI();
        applyRenderMode();

        // Streaming controls: transient doesn't apply to PDE; ppf becomes iterations/frame
        if (ui.transientBox) ui.transientBox.style.display = isPde ? 'none' : 'block';
        if (ui.ppfLabel) ui.ppfLabel.textContent = isPde ? ((lang === 'vi') ? 'Vòng lặp/frame' : 'Iters/frame') : d.ppf;

        // Solver-dependent visibility (ODE only)
        const isOde = st === 'ode';
        const adaptive = isOde && isAdaptiveSolver(String(ui.solver?.value || 'rk4'));
        if (ui.adaptiveRow1) ui.adaptiveRow1.style.display = adaptive ? 'grid' : 'none';
        if (ui.adaptiveRow2) ui.adaptiveRow2.style.display = adaptive ? 'grid' : 'none';

        // DAE: force Euler and hide adaptive rows (not supported)
        if (st === 'dae' && ui.solver) ui.solver.value = 'euler';
        if (ui.solver) ui.solver.disabled = (st === 'dae'); // DAE is Euler-only
        // Hybrid: fixed-step only
        if (st === 'hybrid' && ui.solver) {
          const s = String(ui.solver.value || 'rk4');
          if (isAdaptiveSolver(s)) ui.solver.value = 'rk4';
        }
      }
      ui.systemType?.addEventListener('change', () => syncSystemTypeUI());
      ui.solver?.addEventListener('change', () => {
        const category = String(ui.systemType?.value || 'ode_nonlinear');
        const st = categoryToEngineType(category) || 'ode';
        if (st === 'ode' || st === 'hybrid') {
          saveSolverPrefForCategory(category, ui.solver.value);
        }
        syncSystemTypeUI();
      });
      ui.algMode?.addEventListener('change', () => {
        // In algebraic mode, switching parametric/implicit should auto-pick a matching preset.
        if (String(ui.systemType?.value || '') === 'algebraic') {
          populatePresetDropdown(ui.preset.value);
          const want = pickAlgebraicPresetForMode(getAlgMode());
          if (want && Array.from(ui.preset.options).some(o => o.value === want)) ui.preset.value = want;
          setPreset(ui.preset.value);
          updatePresetButtons();
        }
        syncSystemTypeUI();
      });
      syncSystemTypeUI();

      // ---- Resize ----
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // ---- Boot ----
      axes.visible = true;
      resetSimulation();
      requestAnimationFrame(tick);
    })();

    // Anti 3rd-party injected overlays/bars (common on some hosting / extensions).
    // Conservative: only removes elements that look like injected overlays with extreme z-index,
    // and never removes our app UI by id.
    function removeThirdPartyDiv() {
      const KEEP_IDS = new Set([
        'app', 'ui-panel', 'settings-panel', 'open-settings',
        'error', 'notice', 'crosshair'
      ]);

      let removed = false;
      const candidates = document.querySelectorAll('div, iframe');
      for (const el of candidates) {
        if (!(el instanceof HTMLElement)) continue;
        if (el.id && KEEP_IDS.has(el.id)) continue;
        if (el.closest && el.closest('#ui-panel, #settings-panel')) continue;

        const cs = window.getComputedStyle(el);
        const pos = cs.position;
        const z = Number.parseInt(cs.zIndex || '0', 10);
        const h = el.getBoundingClientRect ? el.getBoundingClientRect().height : 0;

        // Case 1: the known bottom bar pattern you hit before (keep it working)
        const styleAttr = (el.getAttribute && el.getAttribute('style')) ? String(el.getAttribute('style')) : '';
        const looksLikeBottomBar =
          styleAttr.includes('position: fixed') &&
          (styleAttr.includes('bottom: 0%') || styleAttr.includes('bottom:0')) &&
          (styleAttr.includes('left: 0%') || styleAttr.includes('left:0')) &&
          (styleAttr.includes('right: 0%') || styleAttr.includes('right:0')) &&
          styleAttr.includes('width: 100%') &&
          (styleAttr.includes('height: 55px') || styleAttr.includes('height:55px')) &&
          (styleAttr.includes('z-index: 9999') || styleAttr.includes('z-index:9999'));

        // Case 2: generic injected overlay (very high z-index + fixed) often containing iframes/ads
        const hasIframe = !!el.querySelector?.('iframe');
        const text = (el.textContent || '').toLowerCase();
        const looksLikeAd =
          text.includes('advert') || text.includes('ads') || text.includes('sponsored') ||
          text.includes('buy now') || text.includes('download');

        const looksLikeOverlay =
          pos === 'fixed' &&
          Number.isFinite(z) &&
          z >= 9999 &&
          // avoid removing tiny legit UI; injected bars/overlays are usually not tiny
          h >= 30;

        // Remove only if we have strong signals
        if (looksLikeBottomBar || (looksLikeOverlay && (hasIframe || looksLikeAd))) {
          el.remove();
          removed = true;
        }
      }
      return removed;
    }

    // Keep it enforced: observe DOM changes + periodic fallback
    (() => {
      try { removeThirdPartyDiv(); } catch (_) {}
      try {
        const obs = new MutationObserver(() => {
          try { removeThirdPartyDiv(); } catch (_) {}
        });
        obs.observe(document.body, { childList: true, subtree: true });
      } catch (_) {}
      window.setInterval(() => {
        try { removeThirdPartyDiv(); } catch (_) {}
      }, 1000);
    })();
  </script>

  <!-- Help Modal -->
  <div id="help-modal">
    <div id="help-modal-content">
      <button id="help-modal-close" title="Close">×</button>
      <div id="help-modal-title"></div>
      <div id="help-modal-body"></div>
    </div>
  </div>
</body>
</html>

